<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>一线攻城狮</title>
  
  <subtitle>十年磨一剑，一步一步脚踏实地的耕种</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://researchlab.github.io/"/>
  <updated>2018-10-18T05:08:14.830Z</updated>
  <id>http://researchlab.github.io/</id>
  
  <author>
    <name>Lee Hong</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Docker操作提示Get Permission Denied</title>
    <link href="http://researchlab.github.io/2018/06/06/docker-permission-denied/"/>
    <id>http://researchlab.github.io/2018/06/06/docker-permission-denied/</id>
    <published>2018-06-06T15:40:41.000Z</published>
    <updated>2018-10-18T05:08:14.830Z</updated>
    
    <content type="html"><![CDATA[<p>在ubuntu16.04上重新安装docker后，执行docker相关命令，出现”Got permission denied”提示,如下,<br><a id="more"></a><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">~ » docker ps </span><br><span class="line">Got permission denied while trying to connect to the Docker daemon socket at unix:///var/run/docker.sock: Get http://%2Fvar%2Frun%2Fdocker.sock/v1.37/containers/json: dial unix /var/run/docker.sock: connect: permission denied</span><br></pre></td></tr></table></figure></p><h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><p>摘自docker mannual上的一段话<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Manage Docker as a non-root user</span><br><span class="line"></span><br><span class="line">The docker daemon binds to a Unix socket instead of a TCP port. By default that Unix socket is owned by the user root and other users can only access it using sudo. The docker daemon always runs as the root user.</span><br><span class="line"></span><br><span class="line">If you don’t want to use sudo when you use the docker command, create a Unix group called docker and add users to it. When the docker daemon starts, it makes the ownership of the Unix socket read/writable by the docker group.</span><br></pre></td></tr></table></figure></p><p>大概的意思就是：docker进程使用Unix Socket而不是TCP端口。而默认情况下，Unix socket属于root用户，需要root权限才能访问。</p><h2 id="解决方法"><a href="#解决方法" class="headerlink" title="解决方法"></a>解决方法</h2><p>docker守护进程启动的时候，会默认赋予名字为docker的用户组读写Unix socket的权限，因此只要创建docker用户组，并将当前用户加入到docker用户组中，那么当前用户就有权限访问Unix socket了，进而也就可以执行docker相关命令;<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">sudo groupadd docker#添加docker用户组</span><br><span class="line">sudo gpasswd -a $USER docker #将登陆用户加入到docker用户组中</span><br><span class="line">newgrp docker#更新用户组</span><br><span class="line">docker ps#测试docker命令是否可以使用sudo正常使用</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在ubuntu16.04上重新安装docker后，执行docker相关命令，出现”Got permission denied”提示,如下,&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="docker-practice" scheme="http://researchlab.github.io/categories/docker-practice/"/>
    
    
      <category term="docker" scheme="http://researchlab.github.io/tags/docker/"/>
    
  </entry>
  
  <entry>
    <title>redis专题04 数据结构之redis位图系列问题</title>
    <link href="http://researchlab.github.io/2018/01/19/redis-04-bitmap/"/>
    <id>http://researchlab.github.io/2018/01/19/redis-04-bitmap/</id>
    <published>2018-01-19T11:17:30.000Z</published>
    <updated>2018-10-18T05:08:14.838Z</updated>
    
    <content type="html"><![CDATA[<p><code>redis</code>位图数据结构<code>bitmap</code>将很多小的整数储存到一个长度较大的位图中， 又或者将一个非常庞大的键分割为多个较小的键来进行储存，从而非常高效地使用内存，使得<code>redis</code>能够得到更多诸多场景中如用户签到、统计活跃用户、用户在线状态等</p><blockquote><p>此外, <code>bitfield</code>能够以指定的方式对计算溢出进行控制的能力，使得它特别适合应用于实时分析领域；<br><a id="more"></a></p></blockquote><p>用户签到场景中, 签了记录<code>1</code>，没签<code>0</code>，如果使用普通的<code>key/value</code>结构，每个用户一年要记录<code>365</code>个，当用户上亿的时候，需要的存储空间是惊人的。采用<code>redis位图数据结构bitmap</code>，这样每天的签到记录只占据一个位，<code>365</code>天就是<code>365</code>个位，8个bit一个byte, 折算一下<code>46</code>个字节就可以完全容纳下，这就大大节约了存储空间。</p><p>当我们要统计月活的时候，因为需要去重，需要使用<code>set</code>来记录所有活跃用户的<code>id</code>，这非常浪费内存。这时就可以考虑使用位图来标记用户的活跃状态。每个用户会都在这个位图的一个确定位置上，<code>0</code>表示不活跃，<code>1</code>表示活跃。然后到月底遍历一次位图就可以得到月度活跃用户数。不过这个方法也是有条件的，那就是<code>userid</code>是整数连续的，并且活跃占比较高，否则可能得不偿失。</p><h4 id="位图操作"><a href="#位图操作" class="headerlink" title="位图操作"></a>位图操作</h4><p><code>redis</code>位图是通过一个<code>bit</code>位来表示某个元素对应的值或者状态, 其中的key就是对应元素本身，当然<code>redis</code>位数组是自动扩展，如果设置了某个偏移位置超出了现有的内容范围，就会自动将位数组进行零扩充。</p><p>位图不是特殊的数据结构，它的内容其实就是普通的字符串，也就是<code>byte</code>数组。可以使用普通的<code>get/set</code>直接获取和设置整个位图的内容，从<code>redis2.2.0</code>版本开始新增了<code>setbit</code>,<code>getbit</code>,<code>bitcount</code>等几个<code>bitmap</code>相关命令， 也可以使用位图操作<code>getbit/setbit</code>等将<code>byte</code>数组看成<code>「位数组」</code>来处理。</p><p>8个bit组成一个Byte，可以通过<code>setbit/getbit</code>来操作单个位但是比较麻烦，但这也正是bitmap本身会极大的节省储存空间， 当然也可以通过<code>bitfield</code>命令来操作多个位。</p><p>以设置一个字符<code>h</code>为示例<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">字符h对应的8位bit是: 0b1101000  (依次从高位到低位)</span><br></pre></td></tr></table></figure></p><p>从上述可知 只需要设置位图的第1、2，4位置为1 ，即完成设置字符串h的操作，<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; setbit s 1 1</span><br><span class="line">(integer) 0</span><br><span class="line">127.0.0.1:6379&gt; setbit s 2 1</span><br><span class="line">(integer) 0</span><br><span class="line">127.0.0.1:6379&gt; setbit s 4 1</span><br><span class="line">(integer) 0</span><br><span class="line">127.0.0.1:6379&gt; get s</span><br><span class="line">"h"</span><br><span class="line">127.0.0.1:6379&gt;</span><br></pre></td></tr></table></figure></p><p>上述设置是通过<code>setbit</code>分3次设置，然后通过<code>get</code>操作一次取出8bit 得字符<code>h</code>, 也即<code>零存整取</code>的意思, 同样可以通过<code>set s h</code>配合<code>getbit 1</code> 来做到<code>整存零取</code>，或者<code>setbit/getbit</code>实现按位存入读取操作;</p><blockquote><p>如果对应位的字节是不可打印字符，redis-cli 会显示该字符的 16 进制形式。</p></blockquote><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; setbit x 0 1</span><br><span class="line">(integer) 0</span><br><span class="line">127.0.0.1:6379&gt; setbit x 1 1</span><br><span class="line">(integer) 0</span><br><span class="line">127.0.0.1:6379&gt; get x</span><br><span class="line">"\xc0"</span><br></pre></td></tr></table></figure><h4 id="bitcount-bitpos-应用"><a href="#bitcount-bitpos-应用" class="headerlink" title="bitcount/bitpos 应用"></a>bitcount/bitpos 应用</h4><p><code>redis</code>提供了位图统计指令<code>bitcount</code>和位图查找指令<code>bitpos</code>，<code>bitcount</code>用来统计指定位置范围内<code>1</code>的个数，<code>bitpos</code>用来查找指定范围内出现的第一个<code>0</code>或<code>1</code>。</p><p>比如我们可以通过<code>bitcount</code>统计用户一共签到了多少天，通过<code>bitpos</code>指令查找用户从哪一天开始第一次签到。如果指定了范围参数<code>[start, end]</code>，就可以统计在某个时间范围内用户签到了多少天，用户自某天以后的哪天开始签到。</p><blockquote><p>但<code>start</code>和<code>end</code>参数是<code>字节索引</code>，也就是说指定的位范围必须是<code>8</code>的倍数，而不能任意指定。正因此无法直接计算某个月内用户签到了多少天，而必须要将这个月所覆盖的字节内容全部取出来 (<code>getrange</code>可以取出字符串的子串) 然后在内存里进行统计，这个非常繁琐。</p></blockquote><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; set s hello</span><br><span class="line">OK</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 统计所有`1`的个数</span></span><br><span class="line">127.0.0.1:6379&gt; bitcount s</span><br><span class="line">(integer) 21</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 统计第一个字符中1个个数</span></span><br><span class="line">127.0.0.1:6379&gt; bitcount s 0 0</span><br><span class="line">(integer) 3</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 统计前两个字符中1的个数</span></span><br><span class="line">127.0.0.1:6379&gt; bitcount s 0 1</span><br><span class="line">(integer) 7</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 第一个0 位置</span></span><br><span class="line">127.0.0.1:6379&gt; bitpos s 0</span><br><span class="line">(integer) 0</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash">第一个1 位置</span></span><br><span class="line">127.0.0.1:6379&gt; bitpos s 1</span><br><span class="line">(integer) 1</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash">从第二个字符开始的第一个1位置</span></span><br><span class="line">127.0.0.1:6379&gt; bitpos s 1 1 1</span><br><span class="line">(integer) 9</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash">从第三个字符开始的第一个1位置</span></span><br><span class="line">127.0.0.1:6379&gt; bitpos s 1 2 2</span><br><span class="line">(integer) 17</span><br><span class="line">127.0.0.1:6379&gt;</span><br></pre></td></tr></table></figure><h4 id="bitfield应用"><a href="#bitfield应用" class="headerlink" title="bitfield应用"></a>bitfield应用</h4><p><code>redis3.2</code>版本以后新增了一条<code>bitfield</code>命令，借助<code>bitfield</code>命令可以一次进行多个位的操作。</p><p><code>bitfield</code>有三个子指令，分别是<code>get/set/incrby</code>，它们都可以对指定位片段进行读写，但是最多只能处理<code>64</code>个连续的位，如果超过<code>64</code>位，就得使用多个子指令，当然<code>bitfield</code>可以一次执行多个子指令。<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; set s hello</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; bitfield s get u4 0 # 从第一个位开始取 4 个位，结果是无符号数 (u)</span><br><span class="line">1) (integer) 6</span><br><span class="line">127.0.0.1:6379&gt; bitfield s get u3 2 # 从第三个位开始取 3 个位，结果是无符号数 (u)</span><br><span class="line">1) (integer) 5</span><br><span class="line">127.0.0.1:6379&gt; bitfield s get i4 0 # 从第一个位开始取 4 个位，结果是无符号数 (i)</span><br><span class="line">1) (integer) 6</span><br><span class="line">127.0.0.1:6379&gt; bitfield s get i3 2 # 从第三个位开始取 3 个位，结果是无符号数 (i)</span><br><span class="line">1) (integer) -3</span><br><span class="line"><span class="meta">#</span><span class="bash"> 同时执行多条命令</span></span><br><span class="line">127.0.0.1:6379&gt; bitfield s get u4 0 get u3 2 get i4 0 get i3 2</span><br><span class="line">1) (integer) 6</span><br><span class="line">2) (integer) 5</span><br><span class="line">3) (integer) 6</span><br><span class="line">4) (integer) -3</span><br><span class="line"><span class="meta">#</span><span class="bash">将将第二个字符e改成a，a的 ASCII 码是 97</span></span><br><span class="line">127.0.0.1:6379&gt; bitfield s set u8 8 97</span><br><span class="line">1) (integer) 101</span><br><span class="line">127.0.0.1:6379&gt; get s</span><br><span class="line">"hallo"</span><br><span class="line"><span class="meta">#</span><span class="bash"> 注意当设置位数不是8的整数倍，如下是7位时，会导致位数不对无法有效显示字符，redis直接显示出16进制代替</span></span><br><span class="line">127.0.0.1:6379&gt; bitfield s set u8 7 96</span><br><span class="line">1) (integer) 48</span><br><span class="line">127.0.0.1:6379&gt; get s</span><br><span class="line">"h\xc1llo"</span><br></pre></td></tr></table></figure></p><blockquote><p>所谓有符号数是指获取的位数组中第一个位是符号位，剩下的才是值。如果第一位是 1，那就是负数;</p></blockquote><blockquote><p>无符号数表示非负数，没有符号位，获取的位数组全部都是值;</p></blockquote><blockquote><p>有符号数最多可以获取 64 位，无符号数只能获取 63 位 (因为 Redis 协议中的 integer 是有符号数，最大 64 位，不能传递 64 位无符号值)。如果超出限制， redis会报错;</p></blockquote><p><code>bitfield</code>还有一个命令<code>incrby</code>，它用来对指定范围的位进行自增操作；</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; set s hello</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; bitfield s incrby u4 2 1</span><br><span class="line">1) (integer) 11</span><br></pre></td></tr></table></figure><blockquote><p>既然提到自增，就有可能出现溢出。如果增加了正数，会出现上溢，如果增加的是负数，就会出现下溢出;</p></blockquote><blockquote><p><code>Redis</code>默认的处理是折返。如果出现了溢出，就将溢出的符号位丢掉。如果是 8 位无符号数 255，加 1 后就会溢出，会全部变零。如果是 8 位有符号数 127，加 1 后就会溢出变成 -128。</p></blockquote><h4 id="bitfield-自增溢出策略overflow"><a href="#bitfield-自增溢出策略overflow" class="headerlink" title="bitfield 自增溢出策略overflow"></a>bitfield 自增溢出策略overflow</h4><p><code>bitfield</code>指令提供了溢出策略子指令<code>overflow</code>，用户可以选择溢出行为，默认是折返<code>(wrap)</code>，还可以选择失败<code>(fail)</code>报错不执行，以及饱和截断<code>(sat)</code>，超过了范围就停留在最大最小值。<code>overflow</code>指令只影响接下来的第一条指令，这条指令执行完后溢出策略会变成默认值折返<code>(wrap)</code></p><p><strong>饱和截断策略 SAT</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; set s 0111 0101</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; bitfield s overflow sat incrby u4 1 1</span><br><span class="line">1) (integer) 15</span><br><span class="line">127.0.0.1:6379&gt; bitfield s overflow sat incrby u4 1 1 # 保持最大值</span><br><span class="line">1) (integer) 15</span><br></pre></td></tr></table></figure><p>分析<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">字符'u'的ACSII二进制表示为 0111 0101</span><br><span class="line">字符'u' 8bit 在位图数组中的位置如下</span><br><span class="line">bitmap下标  0 1 2 3 4 5 6 7</span><br><span class="line">'u'8bit分布 0 1 1 1 0 1 0 1</span><br><span class="line"></span><br><span class="line">指令，bitfield s overflow sat incrby u4 1 1</span><br><span class="line">表示从 第一位置依次取四个位置值出来 加上一个1</span><br><span class="line">从第一位置依次取出四个位置值 为 bitmap下标1到4直接的值 即 1110 在加1 就是1111</span><br></pre></td></tr></table></figure></p><p><strong>失败不执行策略 FAIL</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; set s what</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; bitfield s overflow fail incrby u4 1 1</span><br><span class="line">1) (integer) 15</span><br><span class="line">127.0.0.1:6379&gt; bitfield s overflow fail incrby u4 1 1</span><br><span class="line">1) (nil)</span><br><span class="line">127.0.0.1:6379&gt; bitfield s overflow fail incrby u4 1 1 # 失败不在执行</span><br><span class="line">1) (nil)</span><br><span class="line">127.0.0.1:6379&gt;</span><br></pre></td></tr></table></figure><p>分析同上</p><h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><hr><ul><li><p>给出了<code>redis</code>位图数据结构<code>bitmap</code>的基本概念，操作及应用场景;</p></li><li><p>以签到场景为例 引入<code>bitcount/bitpos</code>在实际案例中的应用分析;</p></li><li><p>以依次操作多个位，引入<code>bitfield</code>指令，并对<code>bitfield</code>三个子指令<code>get/set/incrby</code>进行了实例分析说明；</p></li><li><p>进一步对<code>bitfield</code>的<code>incrby</code>操作溢出情况，从<code>redis</code>给出的三种溢出策略折返<code>(wrap)</code>，选择失败<code>(fail)</code>报错不执行，饱和截断<code>(sat)</code>进行了实例使用说明;</p></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;code&gt;redis&lt;/code&gt;位图数据结构&lt;code&gt;bitmap&lt;/code&gt;将很多小的整数储存到一个长度较大的位图中， 又或者将一个非常庞大的键分割为多个较小的键来进行储存，从而非常高效地使用内存，使得&lt;code&gt;redis&lt;/code&gt;能够得到更多诸多场景中如用户签到、统计活跃用户、用户在线状态等&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;此外, &lt;code&gt;bitfield&lt;/code&gt;能够以指定的方式对计算溢出进行控制的能力，使得它特别适合应用于实时分析领域；&lt;br&gt;&lt;/p&gt;&lt;/blockquote&gt;
    
    </summary>
    
      <category term="redis专题" scheme="http://researchlab.github.io/categories/redis%E4%B8%93%E9%A2%98/"/>
    
    
      <category term="redis" scheme="http://researchlab.github.io/tags/redis/"/>
    
  </entry>
  
  <entry>
    <title>redis专题03 消息队列系列问题</title>
    <link href="http://researchlab.github.io/2018/01/18/redis-03-delay-queue/"/>
    <id>http://researchlab.github.io/2018/01/18/redis-03-delay-queue/</id>
    <published>2018-01-18T10:20:31.000Z</published>
    <updated>2018-10-18T05:08:14.838Z</updated>
    
    <content type="html"><![CDATA[<p>很多业务场景中多会用到消息队列来传递消息数据问题， 常用的消息队列如<code>NSQ</code>,<code>NAS</code>, <code>Rabbitmq</code>和<code>Kafka</code>等重量级消息队列中间件，功能很强大 使用起来自然也复杂，其实在大部分场景只是需要一个消息队列来传递数据，数据量，数据之间的顺序等也没有特殊的要求， 这样的场景使用<code>redis</code>非常轻松就可以搞定，而且在使用和维护上相对而言要简单方便些,当然<code>redis</code>的消息队列不是专业的消息队列，它没有非常多的高级特性，没有<code>ack</code>保证，如果对消息的可靠性有着极致的追求，那么它就不适合使用；<br><a id="more"></a></p><p>新秀<code>NQS</code>集群搭建相对简单，文档也很简介易懂，但其维护性和代码嵌入性上来讲要比用<code>redis消息队列</code>复杂的多， 此外使用过<code>Rabbitmq</code>的同学知道它使用起来有多复杂，发消息之前要创建<code>Exchange</code>，再创建<code>Queue</code>，还要将 <code>Queue</code>和<code>Exchange</code>通过某种规则绑定起来，发消息的时候要指定<code>routing-key</code>，还要控制头部信息。消费者在消费消息之前也要进行上面一系列的繁琐过程。</p><h4 id="list结构模拟队列"><a href="#list结构模拟队列" class="headerlink" title="list结构模拟队列"></a>list结构模拟队列</h4><p><code>redis</code>中可以用<code>list</code>(列表）结构来模拟队列和栈，而且非常简单，也常用来作为异步消息队列使用，使用<code>rpush/lpush</code>操作入队列，使用<code>lpop/rpop</code>来出队列。</p><p>客户端是通过队列的<code>pop</code>操作来获取消息，然后进行处理。处理完了再接着获取消息，再进行处理。显然客户端不停的<code>pop</code>操作，当队列空后，客户端就会陷入<code>pop</code>的死循环，此时空轮询不但拉高了客户端的<code>CPU</code>占用率,<code>redis</code>的 <code>QPS</code>也会被拉高，如果这样空轮询的客户端有几十来个，<code>redis</code>的慢查询可能会显著增多。</p><p>上述问题通常可以通过<code>sleep</code>命令来解决这个问题，让线程休眠一下，如<code>sleep (1s)</code>，但是休眠会导致消息的延迟增大。如果只有1个消费者，那么这个延迟就是1s。如果有多个消费者，这个延迟会有所下降，因为每个消费者的休眠时间是岔开来的。</p><p>有没有什么办法能显著降低延迟呢？</p><p>当然可以，借助redis提供了一组<code>blpop/brpop</code>阻塞读命令就可以，阻塞读在队列没有数据的时候，会立即进入休眠状态，一旦数据到来，则立刻醒过来。消息的延迟几乎为零。用<code>blpop/brpop</code>替代前面的<code>lpop/rpop</code>，就完美解决了上面的问题。</p><p>但是在实际使用过程中,<code>blpop/brpop</code> 可能会产生<code>假死</code>现象，就是当没有数据的时候通过<code>blpop/brpop</code>操作进入阻塞休眠状态，当再次有数据进来后，<code>blpop/brpop</code>操作并没有被唤醒继续执行<code>pop</code>, 这是为什么呢？</p><p>什么问题？ —— 空闲连接的问题。</p><p>如果线程一直阻塞在哪里，<code>Redis</code>的客户端连接就成了闲置连接，闲置过久，服务器一般会主动断开连接，减少闲置资源占用。这个时候blpop/brpop会抛出异常来。所以编写客户端消费者的时候要小心，注意捕获异常，还要重试。</p><p><strong>应用场景一 延时队列</strong></p><p>当客户端在处理请求时加锁没加成功怎么办。一般有3种策略来处理加锁失败：</p><ul><li><p>直接抛出异常，通知用户稍后重试；</p><ul><li>这种方式比较适合由用户直接发起的请求，用户看到错误对话框后，会先阅读对话框的内容，再点击重试，这样就可以起到人工延时的效果。如果考虑到用户体验，可以由前端的代码替代用户自己来进行延时重试控制。它本质上是对当前请求的放弃，由用户决定是否重新发起新的请求。</li></ul></li><li><p><code>sleep</code>一会再重试；</p><ul><li><code>sleep</code> 会阻塞当前的消息处理线程，会导致队列的后续消息处理出现延迟。如果碰撞的比较频繁或者队列里消息比较多，</li><li><code>sleep</code> 可能并不合适。如果因为个别死锁的 key 导致加锁不成功，线程会彻底堵死，导致后续消息永远得不到及时处理。</li></ul></li></ul><ul><li><u><strong>将请求转移至延时队列，过一会再试；</strong></u></li></ul><p>这种方式比较适合异步消息处理，将当前冲突的请求扔到另一个队列延后处理以避开冲突。</p><p><code>延时队列</code>可以通过<code>redis</code>的<code>zset(有序列表)</code>来实现。我们将消息序列化成一个字符串作为<code>zset</code>的<code>value</code>，这个消息的到期处理时间作为<code>score</code>，然后用多个线程轮询<code>zset</code>获取到期的任务进行处理，多个线程是为了保障可用性，万一挂了一个线程还有其它线程可以继续处理。因为有多个线程，所以需要考虑并发争抢任务，确保任务不能被多次执行。在处理上可以将<code>zrangebyscore</code>和<code>zrem</code>一同挪到服务器端进行原子化操作;</p><h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><hr><ul><li>阐述了<code>redis</code>利用<code>list</code>结构模拟消息队列的使用原理，场景;</li><li>进一步分析了通过<code>list</code>结构模拟异步消息队列出现队列延迟的问题，引入<code>blpop/brpop</code>阻塞读命令操作；</li><li>进一步在<code>blpop/brpop</code>阻塞读命令休眠过久时无法再次唤醒<code>pop</code>操作，是因为当前连接休眠过久被会<code>redis</code>认为是<code>空闲连接</code>而强行断开连接， 导致后继的<code>blpop/brpop</code>在数据再次到达后无法再次唤醒<code>pop</code>操作， 此情况需要在程序实现时注意捕获<code>blpop/brpop</code>阻塞读异常并进行重试reload操作;</li><li>进一步分析了分布式锁加锁失败后的使用方法， 进而引入分析<code>延时队列</code>策略解决分布式锁加锁失败重试问题；</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;很多业务场景中多会用到消息队列来传递消息数据问题， 常用的消息队列如&lt;code&gt;NSQ&lt;/code&gt;,&lt;code&gt;NAS&lt;/code&gt;, &lt;code&gt;Rabbitmq&lt;/code&gt;和&lt;code&gt;Kafka&lt;/code&gt;等重量级消息队列中间件，功能很强大 使用起来自然也复杂，其实在大部分场景只是需要一个消息队列来传递数据，数据量，数据之间的顺序等也没有特殊的要求， 这样的场景使用&lt;code&gt;redis&lt;/code&gt;非常轻松就可以搞定，而且在使用和维护上相对而言要简单方便些,当然&lt;code&gt;redis&lt;/code&gt;的消息队列不是专业的消息队列，它没有非常多的高级特性，没有&lt;code&gt;ack&lt;/code&gt;保证，如果对消息的可靠性有着极致的追求，那么它就不适合使用；&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="redis专题" scheme="http://researchlab.github.io/categories/redis%E4%B8%93%E9%A2%98/"/>
    
    
      <category term="redis" scheme="http://researchlab.github.io/tags/redis/"/>
    
  </entry>
  
  <entry>
    <title>redis专题02 分布式锁</title>
    <link href="http://researchlab.github.io/2018/01/18/redis-02-distributed-lock/"/>
    <id>http://researchlab.github.io/2018/01/18/redis-02-distributed-lock/</id>
    <published>2018-01-18T10:16:28.000Z</published>
    <updated>2018-10-18T05:08:14.838Z</updated>
    
    <content type="html"><![CDATA[<p>分布式应用进行逻辑处理时经常会遇到并发问题。<br><a id="more"></a></p><p>比如一个操作要修改用户的状态，修改状态需要先读出用户的状态，在内存里进行修改，改完了再存回去。如果这样的操作同时进行了，就会出现并发问题，因为读取和保存状态这两个操作不是原子的。（Wiki解释：所谓原子操作是指不会被线程调度机制打断的操作；这种操作一旦开始，就一直运行到结束，中间不会有任何 context switch 线程切换。）</p><p>这个时候就可以使用分布式锁来限制程序的并发执行。Redis分布式锁使用非常广泛。</p><h4 id="分布式锁"><a href="#分布式锁" class="headerlink" title="分布式锁"></a>分布式锁</h4><p>分布式锁本质上要实现的目标就是在<code>Redis</code>里面占一个”茅坑”，当别的进程也要来占时，发现已经有人蹲在那里了，就只好放弃或者稍后再试。</p><p>占坑一般是使用<code>setnx(set if not exists)</code>指令，只允许被一个客户端占坑。先来先占, 用完后再调用<code>del</code>指令释放茅坑。<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; setnx lock:codehole true</span><br><span class="line">(integer) 1</span><br><span class="line">127.0.0.1:6379&gt; get lock:codehole</span><br><span class="line">"true"</span><br><span class="line">... do something critical ...</span><br><span class="line">127.0.0.1:6379&gt; del lock:codehole</span><br><span class="line">(integer) 1</span><br><span class="line">127.0.0.1:6379&gt;</span><br></pre></td></tr></table></figure></p><p>但是有个问题，如果逻辑执行到中间出现异常了，可能会导致<code>del</code>指令没有被调用，这样就会陷入死锁，锁永远得不到释放。可以在拿到锁之后，再给锁加上一个过期时间，比如<code>5s</code>，这样即使中间出现异常也可以保证<code>5秒</code>之后锁会自动释放。<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; setnx lock:codehole true</span><br><span class="line">(integer) 1</span><br><span class="line">127.0.0.1:6379&gt; expire lock:codehole 5</span><br><span class="line">(integer) 1</span><br><span class="line">127.0.0.1:6379&gt;</span><br></pre></td></tr></table></figure></p><p>但是以上逻辑还有问题。如果在<code>setnx</code>和<code>expire</code>之间服务器进程突然挂掉了，可能是因为机器掉电或者是被人为杀掉的，就会导致<code>expire</code>得不到执行，也会造成死锁。</p><p>这种问题的根源就在于<code>setnx</code>和<code>expire</code>是两条指令而不是原子指令。如果这两条指令可以一起执行就不会出现问题。也许你会想到用<code>Redis</code>事务来解决。但是这里不行，因为<code>expire</code>是依赖于<code>setnx</code>的执行结果的，如果<code>setnx</code>的执行结果的，如果<code>setnx</code>没抢到锁，<code>expire</code>是不应该执行的。<code>redis事务</code>里没有<code>if-else</code>分支逻辑，<u><strong>事务的特点是一口气执行，要么全部执行要么一个都不执行。</strong></u></p><p>为了解决这个疑难，Redis2.8版本中作者加入了<code>set</code>指令的扩展参数，使得<code>setnx</code>和<code>expire</code>组合在一起的原子指令一起执行，它就是redis分布式锁的原理;</p><p><code>set</code>完整命令<br><strong>SET key value [EX seconds] [PX milliseconds] [NX|XX]</strong></p><ul><li><code>EX</code> second ：设置键的过期时间为 second 秒。 SET key value EX second 效果等同于 SETEX key second value 。</li><li><code>PX</code> millisecond ：设置键的过期时间为 millisecond 毫秒。 SET key value PX millisecond 效果等同于 PSETEX key millisecond value 。</li><li><code>NX</code> ：只在键不存在时，才对键进行设置操作。 SET key value NX 效果等同于 SETNX key value 。</li><li><code>XX</code> ：只在键已经存在时，才对键进行设置操作。</li></ul><p>从客户端执行命令： <code>SET resource-name anystring NX EX max-lock-time</code><br>如果服务器返回 OK ，那么这个客户端获得锁。<br>如果服务器返回 NIL ，那么客户端获取锁失败，可以在稍后再重试。<br>设置的过期时间到达之后，锁将自动释放。</p><p>可以通过以下修改，让这个锁实现更健壮：</p><p>不使用固定的字符串作为键的值，而是设置一个不可猜测（non-guessable）的长随机字符串，作为口令串（token）。<br>不使用 DEL 命令来释放锁，而是发送一个 Lua 脚本，这个脚本只在客户端传入的值和键的口令串相匹配时，才对键进行删除。<br>这两个改动可以防止持有过期锁的客户端误删现有锁的情况出现。</p><p>以下是一个简单的解锁脚本示例：<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">if redis.call("get",KEYS[1]) == ARGV[1]</span><br><span class="line">then</span><br><span class="line">    return redis.call("del",KEYS[1])</span><br><span class="line">else</span><br><span class="line">    return 0</span><br><span class="line">end</span><br></pre></td></tr></table></figure></p><blockquote><p>这个脚本可以通过 EVAL …script… 1 resource-name token-value 命令来调用。</p></blockquote><blockquote><p>Redis的分布式锁不能解决超时问题，如果在加锁和释放锁之间的逻辑执行的太长，以至于超出了锁的超时限制，就会出现问题。因为这时候第一个线程持有的锁过期了，临界区的逻辑还没有执行完，这个时候第二个线程就提前重新持有了这把锁，导致临界区代码不能得到严格的串行执行。为了避免这个问题，Redis 分布式锁不要用于较长时间的任务。如果真的偶尔出现了，数据出现的小波错乱可能需要人工介入解决。</p></blockquote><p>上述通过<code>set</code>配合<code>lua</code>脚本实现的redis分布式锁，在集群情况下会存在如下问题，<br>比如在<code>Sentinel</code>集群中，主节点挂掉时，从节点会取而代之，客户端上却并没有明显感知。原先第一个客户端在主节点中申请成功了一把锁，但是这把锁还没有来得及同步到从节点，主节点突然挂掉了。然后从节点变成了主节点，这个新的节点内部没有这个锁，所以当另一个客户端过来请求加锁时，立即就批准了。这样就会导致系统中同样一把锁被两个客户端同时持有，不安全性由此产生。不过这种不安全也仅仅是在主从发生 failover 的情况下才会产生，而且持续时间极短，业务系统多数情况下可以容忍。</p><p>为了处理在集群模式下<code>redis</code>分布式锁存在的上述问题，可以考虑引入<code>redlock</code>分布式锁机制，当然为了使用<code>Redlock</code>，需要提供多个<code>Redis</code>实例，这些实例之前相互独立没有主从关系。同很多分布式算法一样，<code>redlock</code>也使用<code>「大多数机制」</code>。加锁时，它会向过半节点发送<code>set(key, value, nx=True, ex=xxx)</code>指令，只要过半节点 <code>set</code>成功，那就认为加锁成功。释放锁时，需要向所有节点发送<code>del</code>指令。不过<code>Redlock</code>算法还需要考虑出错重试、时钟漂移等很多细节问题，同时因为<code>Redlock</code>需要向多个节点进行读写，意味着相比单实例<code>Redis</code>性能会下降一些。</p><p>如果很在乎高可用性，希望挂了一台<code>redis</code>完全不受影响，那就应该考虑<code>redlock</code>, 不过代价也是有的，需要更多的 redis 实例，性能也会有折扣等；</p><h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><hr><ul><li>阐述了<code>redis分布式锁</code>的实现原理;</li><li>进一步分析简单<code>redis分布式锁</code>可能存的超时操作，误删除操作等无法合理处理的问题，建议引入<code>lua</code>脚本配合执行，<code>lua</code>脚本作为<code>redis</code>的内置脚本可以优雅的协助处理很多<code>redis事务</code>无法处理的场景， 同时建议<code>redis分布式锁</code>不要用于较长时间的任务;</li><li>分析了在集群模式下<code>set</code>命令配合<code>lua</code>实现的<code>redis分布式锁</code>会引发数据不一致性问题，进一步引入分析了<code>redlock</code>锁机制，对其实现原理及可能带来的影响进行了简单分析总结;</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;分布式应用进行逻辑处理时经常会遇到并发问题。&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="redis专题" scheme="http://researchlab.github.io/categories/redis%E4%B8%93%E9%A2%98/"/>
    
    
      <category term="redis" scheme="http://researchlab.github.io/tags/redis/"/>
    
  </entry>
  
  <entry>
    <title>redis专题01 数据结构之string/list/hash/set/zset</title>
    <link href="http://researchlab.github.io/2018/01/16/redis-01-basic-structure/"/>
    <id>http://researchlab.github.io/2018/01/16/redis-01-basic-structure/</id>
    <published>2018-01-16T11:31:18.000Z</published>
    <updated>2018-10-18T05:08:14.838Z</updated>
    
    <content type="html"><![CDATA[<p>在日常应用开发中，redis常应用于热点内容缓存，分布式锁，权限认证等场景中，此redis专题试图对redis技术在内容缓存,分布式及redis集群场景中的应用，使用特性，原理及源码进行分析总结，内容来源于个人工作经验实践及网络学习资源的融合归纳总结;<br><a id="more"></a></p><h4 id="1-redis-环境搭建"><a href="#1-redis-环境搭建" class="headerlink" title="1 redis 环境搭建"></a>1 redis 环境搭建</h4><p>通过docker方式搭建一个redis 环境<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 拉取 redis 镜像</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> docker pull redis</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 运行 redis 容器</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> docker run --name myredis -d -p6379:6379 redis</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 执行容器中的 redis-cli，可以直接使用命令行操作 redis</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> docker <span class="built_in">exec</span> -it myredis redis-cli</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> redis 默认有从0到15共计16个数据库，默认为0号数据库</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> flushall 清空redis所有数据库数据(从0到15号数据库)</span></span><br><span class="line">127.0.0.1:6379&gt; flushall</span><br><span class="line">OK</span><br><span class="line"><span class="meta">#</span><span class="bash"> 选择0号数据库</span></span><br><span class="line">127.0.0.1:6379&gt; select 0</span><br><span class="line">OK</span><br><span class="line"><span class="meta">#</span><span class="bash"> 查询当前数据库已存数据的大小</span></span><br><span class="line">127.0.0.1:6379&gt; dbsize</span><br><span class="line">(integer) 0</span><br><span class="line"><span class="meta">#</span><span class="bash"> flushdb 清除单个数据库的数据， 如现在清空的是0号数据库的所有数据</span></span><br><span class="line">127.0.0.1:6379&gt; flushdb</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt;</span><br></pre></td></tr></table></figure></p><h4 id="2-redis基础结构"><a href="#2-redis基础结构" class="headerlink" title="2 redis基础结构"></a>2 redis基础结构</h4><p>redis有5个基础数据结构</p><ul><li><code>string</code> 字符串</li><li><code>list</code> 列表</li><li><code>set</code> 集合</li><li><code>hash</code> 哈希</li><li><code>zset</code> 有序集合</li></ul><blockquote><p><a href="http://doc.redisfans.com/" target="_blank" rel="noopener">redis命令参考链接</a></p></blockquote><h5 id="2-1-string-字符串"><a href="#2-1-string-字符串" class="headerlink" title="2.1 string(字符串)"></a>2.1 string(字符串)</h5><p>Redis中string是动态字符串，采用预分配冗余空间的方式来减少内存的频繁分配，即一个字符串的地址大小实际有两个长度表示，一个是字符串的实际长度len, 另一个是初始化时系统预分配的空间大小capacity, (capacity &gt;= len), 当字符串长度小于1M时，扩容都是加倍现有的空间，如果超过1M，扩容时一次只会多扩1M的空间。</p><blockquote><p>redis字符串最大长度为512M;</p></blockquote><p>基础操作<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; set target learning.redis</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; get target</span><br><span class="line">"learning.redis"</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 计算字符串长度</span></span><br><span class="line">127.0.0.1:6379&gt; strlen target</span><br><span class="line">(integer) 14</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 在字符串尾部追加，返回最终长度</span></span><br><span class="line">127.0.0.1:6379&gt; append target .more</span><br><span class="line">(integer) 19</span><br><span class="line">127.0.0.1:6379&gt; get target</span><br><span class="line">"learning.redis.more"</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 根据变量名，及子串的开始及结束位置 获取子串</span></span><br><span class="line">127.0.0.1:6379&gt; getrange target 15 18</span><br><span class="line">"more"</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 根据变量名， 及待覆盖子串的开始位置，从开始位置覆盖变量值</span></span><br><span class="line">127.0.0.1:6379&gt; setrange target 15 advanced</span><br><span class="line">(integer) 23</span><br><span class="line">127.0.0.1:6379&gt; get target</span><br><span class="line">"learning.redis.advanced"</span><br><span class="line">127.0.0.1:6379&gt;</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 删除字符串可用del指令进行主动删除，也可用expire指令设置过期时间，到点会自动删除;</span></span><br><span class="line">127.0.0.1:6379&gt; set timeout deleteby.itself.after.10.seconds ex 10</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; get timeout</span><br><span class="line">"deleteby.itself.after.10.seconds"</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash">after 10 seconds</span></span><br><span class="line">127.0.0.1:6379&gt; get timeout</span><br><span class="line">(nil)</span><br><span class="line">127.0.0.1:6379&gt; set tmp no.timeout</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; get tmp</span><br><span class="line">"no.timeout"</span><br><span class="line">127.0.0.1:6379&gt; del tmp</span><br><span class="line">(integer) 1</span><br><span class="line">127.0.0.1:6379&gt; get tmp</span><br><span class="line">(nil)</span><br><span class="line">127.0.0.1:6379&gt;</span><br></pre></td></tr></table></figure></p><ul><li>使用场景一 计数器<br>如果字符串为整数时，可以将字符串当成计数器来使用<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; set nums 10</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; get nums</span><br><span class="line">"10"</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 在原变量nums值上增加(incrby)或减少（decry)步长10, 返回最终的计算值</span></span><br><span class="line">127.0.0.1:6379&gt; incrby nums 10</span><br><span class="line">(integer) 20</span><br><span class="line">127.0.0.1:6379&gt; decrby nums 10</span><br><span class="line">(integer) 10</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 在原变量nums值上增加(incr)或减少(decr)步长1， 返回最终的计算值</span></span><br><span class="line">127.0.0.1:6379&gt; incr nums</span><br><span class="line">(integer) 11</span><br><span class="line">127.0.0.1:6379&gt; decr nums</span><br><span class="line">(integer) 10</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 若变量不存在，则incr/decr会创建变量名并在零值基础上进行加(incr)或减(decr)1操作;</span></span><br><span class="line">127.0.0.1:6379&gt; incr id</span><br><span class="line">(integer) 1</span><br><span class="line">127.0.0.1:6379&gt; decr std</span><br><span class="line">(integer) -1</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 注意redis中整数值的有效范围区间，超过溢出报错</span></span><br><span class="line">127.0.0.1:6379&gt; set nums 9223372036854775807</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; incr nums</span><br><span class="line">(error) ERR increment or decrement would overflow</span><br><span class="line">127.0.0.1:6379&gt; set nums -9223372036854775808</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; decr nums</span><br><span class="line">(error) ERR increment or decrement would overflow</span><br><span class="line">127.0.0.1:6379&gt;</span><br></pre></td></tr></table></figure></li></ul><h5 id="2-2-list-列表"><a href="#2-2-list-列表" class="headerlink" title="2.2 list(列表)"></a>2.2 list(列表)</h5><p>Redis将列表数据结构命名为list而不是array，是因为列表的存储结构用的是链表而不是数组，而且链表还是双向链表。因为它是链表，所以随机定位性能较弱，首尾插入删除性能较优。如果list的列表长度很长，使用时我们一定要关注链表相关操作的时间复杂度。</p><p><code>负下标</code> 链表元素的位置使用自然数<code>0,1,2,....n-1</code>表示，还可以使用负数<code>-1,-2,...-n</code>来表示，<code>-1</code>表示<code>「倒数第一」</code>，<code>-2</code>表示<code>「倒数第二」</code>，那么<code>-n</code>就表示<code>第一个元素，对应的下标为0</code>；</p><p><code>队列／栈</code> 链表提供了可以从左边或右边分别对表头表尾进行删除和插入操作的rpush/rpop/lpush/lpop四条命令，使得在需要用到队列或栈操作中使用list列表结构非常方便；</p><p><code>模拟队列</code> 先进先出操作</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 右进左出</span></span><br><span class="line">127.0.0.1:6379&gt; rpush skills go</span><br><span class="line">(integer) 1</span><br><span class="line">127.0.0.1:6379&gt; rpush skills java python</span><br><span class="line">(integer) 3</span><br><span class="line">127.0.0.1:6379&gt; lpop skills</span><br><span class="line">"go"</span><br><span class="line">127.0.0.1:6379&gt; lpop skills</span><br><span class="line">"java"</span><br><span class="line">127.0.0.1:6379&gt; lpop skills</span><br><span class="line">"python"</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 左进右出</span></span><br><span class="line">127.0.0.1:6379&gt; lpush skills go java python</span><br><span class="line">(integer) 3</span><br><span class="line">127.0.0.1:6379&gt; rpop skills</span><br><span class="line">"go"</span><br></pre></td></tr></table></figure><blockquote><p>在日常应用中，列表常用来作为异步队列来使用。</p></blockquote><p><code>模拟栈</code>  后进先出操作</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 右进右出</span></span><br><span class="line">127.0.0.1:6379&gt; rpush skills go java python</span><br><span class="line">(integer) 3</span><br><span class="line">127.0.0.1:6379&gt; rpop skills</span><br><span class="line">"python"</span><br><span class="line">...</span><br><span class="line"><span class="meta">#</span><span class="bash"> 左进左出</span></span><br><span class="line">127.0.0.1:6379&gt; lpush skills go java python</span><br><span class="line">(integer) 3</span><br><span class="line">127.0.0.1:6379&gt; lpop skills</span><br><span class="line">"python"</span><br></pre></td></tr></table></figure><p><code>随机读</code> 可以使用<code>lindex</code>指令访问指定位置的元素，使用<code>lrange</code>指令来获取链表子元素列表，提供<code>start</code>和<code>end</code>下标参数</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; rpush skills go java python</span><br><span class="line">(integer) 3</span><br><span class="line">127.0.0.1:6379&gt; lindex skills 1</span><br><span class="line">"java"</span><br><span class="line">127.0.0.1:6379&gt; lrange skills 0 2</span><br><span class="line">1) "go"</span><br><span class="line">2) "java"</span><br><span class="line">3) "python"</span><br><span class="line">127.0.0.1:6379&gt; lrange skills 0 -1  # -1表示倒数第一</span><br><span class="line">1) "go"</span><br><span class="line">2) "java"</span><br><span class="line">3) "python"</span><br></pre></td></tr></table></figure><blockquote><p>使用<code>lrange</code>获取全部元素时，需要提供<code>end_index</code>，如果没有负下标，就需要首先通过<code>llen</code>指令获取长度，才可以得出<code>end_index</code>的值，有了负下标，使用<code>-1</code>代替<code>end_index</code>就可以达到相同的效果。</p></blockquote><p><code>修改元素</code> 使用<code>lset</code>指令在指定位置修改元素。<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; rpush skills go java python</span><br><span class="line">(integer) 3</span><br><span class="line">127.0.0.1:6379&gt; lset skills 1 javascript</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; lrange skills 0 -1</span><br><span class="line">1) "go"</span><br><span class="line">2) "javascript"</span><br><span class="line">3) "python"</span><br></pre></td></tr></table></figure></p><p><code>插入元素</code> 使用<code>linsert</code>指令在列表的中插入新增元素，插入新元素时需要在<code>linsert</code>指令里指明方向参数<code>before</code>/<code>after</code>来显示指示前置和后置插入； 其次，<code>linsert</code>指令并不是通过指定位置来插入，而是通过指定具体的值。这是因为在分布式环境下，列表的元素总是频繁变动的，意味着上一时刻计算的元素下标在下一时刻可能就不是你所期望的下标了。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; rpush skills go python java</span><br><span class="line">(integer) 3</span><br><span class="line">127.0.0.1:6379&gt; linsert skills before python javascript</span><br><span class="line">(integer) 4</span><br><span class="line">127.0.0.1:6379&gt; lrange skills 0 -1</span><br><span class="line">1) "go"</span><br><span class="line">2) "javascript"</span><br><span class="line">3) "python"</span><br><span class="line">4) "java"</span><br><span class="line">127.0.0.1:6379&gt;</span><br></pre></td></tr></table></figure><p><code>删除元素</code> 列表的删除操作也不是通过指定下标来确定元素的，你需要指定删除的最大个数以及元素的值<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; rpush skills go python go java javascript</span><br><span class="line">(integer) 5</span><br><span class="line">127.0.0.1:6379&gt; lrange skills 0 -1</span><br><span class="line">1) "go"</span><br><span class="line">2) "python"</span><br><span class="line">3) "go"</span><br><span class="line">4) "java"</span><br><span class="line">5) "javascript"</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 指定删除的最大个数及待删除的值，返回删除后的个数值</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 如果待删除的值不存在， 返回0</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 如果待删除的值的个数少于指定的最大个数值， 则返回实际删除的个数值</span></span><br><span class="line">127.0.0.1:6379&gt; lrem skills 1 go</span><br><span class="line">(integer) 1</span><br><span class="line">127.0.0.1:6379&gt; lrange skills 0 -1</span><br><span class="line">1) "python"</span><br><span class="line">2) "go"</span><br><span class="line">3) "java"</span><br><span class="line">4) "javascript"</span><br><span class="line">127.0.0.1:6379&gt; lrem skills 2 java</span><br><span class="line">(integer) 1</span><br><span class="line">127.0.0.1:6379&gt; lrange skills 0 -1</span><br><span class="line">1) "python"</span><br><span class="line">2) "go"</span><br><span class="line">3) "javascript"</span><br><span class="line">127.0.0.1:6379&gt; lrem skills 2 ruby</span><br><span class="line">(integer) 0</span><br><span class="line">127.0.0.1:6379&gt; lrange skills 0 -1</span><br><span class="line">1) "python"</span><br><span class="line">2) "go"</span><br><span class="line">3) "javascript"</span><br><span class="line">127.0.0.1:6379&gt;</span><br></pre></td></tr></table></figure></p><p><code>定长列表</code> 在实际应用场景中，有时会遇到<code>「定长列表」</code> 的需求。比如要以走马灯的形式实时显示中奖用户名列表，因为中奖用户实在太多，能显示的数量一般不超过100条，那么这里就会使用到定长列表。维持定长列表的指令是<code>ltrim</code> ，需要提供两个参数start和end，表示需要保留列表的下标范围，范围之外的所有元素都将被移除。<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; rpush skills go java python javascript ruby erlang rust app php</span><br><span class="line">(integer) 9</span><br><span class="line">127.0.0.1:6379&gt; ltrim skills -3 -1</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; lrange skills 0 -1</span><br><span class="line">1) "rust"</span><br><span class="line">2) "app"</span><br><span class="line">3) "php"</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 当指定参数的end对应的真实下标小于start，其效果等价于del指令，因为这样的参数表示需要需要保留列表元素的下标范围为空。</span></span><br><span class="line">127.0.0.1:6379&gt; ltrim skills -3 -5</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; lrange skills 0 -1</span><br><span class="line">(empty list or set)</span><br><span class="line">127.0.0.1:6379&gt;</span><br></pre></td></tr></table></figure></p><p><code>快速列表 quicklist</code><br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 快速列表结构</span></span><br><span class="line">ziplist &lt;---&gt; ziplist &lt;---&gt; ziplist</span><br></pre></td></tr></table></figure></p><blockquote><p><strong>再深入一点，会发现Redis底层存储的还不是一个简单的<code>linkedlist</code>，而是称之为<code>快速链表quicklist</code>的一个结构。首先在列表元素较少的情况下会使用一块连续的内存存储，这个结构是<code>ziplist</code>，也即是<code>压缩列表</code>。它将所有的元素紧挨着一起存储，分配的是一块连续的内存。当数据量比较多的时候才会改成<code>quicklist</code>。因为普通的链表需要的附加指针空间太大，会比较浪费空间。比如这个列表里存的只是<code>int</code>类型的数据，结构上还需要两个额外的指针<code>prev</code>和<code>next</code>。所以Redis将<code>链表</code>和<code>ziplist</code>结合起来组成了<code>quicklist</code>。也就是将<u>多个<code>ziplist</code>使用<font color="red">双向指针</font>串起来(组成<code>quicklist</code>）</u>使用。这样既满足了快速的插入删除性能，又不会出现太大的空间冗余。</strong></p></blockquote><h5 id="2-3-hash-哈希"><a href="#2-3-hash-哈希" class="headerlink" title="2.3 hash(哈希)"></a>2.3 hash(哈希)</h5><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">哈希结构</span></span><br><span class="line">    /key ---&gt; value</span><br><span class="line">hash-key ---&gt; value</span><br><span class="line">   \\key ---&gt; value</span><br><span class="line">    \...</span><br><span class="line"></span><br><span class="line">                   val2    val2    val2       val2</span><br><span class="line">                   val1    val1    val1       val1</span><br><span class="line">                    ^       ^      ^          ^</span><br><span class="line">                    |       |      |          |</span><br><span class="line">    hash --- array&#123;[key0], [key1], [key2], ... [key2^n]&#125;</span><br></pre></td></tr></table></figure><p>哈希结构等价于Java中的<code>HashMap</code>或者是Python中的字典<code>dict</code>结构，但Redis的字典的值只能是字符串, 在<u>实现结构上它使用<code>二维结构</code>，第一维是数组，第二维是链表，<code>hash</code>的内容<code>key</code>和<code>value</code>存放在链表中，数组里存放的是链表的头指针</u>。通过key查找元素时，先计算<code>key</code>的<code>hashcode</code>，然后用<code>hashcode</code>对数组的长度进行取模定位到链表的表头，再对链表进行遍历获取到相应的<code>value</code>值，链表的作用就是用来将产生了<code>「hash碰撞」</code>的元素串起来。Java语言开发者会感到非常熟悉，因为这样的结构和HashMap是没有区别的。哈希的第一维数组的长度也是2^n。</p><p><code>基础操作</code><br><strong>增</strong></p><ul><li><code>hset</code>  一次增加一个键值对;</li><li><code>hmset</code> 一次增加多个键值对;</li></ul><p><strong>删</strong></p><ul><li><code>hdel</code>  删除指定key，hdel支持同时删除多个key;</li></ul><p><del><strong>改</strong></del></p><p><strong>查</strong></p><ul><li><code>hget</code>          获取具体key对应的value;</li><li><code>hmget</code>         获取多个key对应的value;</li><li><code>hgetall</code>       获取所有的键值对;</li><li><code>hkeys</code>和<code>hvals</code> 可分别获取所有的key列表和value列表;</li><li><code>hexists</code>       判断某个值是否存在于指定key中;</li></ul><blockquote><p>判断元素是否存在 可以使用<code>hget</code>获得<code>key</code>对应的<code>value</code>是否为空来判断，若value的字符串长度特别大，通过这种方式来判断元素存在与否就略显浪费，此时建议使用hexists指令;</p></blockquote><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">hset 设置单个field-value值对并返回设置成功的值对个数，但在下列实践中hset 好像也支持设置多个值队并返回了大于2的值对个数，但是不建议使用hset设置多个值对操作；</span></span><br><span class="line">127.0.0.1:6379&gt; hset auth mike true david true</span><br><span class="line">(integer) 2</span><br><span class="line">127.0.0.1:6379&gt; hget auth mike</span><br><span class="line">"true"</span><br><span class="line">127.0.0.1:6379&gt; hmset auth jack false jett true</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; hget auth jett</span><br><span class="line">"true"</span><br><span class="line"><span class="meta">#</span><span class="bash"> 当hmget 获取不存在key的field对应的value时返回nil</span></span><br><span class="line">127.0.0.1:6379&gt; hmget jack mike jett</span><br><span class="line">1) (nil)</span><br><span class="line">2) (nil)</span><br><span class="line">127.0.0.1:6379&gt; hmget auth jack mike jett</span><br><span class="line">1) "false"</span><br><span class="line">2) "true"</span><br><span class="line">3) "true"</span><br><span class="line">127.0.0.1:6379&gt; hgetall auth</span><br><span class="line">1) "mike"</span><br><span class="line">2) "true"</span><br><span class="line">3) "david"</span><br><span class="line">4) "true"</span><br><span class="line">5) "jack"</span><br><span class="line">6) "false"</span><br><span class="line">7) "jett"</span><br><span class="line">8) "true"</span><br><span class="line">127.0.0.1:6379&gt; hkeys auth</span><br><span class="line">1) "mike"</span><br><span class="line">2) "david"</span><br><span class="line">3) "jack"</span><br><span class="line">4) "jett"</span><br><span class="line">127.0.0.1:6379&gt; hvals auth</span><br><span class="line">1) "true"</span><br><span class="line">2) "true"</span><br><span class="line">3) "false"</span><br><span class="line">4) "true"</span><br><span class="line"><span class="meta">#</span><span class="bash"> hdel 可以支持删除多个field,当field不存在则忽略，最终返回删除成功的个数</span></span><br><span class="line">127.0.0.1:6379&gt; hdel auth jack jett ruby</span><br><span class="line">(integer) 2</span><br><span class="line"><span class="meta">#</span><span class="bash"> hexists 判断指定key中指定field的value值是否存在</span></span><br><span class="line">127.0.0.1:6379&gt; hexists auth jack</span><br><span class="line">(integer) 0</span><br><span class="line">127.0.0.1:6379&gt; hgetall auth</span><br><span class="line">1) "mike"</span><br><span class="line">2) "true"</span><br><span class="line">3) "david"</span><br><span class="line">4) "true"</span><br><span class="line">127.0.0.1:6379&gt;</span><br></pre></td></tr></table></figure><p><code>计数器</code> 如果value为整数，那也可用<code>hash结构</code>来计数，对于内部的每一个key都可以作为独立的计数器。如果value值不是整数，调用hincrby指令会出错。<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; hset nums fish 1</span><br><span class="line">(integer) 1</span><br><span class="line">127.0.0.1:6379&gt; hincrby nums fish 5</span><br><span class="line">(integer) 6</span><br><span class="line">127.0.0.1:6379&gt; hgetall nums</span><br><span class="line">1) "fish"</span><br><span class="line">2) "6"</span><br><span class="line">127.0.0.1:6379&gt;</span><br></pre></td></tr></table></figure></p><p><code>扩容</code> 当<code>hash</code>内部的元素比较拥挤时(hash碰撞比较频繁)，就需要进行扩容。扩容需要申请新的两倍大小的数组，然后将所有的键值对重新分配到新的数组下标对应的链表中(<code>rehash</code>)。如果hash结构很大，比如有上百万个键值对，那么一次完整rehash的过程就会耗时很长, 这对于单线程的Redis里来说有点压力山大。所以<u><strong>Redis采用了渐进式rehash的方案。它会同时保留两个新旧hash结构，在后续的定时任务以及hash结构的读写指令中将旧结构的元素逐渐迁移到新的结构中。这样就可以避免因扩容导致的线程卡顿现象。</strong></u></p><p>hash 结构也可以用来存储用户信息，不同于字符串一次性需要全部序列化整个对象，hash 可以对用户结构中的每个字段单独存储。这样当我们需要获取用户信息时可以进行部分获取。而以整个字符串的形式去保存用户信息的话就只能一次性全部读取，这样就会比较浪费网络流量。</p><p>hash 也有缺点，hash 结构的存储消耗要高于单个字符串，到底该使用 hash 还是字符串，需要根据实际情况再三权衡。</p><p><code>缩容</code> hash结构缩容的原理和扩容是一致的，只不过新的数组大小要比旧数组小一倍。</p><h5 id="2-4-set-集合"><a href="#2-4-set-集合" class="headerlink" title="2.4 set(集合)"></a>2.4 set(集合)</h5><p>Redis的<code>set</code>的内部结构就是<code>hash结构</code>，所有的value都指向同一个内部值。<br><strong>增</strong></p><ul><li><code>sadd</code> 可以一次增加多个元素;</li></ul><p><strong>删</strong></p><ul><li><code>srem</code> 删除一到多个元素;</li><li><code>spop</code> 删除随机一个元素;</li></ul><p><del><strong>改</strong></del></p><p><strong>查</strong></p><ul><li><code>smembers</code>  列出所有元素，</li><li><code>scard</code>  获取集合长度，</li><li><code>srandmember</code> 获取随机count个元素，如果不提供count参数，默认为1</li><li><code>sismember</code>  判断元素是否存在(只能接收单个元素) 使用场景之一是判断是否有某种权限</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> sadd 添加集合元素， 返回成功添加元素个数</span></span><br><span class="line">127.0.0.1:6379&gt; sadd skills go python java</span><br><span class="line">(integer) 3</span><br><span class="line">127.0.0.1:6379&gt; smembers skills</span><br><span class="line">1) "java"</span><br><span class="line">2) "python"</span><br><span class="line">3) "go"</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> scard 获取集合长度</span></span><br><span class="line">127.0.0.1:6379&gt; scard skills</span><br><span class="line">(integer) 3</span><br><span class="line">127.0.0.1:6379&gt; srandmember skills 2</span><br><span class="line">1) "python"</span><br><span class="line">2) "java"</span><br><span class="line">127.0.0.1:6379&gt; srandmember skills 2</span><br><span class="line">1) "java"</span><br><span class="line">2) "go"</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> srem 删除集合某个元素， 返回成功删除个数</span></span><br><span class="line">127.0.0.1:6379&gt; srem skills python java</span><br><span class="line">(integer) 2</span><br><span class="line">127.0.0.1:6379&gt; smembers skills</span><br><span class="line">1) "go"</span><br><span class="line">127.0.0.1:6379&gt; spop skills</span><br><span class="line">"go"</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> sismember 判断给定元素是否存在某个集合中</span></span><br><span class="line">127.0.0.1:6379&gt; sismember skills go</span><br><span class="line">(integer) 0</span><br><span class="line">127.0.0.1:6379&gt;</span><br></pre></td></tr></table></figure><h5 id="2-5-sortedset-有序集合"><a href="#2-5-sortedset-有序集合" class="headerlink" title="2.5 sortedset(有序集合)"></a>2.5 sortedset(有序集合)</h5><p><code>SortedSet</code>(<code>zset</code>)是Redis提供的一个非常特别的数据结构，一方面它等价于<code>Java</code>的数据结构<code>Map&lt;String, Double&gt;</code>，可以给每一个元素<code>value</code>赋予一个权重<code>score</code>，另一方面它又类似于<code>TreeSet</code>，内部的元素会按照权重<code>score</code>进行排序，可以得到每个元素的名次，还可以通过<code>score</code>的范围来获取元素的列表。<br><u><strong><code>zset</code>底层实现使用了两个数据结构，第一个是<code>hash</code>，第二个是<code>跳跃列表</code>，<code>hash</code>的作用就是关联元素<code>value</code>和权重<code>score</code>，保障元素<code>value</code>的唯一性，可以通过元素<code>value</code>找到相应的<code>score</code>值。跳跃列表的目的在于给元素<code>value</code>排序，根据<code>score</code>的范围获取元素列表。</strong></u></p><p><strong>增</strong></p><ul><li><code>zadd</code>   增加一到多个<code>value/score</code>对，<code>score</code>放在前面</li></ul><p><strong>删</strong></p><ul><li><code>zrem</code>   可以删除<code>zset</code>中的元素，可以一次删除多个</li><li><code>zremrangebyrank</code> 可以根据排名范围来删除一个或多个值</li><li><code>zremrangebyscore</code> 可以根据分值返回来删除一个或多个值</li></ul><p><strong>改</strong></p><ul><li><code>zincrby</code> 以指定步长修改指定元素的value值，若value不是整数则会报错</li></ul><p><strong>查</strong></p><ul><li><code>zcard</code>可以得到<code>zset</code>的元素个数</li><li><code>zscore</code> 获取指定元素的权重</li><li><code>zrank</code> 获取指定元素的正向排名</li><li><p><code>zrevrank</code> 获取指定元素的反向排名[倒数第一名]。</p><blockquote><p>正向是由小到大，负向是由大到小。</p></blockquote></li><li><p><code>zrange</code>    指令指定排名范围参数获取对应的元素列表，携带withscores参数可以一并获取元素的权重。</p></li><li><code>zrevrange</code> 指令按负向排名获取元素列表[倒数]。正向是由小到大，负向是由大到小。</li><li><code>zrangebyscore</code> 指定score范围获取对应的元素列表。</li><li><code>zrevrangebyscore</code> 指令获取倒排元素列表。<blockquote><p>正向是由小到大，负向是由大到小。参数-inf表示负无穷，+inf表示正无穷。</p></blockquote></li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; zadd skills 10 go</span><br><span class="line">(integer) 1</span><br><span class="line">127.0.0.1:6379&gt; zadd skills 9 python 8 java 7 js</span><br><span class="line">(integer) 3</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash">zcard 获取有序集合长度</span></span><br><span class="line">127.0.0.1:6379&gt; zcard skills</span><br><span class="line">(integer) 4</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> zincrby 为指定元素value增加给定步长值, 可以用作计数器</span></span><br><span class="line">127.0.0.1:6379&gt; zincrby skills 10 go</span><br><span class="line">"20"</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> zscore 查询具体元素的score值</span></span><br><span class="line">127.0.0.1:6379&gt; zscore skills go</span><br><span class="line">"20"</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> zrank 查询给定元素的排名(从小到大)， zrevrank 反向查询给定元素的排名(从大到小)</span></span><br><span class="line">127.0.0.1:6379&gt; zrank skills go</span><br><span class="line">(integer) 1</span><br><span class="line">127.0.0.1:6379&gt; zrank skills python</span><br><span class="line">(integer) 0</span><br><span class="line">127.0.0.1:6379&gt; zrevrank skills go</span><br><span class="line">(integer) 0</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 获取有序集合的所有元素 zrange是按照正向(score值从小到大)排序返回的值列表</span></span><br><span class="line">127.0.0.1:6379&gt; zrange skills 0 -1</span><br><span class="line">1) "python"</span><br><span class="line">2) "go"</span><br><span class="line">127.0.0.1:6379&gt; zrange skills 0 -1 withscores</span><br><span class="line">1) "python"</span><br><span class="line">2) "9"</span><br><span class="line">3) "go"</span><br><span class="line">4) "20"</span><br><span class="line">127.0.0.1:6379&gt; zrevrange skills 0 -1 withscores</span><br><span class="line">1) "go"</span><br><span class="line">2) "20"</span><br><span class="line">3) "python"</span><br><span class="line">4) "9"</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 获取指定score返回的有序集合值</span></span><br><span class="line">127.0.0.1:6379&gt; zrangebyscore skills 0 20</span><br><span class="line">1) "python"</span><br><span class="line">2) "go"</span><br><span class="line">127.0.0.1:6379&gt; zrangebyscore skills -inf +inf withscores</span><br><span class="line">1) "python"</span><br><span class="line">2) "9"</span><br><span class="line">3) "go"</span><br><span class="line">4) "20"</span><br><span class="line">127.0.0.1:6379&gt; zrevrangebyscore skills +inf -inf withscores</span><br><span class="line">1) "go"</span><br><span class="line">2) "20"</span><br><span class="line">3) "python"</span><br><span class="line">4) "9"</span><br><span class="line">127.0.0.1:6379&gt; zrevrangebyscore skills +inf +inf withscores</span><br><span class="line">(empty list or set)</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> zrem 删除指定key的指定field组</span></span><br><span class="line">127.0.0.1:6379&gt; zrem skills java js</span><br><span class="line">(integer) 2</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> zremrangebyrank 删除指定排名返回内的值组</span></span><br><span class="line">127.0.0.1:6379&gt; zremrangebyrank skills 0 0</span><br><span class="line">(integer) 1</span><br><span class="line">127.0.0.1:6379&gt; zrange skills 0 1</span><br><span class="line">1) "go"</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash">zremrangebyscore 删除给定score返回的值组</span></span><br><span class="line">127.0.0.1:6379&gt; zremrangebyscore skills -inf 10</span><br><span class="line">(integer) 0</span><br><span class="line">127.0.0.1:6379&gt; zrange skills 0 1</span><br><span class="line">1) "go"</span><br><span class="line">127.0.0.1:6379&gt;</span><br></pre></td></tr></table></figure><p><code>跳跃列表</code> <code>zset</code>内部的排序功能是通过<code>「跳跃列表」</code>数据结构来实现的，它的结构非常特殊，也比较复杂。<br>因为zset要支持随机的插入和删除，所以它不好使用数组来表示。先看一个普通的链表结构,<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(value,score)--&gt;(value,score)--&gt;(value,score)--&gt;(value,score)--&gt;(value,score)</span><br></pre></td></tr></table></figure></p><p>需要这个链表按照score值进行排序。这意味着当有新元素需要插入时，需要定位到特定位置的插入点，这样才可以继续保证链表是有序的。通常我们会通过二分查找来找到插入点，但是二分查找的对象必须是数组，只有数组才可以支持快速位置定位，链表做不到，那该怎么办？ 引入跳跃列表<br>跳跃列表（也称跳表）是一种随机化数据结构，基于并联的链表，其效率可比拟于二叉查找树（对于大多数操作需要O(logn)平均时间）。</p><p>基本上，跳跃列表是对有序的链表增加上附加的前进链接，增加是以随机化的方式进行的，所以在列表中的查找可以快速的跳过部分列表元素，因此得名。所有操作都以对数随机化的时间进行。</p><p>跳跃表描述:</p><ul><li>一个跳跃列表由几层组成</li><li>底层包含所有元素</li><li>每一层都是一个有序链表</li><li>在层 <code>i</code> 中的元素按某个固定的概率<code>p(通常为0.5或0.25)</code>出现在层 <code>i+1</code> 中(也就是说高层中的元素必然在低层)</li><li>第<code>i</code>层的某个元素可以向下访问与它有相同值的下层节点</li></ul><p>如下图所示，是一个即为简单的跳跃表。传统意义的单链表是一个线性结构，向有序的链表中插入一个节点需要O(n)的时间，查找操作需要O(n)的时间。如果我们使用图中所示的跳跃表，就可以大大减少减少查找所需时间。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">L2：1-----4---6</span><br><span class="line">L1：1---3-4---6-----9</span><br><span class="line">L0：1-2-3-4-5-6-7-8-9-10</span><br></pre></td></tr></table></figure><p>定位插入点时，先在顶层进行定位，然后下潜到下一级定位，一直下潜到最底层找到合适的位置，将新元素插进去。你也许会问那新插入的元素如何才有机会「身兼数职」呢？<br>跳跃列表采取一个随机策略来决定新元素可以兼职到第几层，首先<code>L0</code>层肯定是<code>100%</code>了，<code>L1</code>层只有<code>50%</code>的概率，<code>L2</code>层只有<code>25%</code>的概率，<code>L3</code>层只有<code>12.5%</code>的概率，一直随机到最顶层<code>L31</code>层。绝大多数元素都过不了几层，只有极少数元素可以深入到顶层。列表中的元素越多，能够深入的层次就越深，能进入到顶层的概率就会越大。</p><h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><hr><p>本文对Redis5种基础数据结构原理，内部实现,常用操作，场景等进行总结,</p><ul><li><code>string</code> 字符串, 内部结构未动态数组;</li><li><code>list</code> 列表, 内部结构为双向链表, 这个双向链表称之为<code>快速链表(quicklist)</code>, 由<code>ziplist压缩链表</code>通过<code>双向指针</code>连接而成，因而可以提高快速插入性能，同时<code>ziplist压缩列表</code>是一块连续内存的链表;</li><li><code>hash</code> 哈希， 内部结构为二维结构，一维为数组用于记录<code>key</code>键列表， 二维为链表用于记录<code>value</code>列表,通过一个<code>key</code>下挂着一个<code>value</code>链表，通过哈希函数取具体的<code>value</code>值;同时redis采用渐进式rehash可以方便对<code>hash</code>结构进行扩容和缩容;</li><li><code>set</code> 集合， 内部结构为<code>hash</code>结构，适用场景之一是判断某个元素是否存在于集合中，如多权限分配场景;</li><li><code>sortedset</code> 有序集合， <code>zset</code>底层实现使用了两个数据结构，第一个是<code>hash</code>，第二个是<code>跳跃列表</code>，<code>hash</code>的作用就是关联元素<code>value</code>和权重<code>score</code>，保障元素<code>value</code>的唯一性，可以通过元素<code>value</code>找到相应的<code>score</code>值。跳跃列表的目的在于给元素<code>value</code>排序，根据<code>score</code>的范围获取元素列表。</li></ul><ul><li><p>此外, 进一步分析了<code>跳跃表</code>的原理/用途，<code>跳跃表</code>也被用在<code>leveldb</code>中。 在一些词典结构中也经常用<code>跳跃表</code>来实现字典，加快查找速度；</p></li><li><p><code>list/set/hash/zset</code> 这四种数据结构是容器型数据结构，它们共享下面两条通用规则,</p><ul><li>如果容器不存在，那就创建一个，再进行操作。比如 rpush 操作刚开始是没有列表的，Redis 就会自动创建一个，然后再 rpush 进去新元素。</li><li>如果容器里元素没有了，那么立即删除元素，释放内存。这意味着 lpop 操作到最后一个元素，列表就消失了。</li></ul></li><li><p>Redis 所有的数据结构都可以设置过期时间，时间到了，Redis 会自动删除相应的对象。需要注意的是过期是以对象为单位，比如一个 hash 结构的过期是整个 hash 对象的过期，而不是其中的某个子 key。</p></li><li><p>还有一个需要特别注意的地方是如果一个字符串已经设置了过期时间，然后你调用了 set 方法修改了它，它的过期时间会消失。</p></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在日常应用开发中，redis常应用于热点内容缓存，分布式锁，权限认证等场景中，此redis专题试图对redis技术在内容缓存,分布式及redis集群场景中的应用，使用特性，原理及源码进行分析总结，内容来源于个人工作经验实践及网络学习资源的融合归纳总结;&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="redis专题" scheme="http://researchlab.github.io/categories/redis%E4%B8%93%E9%A2%98/"/>
    
    
      <category term="redis" scheme="http://researchlab.github.io/tags/redis/"/>
    
  </entry>
  
  <entry>
    <title>快速排序算法总结</title>
    <link href="http://researchlab.github.io/2017/09/19/quicksort-summary/"/>
    <id>http://researchlab.github.io/2017/09/19/quicksort-summary/</id>
    <published>2017-09-19T10:04:47.000Z</published>
    <updated>2018-10-18T05:08:14.838Z</updated>
    
    <content type="html"><![CDATA[<p>本文首先分别详细阐述了单向扫描、双向扫描快速排序算法原理,并用golang分别设计实现了这两种经典的快速排序算法; 然后本文从性能的角度分不同场景进一步讨论了快速排序改进算法并在文中通过程序设计实现了相关算法，最后基于上述场景从上述算法总结了快速算法的特性及适用场景;<br><a id="more"></a></p><blockquote><p>快速排序是对冒泡排序的一种改进, 采用分治策略, 通过一趟排序将要排序的数据分割成独立的两部分，其中一部分的所有数据都比另外一部分的所有数据都要小，然后再按此方法对这两部分数据分别进行快速排序，整个排序过程可以递归进行，以此达到整个数据变成有序序列。</p></blockquote><p>下面首先来阐述快排的两种经典实现方式: 单向扫描及双向扫描,</p><h2 id="单向扫描"><a href="#单向扫描" class="headerlink" title="单向扫描"></a>单向扫描</h2><p><strong>算法原理:</strong> 主要由两部分组成, 一部分是递归部分QuickSort, 它将调用partition进行划分, 并取得划分元素P, 然后分别对P之前的部分和P 之后的部分递归调用QuickSort; 另一部分是partition, 选取划分元素P（随机选取数组中的一个元素, 交换到数组末尾位置）, 定义两个标记值left和right, 随着划分的进行, 这两个标记值将数组分成三部分, left之左的部分是小于划分元素P的值, left和right之间的部分是大 于等于划分元素P的值（等于p的值没有必要进行交换）, right之右的部分是未划分的部分。运行中right自左向右遍历, left指向最左的一个不小于P的值, 当right遇见小于P的元素就与left当前索引的值交换, right和left同时前进，否则right直接前进，直到数组末尾，最后将P与left当前指向的值交换, 并且返回i的值;</p><h2 id="双向扫描"><a href="#双向扫描" class="headerlink" title="双向扫描"></a>双向扫描</h2><h2 id="三中值扫描"><a href="#三中值扫描" class="headerlink" title="三中值扫描"></a>三中值扫描</h2>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文首先分别详细阐述了单向扫描、双向扫描快速排序算法原理,并用golang分别设计实现了这两种经典的快速排序算法; 然后本文从性能的角度分不同场景进一步讨论了快速排序改进算法并在文中通过程序设计实现了相关算法，最后基于上述场景从上述算法总结了快速算法的特性及适用场景;&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="algorithm" scheme="http://researchlab.github.io/categories/algorithm/"/>
    
    
      <category term="golang" scheme="http://researchlab.github.io/tags/golang/"/>
    
      <category term="quicksort" scheme="http://researchlab.github.io/tags/quicksort/"/>
    
  </entry>
  
  <entry>
    <title>搭建Docker Registry容器服务</title>
    <link href="http://researchlab.github.io/2017/09/15/docker-registry-v2/"/>
    <id>http://researchlab.github.io/2017/09/15/docker-registry-v2/</id>
    <published>2017-09-15T14:32:05.000Z</published>
    <updated>2018-10-18T05:08:14.830Z</updated>
    
    <content type="html"><![CDATA[<p>Docker Registry 是一个用来管理Docker镜像的服务，本身也是一个Docker容器。搭建一个私有的Docker Registry的使用场景主要有下面几个:<br>1.当需要对容器镜像存储进行完全控制,就不能依赖官方提供的Docker Hub进行管理;<br>2.当内部使用存在网络问题或安全问题等情况都适合搭建私有的Docker Registry对镜像进行管理;</p><p>下面从需频繁pull镜像到某内部机器上新建容器的需求来搭建需要认证访问的Docker Registry,这样同时可以解决网络依赖问题及安全问题, 下面是搭建Docker Registry过程的记录和总结;<br><a id="more"></a></p><h2 id="搭建Docker-Registry"><a href="#搭建Docker-Registry" class="headerlink" title="搭建Docker Registry"></a>搭建Docker Registry</h2><p>1.要搭建本地私有Registry, 首先需要一个Docker Registry基础镜像,直接pull官方镜像即可,<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker pull registry</span><br></pre></td></tr></table></figure></p><p>2.通过下面的命令运行一个基于上面pull的Registry容器服务,<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run -d -p 5000:5000 --restart=always -v /opt/registry-var/:/var/lib/registry/ registry:latest</span><br></pre></td></tr></table></figure></p><p><strong>注:</strong> </p><ul><li>上面需要注意的是新registry仓库数据目录的位置。容器内部新registry的仓库目录是在/var/lib/registry, 所以运行时挂载目录需要注意,因为挂着到别的目录是运行不的;</li><li>其中<code>-v</code>选项 是将本地(宿主机)/opt/registry-var/目录挂载到容器的/var/lib/registry/目录上,</li></ul><p>当上面Registry服务启动之后可通过curl <a href="http://100.73.41.17:5000/v2/_catalog" target="_blank" rel="noopener">http://100.73.41.17:5000/v2/_catalog</a> (假设上面启动Registry服务的的机器ip为:100.73.41.17)能看到json格式的返回值时，说明registry已经运行起来了。</p><p>但上面运行的Registry服务是没有设置认证权限的,即未授权用户也是可以访问上述Registry服务的，为了安全起见一般都会设置认证权限用于访问,</p><p>3.配置带用户权限的registry<br>现在registry已经可以使用了。如果想要控制registry的使用权限，使其只有在登录用户名和密码之后才能使用的话，还需要做额外的设置。<br>registry的用户名密码文件可以通过htpasswd来生成,<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mkdir /opt/registry-var/auth/</span><br><span class="line">docker run --entrypoint htpasswd registry:latest -Bbn felix felix  &gt;&gt; /opt/registry-var/auth/htpasswd</span><br></pre></td></tr></table></figure></p><p>上面这条命令是为felix用户名生成密码为felix的一条用户信息，存在/opt/registry-var/auth/htpasswd文件里面，文件中存的密码是被加密过的。<br>启动带权限配置的docker Registry服务就需要多加几个配置参数了, 启动命令如下:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">docker run -d -p 5000:5000 --restart=always \</span><br><span class="line">  -v /opt/registry-var/auth/:/auth/ \</span><br><span class="line">  -e <span class="string">"REGISTRY_AUTH=htpasswd"</span> \</span><br><span class="line">  -e <span class="string">"REGISTRY_AUTH_HTPASSWD_REALM=Registry Realm"</span> \</span><br><span class="line">  -e REGISTRY_AUTH_HTPASSWD_PATH=/auth/htpasswd \</span><br><span class="line">  -v /opt/registry-var/:/var/lib/registry/ \</span><br><span class="line">  registry:latest</span><br></pre></td></tr></table></figure><p><strong>注:</strong></p><ul><li>挂载认证目录到容器中: <code>-v /opt/registry-var/auth/:/auth/</code></li><li>设置认证方式: <code>-e &quot;REGISTRY_AUTH=htpasswd&quot;</code> </li><li>设置认证方式: <code>-e &quot;REGISTRY_AUTH_HTPASSWD_REALM=Registry Realm&quot;</code> </li><li>设置认证路径: <code>-e REGISTRY_AUTH_HTPASSWD_PATH=/auth/htpasswd</code></li><li>挂载镜像目录: <code>-v /opt/registry-var/:/var/lib/registry/</code></li><li>端口映射 <code>-p 5000:5000</code> 注意Docker Registry容器内部默认监听的是<code>5000</code>端口,如果要修改内部监听端口可通过指定参数<code>REGISTRY_HTTP_ADDR</code>即可修改，如修改为内部监听<code>5001</code>端口,</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">docker run -d --restart=always \</span><br><span class="line">-e REGISTRY_HTTP_ADDR=0.0.0.0:5001 \</span><br><span class="line">  -p 5000:5001 \</span><br><span class="line">  -v /opt/registry-var/auth/:/auth/ \</span><br><span class="line">  -e <span class="string">"REGISTRY_AUTH=htpasswd"</span> \</span><br><span class="line">  -e <span class="string">"REGISTRY_AUTH_HTPASSWD_REALM=Registry Realm"</span> \</span><br><span class="line">  -e REGISTRY_AUTH_HTPASSWD_PATH=/auth/htpasswd \</span><br><span class="line">  -v /opt/registry-var/:/var/lib/registry/ \</span><br><span class="line">  registry:latest</span><br></pre></td></tr></table></figure><h2 id="管理镜像"><a href="#管理镜像" class="headerlink" title="管理镜像"></a>管理镜像</h2><p>上面认证Docker Registry 服务准备好之后，就可以用来管理镜像了，管理镜像一般分下面三步,<br>1.认证登录Docker Registry<br>因为需要认证所以在管理镜像时首选需要通过下面的命令认证登录,<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker login 100.73.41.17:5000</span><br></pre></td></tr></table></figure></p><p>通过上述命令按照提示输入登录名和密码即可登录，但是有可能会遇到下面的提示,而登录失败,<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">➜  docker login 100.73.41.17:5000</span><br><span class="line">Username (xxx): xxx </span><br><span class="line">Password:</span><br><span class="line">Error response from daemon: Get https://100.73.41.17:5000/v2/: http: server gave HTTP response to HTTPS client</span><br></pre></td></tr></table></figure></p><p>这个提示已经很明显告诉你是因为client(https)请求与server(http)接收端协议对不上导致,那如何解决？ 网上千篇一律的告诉你要做如下设置:<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">➜  cat /etc/docker/daemon.json</span><br><span class="line">&#123;</span><br><span class="line"><span class="string">"insecure-registries"</span>:[<span class="string">"100.73.41.17:5000"</span>]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>是的没错, 是通过上述设置即可解决问题,但是这个设置不是设置在Docker Registry启动的那台机器上(上面是:100.73.41.17), 这个是要设置在你在那台机器上进行登录上传下载镜像操作的机器上，</p><p>如上面所设置，我的Docker Registry是搭建在100.73.41.17这台远程机器上,而我需要在本地的Mac 机器上登录远程得这个私有的Docker Registry 进行上传下载操作，那么上面的设置就要设置在我的Mac机器的Docker配置中;</p><p>但是在Mac机器上好像没有发现/etc/docker/daemon.json这个文件，后来通过docker client的图形界面进行设置的，如下，设置之后需要重启docker server,如我需要重启Mac机器上的docker server;</p><p><center><img src="/2017/09/15/docker-registry-v2/set_insecure_registries.png" alt=""><br>图1 设置insecure-registries</center><br>不过设置<code>insecure-registries</code>是非常不安全的，官方文档中也不推荐而是给出自己生成证书的方式进行认证，<a href="https://docs.docker.com/registry/insecure/#troubleshoot-insecure-registry" target="_blank" rel="noopener">官方链接</a><br>而生产环境中一般需要配置两道认证，第一道认证即证书认证就是将启动Docker Registry 服务的认证证书copy一份到操作Docker Registry机器上（如我的Mac机器）， 第二道认证即上面的用户名密码认证; 具体<a href="https://docs.docker.com/registry/deploying/#native-basic-auth" target="_blank" rel="noopener">官方链接</a><br>1.写入本地镜像到私有Docker Registry,<br>上面登录成功后，接着就可以把本地的镜像推送到远程私有Docker Registry上去了,不过这里需要注意的是待推送到远程Registry上去的本地镜像其名字前缀必须设置为<code>100.73.41.17:5000/</code>, 因为下面要去取镜像时,按照docker读取镜像的规则是<code>镜像地址/镜像名称</code>, 通过镜像地址读取镜像名称, 如果在读取镜像是只给出镜像名称, 则Docker会到官方的Docker Hub上去下载相应的镜像而非本地私有Registry库;下面假设已经制作了一个jenkins镜像但是其前缀不是上面的Registry服务地址,可通过docker tag命令给镜像重新命名然后上传到私有Registry即可，具体命令如下,<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">docker tag jenkins:latest 100.73.41.17:5000/jenkins:latest</span><br><span class="line">docker push 100.73.41.17:5000/jenkins:latest</span><br></pre></td></tr></table></figure></p><p>2.读取镜像到本地<br>上面成功把镜像推送到远程Docker Registry服务上之后，要用时怎么读取到本地？ 在认证登录远程私有Docker Registry通过如下pull命令即可取回目标镜像,<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker pull 100.73.41.17:5000/jenkins:latest</span><br></pre></td></tr></table></figure></p><p>3.删除镜像<br>当镜像上传到远程私有Docker Registry 之后, 发现不需要想删除怎么办？ docker registry应该提供了删除镜像的方法的,不过这个好像在启动Docker Registry 需要配置可删除的开关才行,那么有什么简单的办法可以直接删除呢？办法当然有, 还记得在启动Docker Registry容器服务时, 挂载的镜像目录<code>-v /opt/registry-var/:/var/lib/registry/</code> ？ 是的你上传的镜像其实都在本地的<code>/opt/registry-var/</code>目录下,在这里手动删除即可，虽然简单粗暴；</p><h2 id="详细配置"><a href="#详细配置" class="headerlink" title="详细配置"></a>详细配置</h2><p>上面启动Docker Registry 服务对镜像进行管理,但是这个Registry还有些什么特性可以用于对镜像的管理呢？可以通过设置镜像启动容器的配置来管理,<br>首先在本地配置好自定义配置然后通过volume挂载到容器内部即可，这样Registry容器启动命令如下,<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">docker run -d --restart=always \</span><br><span class="line">-e REGISTRY_HTTP_ADDR=0.0.0.0:5001 \</span><br><span class="line">  -p 5000:5001 \</span><br><span class="line">  -v /opt/registry-var/auth/:/auth/ \</span><br><span class="line">  -e <span class="string">"REGISTRY_AUTH=htpasswd"</span> \</span><br><span class="line">  -e <span class="string">"REGISTRY_AUTH_HTPASSWD_REALM=Registry Realm"</span> \</span><br><span class="line">  -e REGISTRY_AUTH_HTPASSWD_PATH=/auth/htpasswd \</span><br><span class="line">  -v /opt/registry-var/:/var/lib/registry/ \</span><br><span class="line">-v /<span class="built_in">local</span>/path/to/config.yml:/etc/docker/registry/config.yml \</span><br><span class="line">  registry:latest</span><br></pre></td></tr></table></figure></p><p>其中Registry 容器的官方配置文件及配置字段参考官方即可<a href="https://docs.docker.com/registry/configuration/#list-of-configuration-options" target="_blank" rel="noopener">Registry配置文件及配置字段官方文档</a></p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ul><li>本文总结了如何搭建私有Docker Registry服务;</li><li>本文总结了如何设置认证权限,并建议在生成环境中同时配置证书认证及密码认证两道安全认证措施;</li><li>同时也演示了如何用搭建好的私有Docker Registry服务进行镜像上传下载删除等管理工作；</li><li>在总结本文时重点参考了官方文档, 发现之前在搭建Docker  Registry服务时并没有这么清楚，包括出现的错误等问题也是先通过搜索引擎来解决问题，但现在看来其实官方文档中也给出了可能存在的异常情况并给出了较为全面的解决方案;</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Docker Registry 是一个用来管理Docker镜像的服务，本身也是一个Docker容器。搭建一个私有的Docker Registry的使用场景主要有下面几个:&lt;br&gt;1.当需要对容器镜像存储进行完全控制,就不能依赖官方提供的Docker Hub进行管理;&lt;br&gt;2.当内部使用存在网络问题或安全问题等情况都适合搭建私有的Docker Registry对镜像进行管理;&lt;/p&gt;
&lt;p&gt;下面从需频繁pull镜像到某内部机器上新建容器的需求来搭建需要认证访问的Docker Registry,这样同时可以解决网络依赖问题及安全问题, 下面是搭建Docker Registry过程的记录和总结;&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="docker-practice" scheme="http://researchlab.github.io/categories/docker-practice/"/>
    
    
      <category term="docker" scheme="http://researchlab.github.io/tags/docker/"/>
    
  </entry>
  
  <entry>
    <title>一步一步构建自己的RPC server</title>
    <link href="http://researchlab.github.io/2017/03/20/build-rpc-server-in-golang/"/>
    <id>http://researchlab.github.io/2017/03/20/build-rpc-server-in-golang/</id>
    <published>2017-03-20T21:28:14.000Z</published>
    <updated>2018-10-18T05:08:14.826Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://en.wikipedia.org/wiki/Remote_procedure_call" target="_blank" rel="noopener">远程程序调用(Remote procedure call, RPC)</a>是进程间通信的一种基本形式， 并且广泛用于分布式计算中。下面就通过一步一步构建一个简单的RPC服务器来总结加深对RPC应用的理解。</p><a id="more"></a><h2 id="公共接口和结构"><a href="#公共接口和结构" class="headerlink" title="公共接口和结构"></a>公共接口和结构</h2><p>方便起见，假设有一个包含<code>Multiply</code>和<code>Divide</code>方法的接口， 这两个接口分别表示乘法<code>*</code>和除法<code>/</code>操作，另外存在一个<code>Args</code>的结构体用于将客户端参数传递到服务器端， 还存在一个<code>Quotient</code>的公共结构，用于表示乘法和除法操作的输出结果，具体如下，</p><p>公共结构<br><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//file: shared_structs.go</span></span><br><span class="line"><span class="keyword">package</span> shared </span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Args <span class="keyword">struct</span> &#123;</span><br><span class="line">A, B <span class="keyword">int</span> </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Quotient <span class="keyword">struct</span> &#123;</span><br><span class="line">Quo, Rem <span class="keyword">int</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>公共接口<br><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//file interface.go </span></span><br><span class="line"></span><br><span class="line"><span class="keyword">package</span> shared </span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Arith <span class="keyword">interface</span> &#123;</span><br><span class="line">Multiply(args *Args, reply *<span class="keyword">int</span>) error</span><br><span class="line">Divide(args *Args, quo *Quotient) error</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="接口实现"><a href="#接口实现" class="headerlink" title="接口实现"></a>接口实现</h2><p>下面简单实现上述定义的公共接口， 具体如下，<br><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//file interface_implementation.go </span></span><br><span class="line"></span><br><span class="line"><span class="keyword">package</span> main </span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span>(</span><br><span class="line"><span class="string">"shared"</span> </span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">// Every method that we want to export must have </span></span><br><span class="line"><span class="comment">// (1) the method has two arguments, both exported(or builtin) types</span></span><br><span class="line"><span class="comment">// (2) the method's second argument is a pointer </span></span><br><span class="line"><span class="comment">// (3) the method has return type error</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Arith <span class="keyword">int</span> </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(t *Arith)</span> <span class="title">Multiply</span><span class="params">(args *shared.Args, reply *<span class="keyword">int</span>)</span> <span class="title">error</span></span>&#123;</span><br><span class="line">*reply = args.A * args.B </span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(t * Arith)</span> <span class="title">Divide</span><span class="params">(args *shared.Args, quo *shared.Quotient)</span> <span class="title">error</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span> args.B == <span class="number">0</span> &#123;</span><br><span class="line"><span class="keyword">return</span> errors.New(<span class="string">"divide by zero"</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">quo.Quo = args.A / args.B</span><br><span class="line">quo.Rem = args.A % args.B </span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span> </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="RPC-server-实现"><a href="#RPC-server-实现" class="headerlink" title="RPC server 实现"></a>RPC server 实现</h2><p>可以通过HTTP协议或TCP协议来实现一个RPC server, 下面用这两种方式分别实现RPC server。</p><h3 id="HTTP-RPC-server-client"><a href="#HTTP-RPC-server-client" class="headerlink" title="HTTP RPC server/client"></a>HTTP RPC server/client</h3><ul><li><p>HTTP RPC server 实现<br>这种方法即先通过监听HTTP 协议链接，然后转换到RPC 协议上， 这种方法的好处是可以很方便对客户端链接请求进行授权验证，因为HTTP可以方便地支持多种授权验证，具体实现如下， </p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// file: server_http.go </span></span><br><span class="line"><span class="keyword">package</span> main </span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span>(</span><br><span class="line"><span class="string">"errors"</span></span><br><span class="line"><span class="string">"log"</span></span><br><span class="line"><span class="string">"net"</span></span><br><span class="line"><span class="string">"net/http"</span></span><br><span class="line"><span class="string">"net/rpc"</span></span><br><span class="line"></span><br><span class="line"><span class="string">"shared"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">registerArith</span><span class="params">(server *rpc.Server, arith shared.Arith)</span></span> &#123;</span><br><span class="line"><span class="comment">// registers Arith interface by name of `Arithmetic`.</span></span><br><span class="line"><span class="comment">// If you want this name to be same as the type name, you can </span></span><br><span class="line"><span class="comment">// use server.Register instead.</span></span><br><span class="line">server.RegisterName(<span class="string">"Arithmetic"</span>, arith)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="comment">// Creating an instance of struct which implement Arith interface </span></span><br><span class="line">arith := <span class="built_in">new</span>(Arith)</span><br><span class="line"></span><br><span class="line"><span class="comment">// Register a new rpc server (In most cases, you will use default server only) </span></span><br><span class="line"><span class="comment">// And register struct we created above by name "Arith"</span></span><br><span class="line"><span class="comment">// The wrapper method here ensures that only structs which implement Arith interface</span></span><br><span class="line"><span class="comment">// are allowed to register themselves. </span></span><br><span class="line"></span><br><span class="line">server := rpc.NewServer()</span><br><span class="line">registerArith(server, arith)</span><br><span class="line"></span><br><span class="line"><span class="comment">// registers an HTTP handler for RPC messages on rpcPath, and a debugging handler on debugPath</span></span><br><span class="line">server.HandleHTTP(<span class="string">"/"</span>, <span class="string">"/debug"</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// Listen for incoming tcp packets on specified port. </span></span><br><span class="line">l, e := net.Listen(<span class="string">"tcp"</span>, <span class="string">":1234"</span>)</span><br><span class="line"><span class="keyword">if</span> e != <span class="literal">nil</span> &#123;</span><br><span class="line">log.Fatal(<span class="string">"listen error:"</span>, e)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// This statement starts go's http server on </span></span><br><span class="line"><span class="comment">// socket specified by l .</span></span><br><span class="line">http.Serve(l, <span class="literal">nil</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>HTTP RPC Client </p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// file: client_http.go </span></span><br><span class="line"></span><br><span class="line"><span class="keyword">package</span> main </span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span>(</span><br><span class="line"><span class="string">"fmt"</span></span><br><span class="line"><span class="string">"log"</span></span><br><span class="line"><span class="string">"net/rpc"</span></span><br><span class="line"></span><br><span class="line"><span class="string">"shared"</span> </span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Arith <span class="keyword">struct</span> &#123;</span><br><span class="line">client *rpc.Client </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(t * Arith)</span> <span class="title">Divide</span><span class="params">(a, b <span class="keyword">int</span>)</span> <span class="title">shared</span>.<span class="title">Quotient</span></span>&#123;</span><br><span class="line">args := &amp;shared.Args&#123;a, b&#125;</span><br><span class="line"><span class="keyword">var</span> reply shared.Quotient </span><br><span class="line">err := t.client.Call(<span class="string">"Arithmetic.Divide"</span>, args, &amp;reply)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">log.Fatal(<span class="string">"arith error:"</span>, err)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> reply</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(t *Arith)</span><span class="title">Multiply</span><span class="params">(a, b <span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">args := &amp;shared.Args&#123;a, b&#125; </span><br><span class="line"><span class="keyword">var</span> reply <span class="keyword">int</span> </span><br><span class="line">err := t.client.Call(<span class="string">"Arithmetic.Multiply"</span>, args, &amp;reply)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">log.Fatal(<span class="string">"arith error:"</span>, err)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> reply</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="comment">// Tries to connect to localhost:1234 using HTTP protocol (The port on which rpc server is listening)</span></span><br><span class="line">client, err := rpc.DialHTTP(<span class="string">"tcp"</span>, <span class="string">"localhost:1234"</span>)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">log.Fatal(<span class="string">"dialing:"</span>, err)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Create a struct, that mimics all methods provided by interface.</span></span><br><span class="line"><span class="comment">// It is not compulsory, we are doing it here, just to simulate a traditional method call.</span></span><br><span class="line">arith := &amp;Arith&#123;client: client&#125;</span><br><span class="line">fmt.Println(arith.Multiply(<span class="number">5</span>, <span class="number">6</span>)) </span><br><span class="line">    fmt.Println(arith.Divide(<span class="number">500</span>, <span class="number">10</span>))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h3 id="TCP-RPC-server-client"><a href="#TCP-RPC-server-client" class="headerlink" title="TCP RPC server/client"></a>TCP RPC server/client</h3><p>上述通过<code>HTTP</code>协议实现来一个RPC server/client, 但是需要先监听HTTP协议链接，然后转换到RPC协议上来， 这就多了一个转换操作， 下面通过TCP协议来实现RPC server， 则可以直接监听链接，无需依赖HTTP协议， 具体实现如下，</p><ul><li>TCP RPC server </li></ul><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// file: tcp_server.go</span></span><br><span class="line"><span class="keyword">package</span> main </span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span>(</span><br><span class="line"><span class="string">"errors"</span></span><br><span class="line"><span class="string">"log"</span></span><br><span class="line"><span class="string">"net"</span></span><br><span class="line"><span class="string">"net/rpc"</span></span><br><span class="line"><span class="string">"shared"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">registerArith</span><span class="params">(server *rpc.Server, arith shared.Arith)</span></span> &#123;</span><br><span class="line"><span class="comment">// registers Arith interface by name of `Arithmetic`. </span></span><br><span class="line"><span class="comment">// If you want this name to be same as the type name, you </span></span><br><span class="line"><span class="comment">// can use server.Register instead. </span></span><br><span class="line">server.RegisterName(<span class="string">"Arithmetic"</span>, arith)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="comment">// Creating an instance of struct which implement Arith interface</span></span><br><span class="line">arith := <span class="built_in">new</span>(Arith)</span><br><span class="line"></span><br><span class="line"><span class="comment">// Register a new rpc server (In most cases, you will use default server only) </span></span><br><span class="line"><span class="comment">// And register struct we created above by name "Arith"</span></span><br><span class="line"><span class="comment">// The wrapper method here ensures that only structs which iplement Arith interface </span></span><br><span class="line"><span class="comment">// are allowed to register themselves.</span></span><br><span class="line">server := rpc.NewServer()</span><br><span class="line">registerArith(server, arith)</span><br><span class="line"></span><br><span class="line"><span class="comment">// Listen for incoming tcp packets on specified port. </span></span><br><span class="line">l, e := net.Listen(<span class="string">"tcp"</span>, <span class="string">":1234"</span>)</span><br><span class="line"><span class="keyword">if</span> e != <span class="literal">nil</span> &#123;</span><br><span class="line">log.Fatal(<span class="string">"listen error:"</span>, e)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//This statment links rpc server to the socket, and allows rpc server to accept </span></span><br><span class="line"><span class="comment">// rpc request comming from that socket. </span></span><br><span class="line">server.Accept(l)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>TCP RPC client </li></ul><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// file: tcp_client.go </span></span><br><span class="line"><span class="keyword">package</span> main </span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span>(</span><br><span class="line"><span class="string">"fmt"</span></span><br><span class="line"><span class="string">"log"</span></span><br><span class="line"><span class="string">"net"</span></span><br><span class="line"><span class="string">"net/rpc"</span></span><br><span class="line"><span class="string">"shared"</span> </span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Arith <span class="keyword">struct</span> &#123;</span><br><span class="line">client *rpc.Client </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(t *Arith)</span> <span class="title">Divide</span><span class="params">(a, b <span class="keyword">int</span>)</span> <span class="title">shared</span>.<span class="title">Quotient</span></span> &#123;</span><br><span class="line">args := &amp;shared.Args&#123;a, b&#125;</span><br><span class="line"><span class="keyword">var</span> reply shared.Quotient </span><br><span class="line">err := t.client.Call(<span class="string">"Arithmetic.Divide"</span>, args, &amp;reply)</span><br><span class="line"><span class="keyword">if</span> err !=<span class="literal">nil</span> &#123;</span><br><span class="line">log.Fatal(<span class="string">"arith error:"</span>, err)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> reply</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(t *Arith)</span> <span class="title">Multiply</span><span class="params">(a, b <span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">args := &amp;shared.Args&#123;a, b&#125;</span><br><span class="line"><span class="keyword">var</span> reply <span class="keyword">int</span> </span><br><span class="line">err := t.client.Call(<span class="string">"Arithmetic.Multiply"</span>, args, &amp;reply)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">log.Fatal(<span class="string">"arith error:"</span>, err)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> reply</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="comment">// Tries to connect to localhost:1234 (The port on which rpc server is listening)</span></span><br><span class="line">conn, err := net.Dial(<span class="string">"tcp"</span>, <span class="string">"localhost:1234"</span>)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">log.Fatal(<span class="string">"Connectiong:"</span>, err)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Create a struct, that mimics all methods provided by interface. </span></span><br><span class="line"><span class="comment">// It is not compulsory, we are doing it here, just to simulate a tradional method call. </span></span><br><span class="line">arith := &amp;Arith&#123;client: rpc.NewClient(conn)&#125;</span><br><span class="line"></span><br><span class="line">fmt.Println(arith.Multiply(<span class="number">5</span>, <span class="number">6</span>))</span><br><span class="line">fmt.Println(arith.Divide(<span class="number">500</span>, <span class="number">10</span>))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ul><li>通过用HTTP协议和TCP协议分别实现了RPC 服务， 加深了对RPC应用的理解， </li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;a href=&quot;https://en.wikipedia.org/wiki/Remote_procedure_call&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;远程程序调用(Remote procedure call, RPC)&lt;/a&gt;是进程间通信的一种基本形式， 并且广泛用于分布式计算中。下面就通过一步一步构建一个简单的RPC服务器来总结加深对RPC应用的理解。&lt;/p&gt;
    
    </summary>
    
      <category term="golang" scheme="http://researchlab.github.io/categories/golang/"/>
    
    
      <category term="golang" scheme="http://researchlab.github.io/tags/golang/"/>
    
      <category term="rpc" scheme="http://researchlab.github.io/tags/rpc/"/>
    
  </entry>
  
  <entry>
    <title>docker实践--06 运行MongoDB和Redis</title>
    <link href="http://researchlab.github.io/2017/03/08/docker-run-mongodb-redis/"/>
    <id>http://researchlab.github.io/2017/03/08/docker-run-mongodb-redis/</id>
    <published>2017-03-08T20:49:20.000Z</published>
    <updated>2018-10-18T05:08:14.830Z</updated>
    
    <content type="html"><![CDATA[<p>上篇文件总结了如何编写<code>Dockerfile</code>及如何通过<code>Dockerfile</code>构建镜像并运行相应的应用需求, 本文将通过编写<code>Dockerfile</code>来创建MongoDB和Redis应用进一步学习实践<code>Docker</code>的运行机制。<br><a id="more"></a></p><blockquote><p>MongoDB 是一个基于分布式文件存储的数据库。由C++语言编写。旨在为WEB应用提供可扩展的高性能数据存储解决方案。MongoDB 是一个介于关系数据库和非关系数据库之间的产品，是非关系数据库当中功能最丰富，最像关系数据库的数据库。特点是高性能、易部署、易使用，存储数据非常方便。 </p><p>Redis是一个开源的使用ANSI C语言编写、支持网络、可基于内存亦可持久化的日志型、Key-Value数据库，并提供多种语言的API。 </p></blockquote><p><strong> 需求 </strong><br>在Docker中创建MongoDB和Redis应用</p><p><strong> 需求分析 </strong></p><p>首先需要安装和配置<code>MongoDB</code> 和<code>Redis</code> 然后编写<code>Dockerfile</code> , 最后通过<code>Dockerfile</code>构建镜像, 并通过<code>docker run</code>基于该新镜像运行容器来创建MongoDB和Redis应用。</p><h2 id="编写Dockerfile"><a href="#编写Dockerfile" class="headerlink" title="编写Dockerfile"></a>编写Dockerfile</h2><p>向<code>Dockerfile</code>文件写入如下命令,<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Version 0.1 </span></span><br><span class="line"></span><br><span class="line"><span class="comment"># basic image</span></span><br><span class="line">FROM nbuntu:latest</span><br><span class="line"></span><br><span class="line"><span class="comment"># Maintainer</span></span><br><span class="line">MAINTAINER lihong/leehongitrd@163.com</span><br><span class="line"></span><br><span class="line"><span class="comment"># RUN </span></span><br><span class="line">RUN apt-get install -yqq supervisor &amp;&amp; apt-get clean </span><br><span class="line"></span><br><span class="line"><span class="comment"># CMD</span></span><br><span class="line"></span><br><span class="line">CMD [<span class="string">"supervisord"</span>]</span><br></pre></td></tr></table></figure></p><p>说明,<br>上述<code>FROM</code>镜像是采用自己重新修改过的镜像, 这个新的<code>nbuntu</code>镜像是安装了<code>ifconfig</code>, <code>ping</code>等<code>net-tools</code>工具的镜像;</p><p>为便于管理, 将安装ssh服务来提供便捷的管理<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">RUN apt-get install -yqq openssh-server openssh-client</span><br></pre></td></tr></table></figure></p><p>创建运行目录<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">RUN mkdir /var/run/sshd</span><br></pre></td></tr></table></figure></p><p>设置root密码及充许root通过ssh登录,<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">RUN <span class="built_in">echo</span> <span class="string">'root:123456'</span> | chpasswd</span><br><span class="line"><span class="comment">#RUN sed -i 's/PermitRootLogin without-password/PermitRootLogin yes/' /etc/ssh/sshd_config</span></span><br><span class="line">RUN sed -i <span class="string">'s/PermitRootLogin prohibit-password/PermitRootLogin yes/'</span> /etc/ssh/sshd_config</span><br></pre></td></tr></table></figure></p><p>注: ubuntu系统的不同版本中设置充许root通过ssh登录的命令是不同的，如在ubuntu14.04版本中是如下命令，<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">RUN sed -i <span class="string">'s/PermitRootLogin without-password/PermitRootLogin yes/'</span> /etc/ssh/sshd_config</span><br></pre></td></tr></table></figure></p><p>而在ubuntu16.04.2版本中, 则为如下命令,<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">RUN sed -i <span class="string">'s/PermitRootLogin prohibit-password/PermitRootLogin yes/'</span> /etc/ssh/sshd_config</span><br></pre></td></tr></table></figure></p><p>现在<code>Dockerfile</code>如下所示,<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Version 0.1</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 基础镜像</span></span><br><span class="line">FROM nbuntu:latest</span><br><span class="line"></span><br><span class="line"><span class="comment"># 维护者信息</span></span><br><span class="line">MAINTAINER lihong/leehongitrd@163.com</span><br><span class="line"></span><br><span class="line"><span class="comment"># 镜像操作命令</span></span><br><span class="line">RUN apt-get -yqq update &amp;&amp; apt-get install -yqq supervisor</span><br><span class="line">RUN apt-get install -yqq openssh-server openssh-client</span><br><span class="line"></span><br><span class="line">RUN mkdir /var/run/sshd</span><br><span class="line">RUN <span class="built_in">echo</span> <span class="string">'root:123456'</span> | chpasswd</span><br><span class="line">RUN sed -i <span class="string">'s/PermitRootLogin prohibit-password/PermitRootLogin yes/'</span> /etc/ssh/sshd_config</span><br></pre></td></tr></table></figure></p><p>到目前为止<code>Dockerfile</code>如上述所示, 下面要分别编写<code>MongoDB</code>和<code>Redis</code>的<code>Dockerfile</code>都将基于这个<code>Dockerfile</code>来完成,暂且将当前这个<code>Dockerfile</code>称为第一部分<code>Dockerfile</code>, 以便于区分下文中<code>MongoDB Dockerfile</code>和<code>Redis Dockerfile</code></p><h2 id="编写MongoDB-Dockerfile"><a href="#编写MongoDB-Dockerfile" class="headerlink" title="编写MongoDB Dockerfile"></a>编写MongoDB Dockerfile</h2><p>基于上述已经完成的第一部分<code>Dockerfile</code>编写<code>MongoDB</code>的<code>Dockerfile</code>。 首先将当前目录下(/home/lihong/docker)的<code>Dockerfile</code> 复制一份到/home/lihong/docker/mongodb目录下, 就从/home/lihong/docker/mongodb/Dockerfile的基础上编写下述<code>MongoDB</code>的<code>Dockerfile</code>,</p><p><strong> 1 安装MongoDB </strong></p><p>在Ubuntu上安装MongoDB有两种方法,</p><p>方法一: 添加mongodb的源, 执行<code>apt-get install mongodb-org</code>就可以安装下面的所有软件包,</p><ul><li><code>mongodb-org-server</code>：mongod 服务和配置文件</li><li><code>mongodb-org-mongos</code>：mongos 服务</li><li><code>mongodb-org-shell</code>：mongo shell工具</li><li><code>mongodb-org-tools</code>：mongodump，mongoexport等工具</li></ul><p>方法二: 下载二进制包，然后解压出来就可以。</p><p>本文推荐使用此方案, 从MongoDB官网得知下载链接如下：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">https://fastdl.mongodb.org/linux/mongodb-linux-x86_64-ubuntu1604-3.4.2.tgz</span><br></pre></td></tr></table></figure></p><p>使用<code>ADD</code>命令添加压缩包到镜像, 向<code>Dockerfile</code>中写入如下内容,<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">RUN mkdir -p /opt</span><br><span class="line">ADD https://fastdl.mongodb.org/linux/mongodb-linux-x86_64-ubuntu1604-3.4.2.tgz /opt/mongodb.tar.gz</span><br><span class="line">RUN <span class="built_in">cd</span> /opt &amp;&amp; tar zxvf mongodb.tar.gz &amp;&amp; rm -rf mongodb.tar.gz</span><br><span class="line">RUN mv /opt/mongodb-linux-x86_64-ubuntu1604-3.4.2 /opt/mongodb</span><br></pre></td></tr></table></figure></p><p>接下来创建<code>MongoDB</code>的数据存储目录,<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">RUN mkdir -p /data/db</span><br></pre></td></tr></table></figure></p><p>将<code>MongoDB</code>的执行路径添加到环境变量里,<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ENV PATH=/opt/mongodb/bin:<span class="variable">$PATH</span></span><br></pre></td></tr></table></figure></p><p><code>MongoDB</code>和<code>SSH</code>对外的端口：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">EXPOSE 27017 22</span><br></pre></td></tr></table></figure></p><p><strong> 2 编写Supervisord配置文件 </strong></p><p>添加<code>Supervisord</code>配置文件来启动<code>mongodb</code>和<code>ssh</code>, 创建文件<code>/home/lihong/docker/mongodb/supervisord.conf</code>, 添加以下内容,<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">[supervisord]</span><br><span class="line">nodaemon=<span class="literal">true</span></span><br><span class="line"></span><br><span class="line">[program:mongodb]</span><br><span class="line"><span class="built_in">command</span>=/opt/mongodb/bin/mongod</span><br><span class="line"></span><br><span class="line">[program:ssh]</span><br><span class="line"><span class="built_in">command</span>=/usr/sbin/sshd -D</span><br></pre></td></tr></table></figure></p><p>在<code>Dockerfile</code>中增加向镜像内拷贝该文件的命令,<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">COPY supervisord.conf /etc/supervisor/conf.d/supervisord.conf</span><br></pre></td></tr></table></figure></p><p><strong> 3 完整的MongoDB Dockerfile </strong><br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Version 0.1</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 基础镜像</span></span><br><span class="line">FROM nbuntu:latest</span><br><span class="line"></span><br><span class="line"><span class="comment"># 维护者信息</span></span><br><span class="line">MAINTAINER lihong/leehongitrd@163.com</span><br><span class="line"></span><br><span class="line"><span class="comment"># 镜像操作命令</span></span><br><span class="line">RUN apt-get install -yqq supervisor</span><br><span class="line">RUN apt-get install -yqq openssh-server openssh-client</span><br><span class="line"></span><br><span class="line">RUN mkdir /var/run/sshd</span><br><span class="line">RUN <span class="built_in">echo</span> <span class="string">'root:123456'</span> | chpasswd</span><br><span class="line">RUN sed -i <span class="string">'s/PermitRootLogin prohibit-password/PermitRootLogin yes/'</span> /etc/ssh/sshd_config</span><br><span class="line"></span><br><span class="line">RUN mkdir -p /opt</span><br><span class="line">ADD https://fastdl.mongodb.org/linux/mongodb-linux-x86_64-ubuntu1604-3.4.2.tgz /opt/mongodb.tar.gz</span><br><span class="line">RUN <span class="built_in">cd</span> /opt &amp;&amp; tar zxvf mongodb.tar.gz &amp;&amp; rm -rf mongodb.tar.gz</span><br><span class="line">RUN mv /opt/mongodb-linux-x86_64-ubuntu1604-3.4.2 /opt/mongodb</span><br><span class="line"></span><br><span class="line">RUN mkdir -p /data/db</span><br><span class="line"></span><br><span class="line">ENV PATH=/opt/mongodb/bin:<span class="variable">$PATH</span></span><br><span class="line"></span><br><span class="line">COPY supervisord.conf /etc/supervisor/conf.d/supervisord.conf</span><br><span class="line"></span><br><span class="line">EXPOSE 27017 22</span><br><span class="line"></span><br><span class="line"><span class="comment"># 容器启动命令</span></span><br><span class="line">CMD [<span class="string">"supervisord"</span>]</span><br></pre></td></tr></table></figure></p><p><strong> 注 </strong>: 通常直接从官方ADD mongodb链接 <a href="https://fastdl.mongodb.org/linux/mongodb-linux-x86_64-ubuntu1604-3.4.2.tgz" target="_blank" rel="noopener">https://fastdl.mongodb.org/linux/mongodb-linux-x86_64-ubuntu1604-3.4.2.tgz</a>, 速度很慢, 另一种方法是直接先把这个下载地址通过浏览器把mongodb的tar包下载到/home/lihong/docker/mongodb/目录下, 因为ADD在添加tar包到docker里面时会自己帮你解压缩的, 所以上述命令就要做如下替换, 把原先的从http地址下载,<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">RUN mkdir -p /opt</span><br><span class="line">ADD https://fastdl.mongodb.org/linux/mongodb-linux-x86_64-ubuntu1604-3.4.2.tgz /opt/mongodb.tar.gz</span><br><span class="line">RUN <span class="built_in">cd</span> /opt &amp;&amp; tar zxvf mongodb.tar.gz &amp;&amp; rm -rf mongodb.tar.gz</span><br><span class="line">RUN mv /opt/mongodb-linux-x86_64-ubuntu1604-3.4.2 /opt/mongodb</span><br></pre></td></tr></table></figure></p><p>替换为现在直接加载tar的方式, 具体替换为,<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">RUN mkdir -p /opt</span><br><span class="line">ADD https://fastdl.mongodb.org/linux/mongodb-linux-x86_64-ubuntu1604-3.4.2.tgz /opt/</span><br><span class="line">RUN mv /opt/mongodb-linux-x86_64-ubuntu1604-3.4.2 /opt/mongodb</span><br></pre></td></tr></table></figure></p><h2 id="编写Redis-Dockerfile"><a href="#编写Redis-Dockerfile" class="headerlink" title="编写Redis Dockerfile"></a>编写Redis Dockerfile</h2><p>同样<code>Redis Dockerfile</code>也可以基于已经完成的第一部分<code>Dockerfile</code>来写, 首先将<code>/home/lihong/docker</code>下得第一部分<code>Dockerfile</code>拷贝到<code>/home/lihong/docker/redis</code>文件夹下, </p><p><strong> 1 安装 Redis </strong><br>向<code>Dockerfile</code>中写入如下内容,<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">RUN apt-get install redis-server</span><br></pre></td></tr></table></figure></p><p>添加redis和ssh对外的端口号,<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">EXPOSE 6379 22</span><br></pre></td></tr></table></figure></p><p><strong> 2 编写Supervisord配置文件 </strong></p><p>添加<code>Supervisord</code>配置文件来启动<code>redis-server</code>和<code>ssh</code> 创建文件<code>/home/lihong/docker/redis/supervisord.conf</code>, 添加以下内容,<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">[supervisord]</span><br><span class="line">nodaemon=<span class="literal">true</span></span><br><span class="line"></span><br><span class="line">[program:redis]</span><br><span class="line"><span class="built_in">command</span>=/usr/bin/redis-server</span><br><span class="line"></span><br><span class="line">[program:ssh]</span><br><span class="line"><span class="built_in">command</span>=/usr/sbin/sshd -D</span><br></pre></td></tr></table></figure></p><p>向Dockerfile中增加向镜像内拷贝该文件的命令：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">COPY supervisord.conf /etc/supervisor/conf.d/supervisord.conf</span><br></pre></td></tr></table></figure></p><p><strong> 3 完整的 Dockerfile </strong><br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Version 0.1</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 基础镜像</span></span><br><span class="line">FROM nbuntu:latest</span><br><span class="line"></span><br><span class="line"><span class="comment"># 维护者信息</span></span><br><span class="line">MAINTAINER lihong/leehongitrd@163.com </span><br><span class="line"></span><br><span class="line"><span class="comment"># 镜像操作命令</span></span><br><span class="line">RUN apt-get -yqq update &amp;&amp; apt-get install -yqq supervisor redis-server</span><br><span class="line">RUN apt-get install -yqq openssh-server openssh-client</span><br><span class="line"></span><br><span class="line">RUN mkdir /var/run/sshd</span><br><span class="line">RUN <span class="built_in">echo</span> <span class="string">'root:123456'</span> | chpasswd</span><br><span class="line">RUN sed -i <span class="string">'s/PermitRootLogin prohibit-password/PermitRootLogin yes/'</span> /etc/ssh/sshd_config</span><br><span class="line"></span><br><span class="line">COPY supervisord.conf /etc/supervisor/conf.d/supervisord.conf</span><br><span class="line"></span><br><span class="line">EXPOSE 6379 22</span><br><span class="line"></span><br><span class="line"><span class="comment"># 容器启动命令</span></span><br><span class="line">CMD [<span class="string">"supervisord"</span>]</span><br></pre></td></tr></table></figure></p><h2 id="创建镜像"><a href="#创建镜像" class="headerlink" title="创建镜像"></a>创建镜像</h2><p><strong> 1 创建MongoDB镜像 </strong><br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line">lihong@dev:~/docker/mongodb$ docker build -t mongodb:0.1 .</span><br><span class="line">Sending build context to Docker daemon 484.1 MB</span><br><span class="line">Step 1 : FROM nbuntu:latest</span><br><span class="line"> ---&gt; f16a2621960a</span><br><span class="line">Step 2 : MAINTAINER lihong/leehongitrd@163.com</span><br><span class="line"> ---&gt; Using cache</span><br><span class="line"> ---&gt; 834538265a0a</span><br><span class="line">Step 3 : RUN apt-get install -yqq supervisor</span><br><span class="line"> ---&gt; Running <span class="keyword">in</span> e7b54bcbd69f</span><br><span class="line"> ---&gt; 32e2892fba7c</span><br><span class="line">Step 4 : RUN apt-get install -yqq openssh-server openssh-client</span><br><span class="line"> ---&gt; Running <span class="keyword">in</span> 00102fd9088f</span><br><span class="line"> ---&gt; 5ce7cbf2a50e</span><br><span class="line">Step 5 : RUN mkdir /var/run/sshd</span><br><span class="line"> ---&gt; Running <span class="keyword">in</span> bb408fb2b0ba</span><br><span class="line"> ---&gt; bc1305d8403f</span><br><span class="line">Removing intermediate container bb408fb2b0ba</span><br><span class="line">Step 6 : RUN <span class="built_in">echo</span> <span class="string">'root:123456'</span> | chpasswd</span><br><span class="line"> ---&gt; Running <span class="keyword">in</span> 002fa189da1b</span><br><span class="line"> ---&gt; 2948cab7667d</span><br><span class="line">Removing intermediate container 002fa189da1b</span><br><span class="line">Step 7 : RUN sed -i <span class="string">'s/PermitRootLogin prohibit-password/PermitRootLogin yes/'</span> /etc/ssh/sshd_config</span><br><span class="line"> ---&gt; Running <span class="keyword">in</span> b6bb01e8363c</span><br><span class="line"> ---&gt; 12e5f0b915f6</span><br><span class="line">Removing intermediate container b6bb01e8363c</span><br><span class="line">Step 8 : RUN mkdir -p /opt</span><br><span class="line"> ---&gt; Running <span class="keyword">in</span> 5fceaab69914</span><br><span class="line"> ---&gt; 36e5128476ad</span><br><span class="line">Removing intermediate container 5fceaab69914</span><br><span class="line">Step 9 : ADD mongodb-linux-x86_64-ubuntu1604-3.4.2.tgz /opt/</span><br><span class="line"> ---&gt; 746c06c2955a</span><br><span class="line">Removing intermediate container 1ad6994dffbf</span><br><span class="line">Step 10 : RUN mv /opt/mongodb-linux-x86_64-ubuntu1604-3.4.2 /opt/mongodb</span><br><span class="line"> ---&gt; Running <span class="keyword">in</span> 8aee03f3ff1f</span><br><span class="line"> ---&gt; bb59a44e388e</span><br><span class="line">Removing intermediate container 8aee03f3ff1f</span><br><span class="line">Step 11 : RUN mkdir -p /data/db</span><br><span class="line"> ---&gt; Running <span class="keyword">in</span> d824290aeeda</span><br><span class="line"> ---&gt; 524ea3b42ee7</span><br><span class="line">Removing intermediate container d824290aeeda</span><br><span class="line">Step 12 : ENV PATH /opt/mongodb/bin:<span class="variable">$PATH</span></span><br><span class="line"> ---&gt; Running <span class="keyword">in</span> 528b7eb1ebd2</span><br><span class="line"> ---&gt; 4f20f47cb729</span><br><span class="line">Removing intermediate container 528b7eb1ebd2</span><br><span class="line">Step 13 : COPY supervisord.conf /etc/supervisor/conf.d/supervisord.conf</span><br><span class="line"> ---&gt; 81b25cae6dfb</span><br><span class="line">Removing intermediate container 2925012500cb</span><br><span class="line">Step 14 : EXPOSE 27017 22</span><br><span class="line"> ---&gt; Running <span class="keyword">in</span> e6b39c60ba24</span><br><span class="line"> ---&gt; 357fcd3fce1b</span><br><span class="line">Removing intermediate container e6b39c60ba24</span><br><span class="line">Step 15 : CMD supervisord</span><br><span class="line"> ---&gt; Running <span class="keyword">in</span> 750793c619bf</span><br><span class="line"> ---&gt; 73fc5cf01a32</span><br><span class="line">Removing intermediate container 750793c619bf</span><br><span class="line">Successfully built 73fc5cf01a32</span><br><span class="line">lihong@dev:~/docker/mongodb$ docker images</span><br><span class="line">REPOSITORY          TAG                 IMAGE ID            CREATED             SIZE</span><br><span class="line">mongodb             0.1                 73fc5cf01a32        6 seconds ago       824.1 MB</span><br><span class="line">redis               0.1                 e4bd400dd3fd        12 hours ago        258.9 MB</span><br><span class="line">nbuntu              latest              f16a2621960a        21 hours ago        174.2 MB</span><br><span class="line">redis               latest              e4a35914679d        8 days ago          182.9 MB</span><br><span class="line">ubuntu              latest              0ef2e08ed3fa        9 days ago          130 MB</span><br><span class="line">lihong@dev:~/docker/mongodb$</span><br></pre></td></tr></table></figure></p><p>可以看到新镜像mongodb:0.1已经创建好了, 下面通过mongodb:0.1镜像创建一个新容器mongodb_demo,<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">lihong@dev:~/docker/mongodb$ docker run -P -d --name mongodb_demo mongodb:0.1</span><br><span class="line">7a80d0577f98c9071aaf7c491968bf66a6dc68e6d818c8563ee0b3a08cb25a31</span><br><span class="line">lihong@dev:~/docker/mongodb$ docker ps</span><br><span class="line">CONTAINER ID        IMAGE               COMMAND             CREATED             STATUS              PORTS                                             NAMES</span><br><span class="line">7a80d0577f98        mongodb:0.1         <span class="string">"supervisord"</span>       7 seconds ago       Up 4 seconds        0.0.0.0:32775-&gt;22/tcp, 0.0.0.0:32774-&gt;27017/tcp   mongodb_demo</span><br></pre></td></tr></table></figure></p><p>上述<code>docker ps</code>命令的输出可以看到<code>MongoDB</code>的端口号已经被自动映射到了本地的<code>32774</code>端口，下面对<code>MongoDB</code>是否启动进行测试,<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">lihong@dev:~/docker/mongodb$ docker ps</span><br><span class="line">CONTAINER ID        IMAGE               COMMAND             CREATED             STATUS              PORTS                                             NAMES</span><br><span class="line">7a80d0577f98        mongodb:0.1         <span class="string">"supervisord"</span>       4 minutes ago       Up 4 minutes        0.0.0.0:32775-&gt;22/tcp, 0.0.0.0:32774-&gt;27017/tcp   mongodb_demo</span><br><span class="line">cc8b65b87a75        redis:0.1           <span class="string">"supervisord"</span>       12 hours ago        Up 12 hours         0.0.0.0:32773-&gt;22/tcp, 0.0.0.0:32772-&gt;6379/tcp    redis_demo</span><br><span class="line">lihong@dev:~/docker/mongodb$ mongo --host 127.0.0.1 --port 32774</span><br><span class="line">MongoDB shell version: 2.6.10</span><br><span class="line">connecting to: 127.0.0.1:32774/<span class="built_in">test</span></span><br><span class="line">Welcome to the MongoDB shell.</span><br><span class="line">For interactive <span class="built_in">help</span>, <span class="built_in">type</span> <span class="string">"help"</span>.</span><br><span class="line">For more comprehensive documentation, see</span><br><span class="line">       http://docs.mongodb.org/</span><br><span class="line">Questions? Try the support group</span><br><span class="line">       http://groups.google.com/group/mongodb-user</span><br><span class="line">Server has startup warnings:</span><br><span class="line">2017-03-09T03:59:06.614+0000 I CONTROL  [initandlisten]</span><br><span class="line">2017-03-09T03:59:06.614+0000 I CONTROL  [initandlisten] ** WARNING: Access control is not enabled <span class="keyword">for</span> the database.</span><br><span class="line">2017-03-09T03:59:06.615+0000 I CONTROL  [initandlisten] **          Read and write access to data and configuration is unrestricted.</span><br><span class="line">2017-03-09T03:59:06.615+0000 I CONTROL  [initandlisten] ** WARNING: You are running this process as the root user, <span class="built_in">which</span> is not recommended.</span><br><span class="line">2017-03-09T03:59:06.615+0000 I CONTROL  [initandlisten]</span><br><span class="line">2017-03-09T03:59:06.663+0000 I CONTROL  [initandlisten]</span><br><span class="line">2017-03-09T03:59:06.664+0000 I CONTROL  [initandlisten] ** WARNING: /sys/kernel/mm/transparent_hugepage/enabled is <span class="string">'always'</span>.</span><br><span class="line">2017-03-09T03:59:06.664+0000 I CONTROL  [initandlisten] **        We suggest setting it to <span class="string">'never'</span></span><br><span class="line">2017-03-09T03:59:06.664+0000 I CONTROL  [initandlisten]</span><br><span class="line">&gt; show dbs;</span><br><span class="line">admin  0.000GB</span><br><span class="line"><span class="built_in">local</span>  0.000GB</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></p><p>可以看到mongodb服务可用,<br><strong> 2 创建Redis镜像 </strong><br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">lihong@dev:~/docker/redis$ docker build -t redis:0.1 .</span><br><span class="line">Sending build context to Docker daemon 3.072 kB</span><br><span class="line">Step 1 : FROM nbuntu:latest</span><br><span class="line"> ---&gt; f16a2621960a</span><br><span class="line">Step 2 : MAINTAINER lihong/leehongitrd@163.com</span><br><span class="line"> ---&gt; Running <span class="keyword">in</span> 92081132374d</span><br><span class="line"> ---&gt; a33c13bf12cb</span><br><span class="line">Removing intermediate container 92081132374d</span><br><span class="line">Step 3 : RUN apt-get install -yqq supervisor redis-server</span><br><span class="line"> ---&gt; bdc6e761ea22</span><br><span class="line">Removing intermediate container c77d8bfd1c78</span><br><span class="line">Step 4 : RUN apt-get install -yqq openssh-server openssh-client</span><br><span class="line"> ---&gt; Running <span class="keyword">in</span> 970a77bef632</span><br><span class="line">Step 5 : RUN mkdir /var/run/sshd</span><br><span class="line"> ---&gt; Running <span class="keyword">in</span> e68f56b9eba0</span><br><span class="line"> ---&gt; 707b8b2bd7bc</span><br><span class="line">Removing intermediate container e68f56b9eba0</span><br><span class="line">Step 6 : RUN <span class="built_in">echo</span> <span class="string">'root:123456'</span> | chpasswd</span><br><span class="line"> ---&gt; Running <span class="keyword">in</span> e3c6f371c513</span><br><span class="line"> ---&gt; fc81cd175615</span><br><span class="line">Removing intermediate container e3c6f371c513</span><br><span class="line">Step 7 : RUN sed -i <span class="string">'s/PermitRootLogin prohibit-password/PermitRootLogin yes/'</span> /etc/ssh/sshd_config</span><br><span class="line"> ---&gt; Running <span class="keyword">in</span> c5a0a941b971</span><br><span class="line"> ---&gt; 2bef0836db0d</span><br><span class="line">Removing intermediate container c5a0a941b971</span><br><span class="line">Step 8 : COPY supervisord.conf /etc/supervisor/conf.d/supervisord.conf</span><br><span class="line"> ---&gt; 3e2692da94bc</span><br><span class="line">Removing intermediate container cf851760235f</span><br><span class="line">Step 9 : EXPOSE 6379 22</span><br><span class="line"> ---&gt; Running <span class="keyword">in</span> 84e24be61ab6</span><br><span class="line"> ---&gt; 9ed91e3e5d23</span><br><span class="line">Removing intermediate container 84e24be61ab6</span><br><span class="line">Step 10 : CMD supervisord</span><br><span class="line"> ---&gt; Running <span class="keyword">in</span> 3352a31501ce</span><br><span class="line"> ---&gt; d59c4c42bc34</span><br><span class="line">Removing intermediate container 3352a31501ce</span><br><span class="line">Successfully built d59c4c42bc34</span><br><span class="line">lihong@dev:~/docker/redis$ docker images</span><br><span class="line">REPOSITORY          TAG                 IMAGE ID            CREATED              SIZE</span><br><span class="line">redis               0.1                 d59c4c42bc34        About a minute ago   261.1 MB</span><br><span class="line">nbuntu              latest              f16a2621960a        8 hours ago          174.2 MB</span><br><span class="line">redis               latest              e4a35914679d        7 days ago           182.9 MB</span><br><span class="line">ubuntu              latest              0ef2e08ed3fa        8 days ago           130 MB</span><br><span class="line">lihong@dev:~/docker/redis$</span><br></pre></td></tr></table></figure></p><p>为检查新镜像redis:0.1能否提供redis服务, 下面基于新镜像redis:0.1创建新容器redis_demo,<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">lihong@dev:~/docker/redis$ docker run -P -d --name redis_demo redis:0.1</span><br><span class="line">cc8b65b87a75b02fef26dd4735841503ccea9db414cd88675d38b5359785d570</span><br></pre></td></tr></table></figure></p><p>通过<code>docker ps</code>命令可以看到<code>redis</code>的端口号已经被自动映射到了本地的<code>32770</code>端口，SSH服务的端口号也映射到了<code>32771</code> 端口。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">lihong@dev:~/docker/redis$ docker ps</span><br><span class="line">CONTAINER ID        IMAGE               COMMAND             CREATED             STATUS              PORTS                                            NAMES</span><br><span class="line">cc8b65b87a75        redis:0.1           <span class="string">"supervisord"</span>       6 seconds ago       Up 5 seconds        0.0.0.0:32773-&gt;22/tcp, 0.0.0.0:32772-&gt;6379/tcp   redis_demo</span><br></pre></td></tr></table></figure></p><p>通过ssh连接到redis_demo容器, 看到redis服务是可用的,<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">lihong@dev:~/docker/redis$ ssh root@127.0.0.1 -p 32773</span><br><span class="line">root@127.0.0.1<span class="string">'s password:</span></span><br><span class="line"><span class="string">Welcome to Ubuntu 16.04.2 LTS (GNU/Linux 4.8.0-41-generic x86_64)</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string"> * Documentation:  https://help.ubuntu.com</span></span><br><span class="line"><span class="string"> * Management:     https://landscape.canonical.com</span></span><br><span class="line"><span class="string"> * Support:        https://ubuntu.com/advantage</span></span><br><span class="line"><span class="string">Last login: Wed Mar  8 16:01:01 2017 from 172.17.0.1</span></span><br><span class="line"><span class="string">root@cc8b65b87a75:~# redis-cli</span></span><br><span class="line"><span class="string">127.0.0.1:6379&gt; get name</span></span><br><span class="line"><span class="string">(nil)</span></span><br><span class="line"><span class="string">127.0.0.1:6379&gt; set name mike</span></span><br><span class="line"><span class="string">OK</span></span><br><span class="line"><span class="string">127.0.0.1:6379&gt; get name</span></span><br><span class="line"><span class="string">"mike"</span></span><br><span class="line"><span class="string">127.0.0.1:6379&gt;</span></span><br><span class="line"><span class="string">root@cc8b65b87a75:~# exit</span></span><br><span class="line"><span class="string">logout</span></span><br><span class="line"><span class="string">Connection to 127.0.0.1 closed.</span></span><br><span class="line"><span class="string">lihong@dev:~/docker/redis$ redis-cli -h 127.0.0.1 -p 32772</span></span><br><span class="line"><span class="string">127.0.0.1:32772&gt; get name</span></span><br><span class="line"><span class="string">"mike"</span></span><br><span class="line"><span class="string">127.0.0.1:32772&gt;</span></span><br></pre></td></tr></table></figure></p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ul><li>通过在Docker上创建MongoDB和Redis应用, 进一步熟悉了Dockerfile的编写规则;</li><li>在新构建的镜像上创建容器, 并通过测试确认容器能提供MongoDB和Redis服务, 进一步熟悉容器的使用;</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;上篇文件总结了如何编写&lt;code&gt;Dockerfile&lt;/code&gt;及如何通过&lt;code&gt;Dockerfile&lt;/code&gt;构建镜像并运行相应的应用需求, 本文将通过编写&lt;code&gt;Dockerfile&lt;/code&gt;来创建MongoDB和Redis应用进一步学习实践&lt;code&gt;Docker&lt;/code&gt;的运行机制。&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="docker-practice" scheme="http://researchlab.github.io/categories/docker-practice/"/>
    
    
      <category term="docker" scheme="http://researchlab.github.io/tags/docker/"/>
    
  </entry>
  
  <entry>
    <title>docker实践--05 编写Dockerfile</title>
    <link href="http://researchlab.github.io/2017/03/07/docker-dockerfile/"/>
    <id>http://researchlab.github.io/2017/03/07/docker-dockerfile/</id>
    <published>2017-03-07T16:03:35.000Z</published>
    <updated>2018-10-18T05:08:14.826Z</updated>
    
    <content type="html"><![CDATA[<p>docker容器是在指定的镜像上运行的, 创建docker镜像的方法也有很多中比如直接到<code>docker Hub</code>上通过<code>docker pull</code>创建一个镜像, 也可以通过修改其它镜像然后提交修改<code>docker commit</code> 来创建新的镜像, 还有如导入某个现有的镜像, 但是在实际中难觅要定制化改进出符合特定场景的镜像, 虽然用上述方式也是可以创建新的镜像的, 但是缺点也很多, 主要缺点是不便于维护, 其实创建docker 镜像还有一种最好的办法就是手工打造<code>Dockerfile</code>, 然后通过<code>docker build</code>编译生成新的镜像, 下面本文就来实践怎么编写符合规范的Dockerfile, 然后又是怎么样通过Dockerfile来创建合适的镜像的。</p><a id="more"></a><p><strong> 需求 </strong><br>需求是完成一个<code>Dockerfile</code>, 通过该<code>Dockerfile</code>创建一个Web应用, 该web应用为apache托管的一个静态页面网站, 换句话说, 我们写一个<code>Dockerfile</code>, 用来创建一个实验楼公司的网站应用, 就是 <a href="http://www.simplecloud.cn" target="_blank" rel="noopener">http://www.simplecloud.cn</a> 这个站点。这个站点是纯静态的页面, 我们也可以直接下载得到。<br>从实现这个需求中去实践和学习关于<code>Dockerfile</code>如下三方面的内容,</p><ul><li>了解Dockerfile 基本框架</li><li>学习Dockerfile 编写常用命令</li><li>通过Dockerfile 构建镜像</li></ul><h2 id="Dockerfile基本框架"><a href="#Dockerfile基本框架" class="headerlink" title="Dockerfile基本框架"></a>Dockerfile基本框架</h2><p>一份Dockerfile一般包含下面几个部分,</p><ul><li><code>基础镜像</code>：以哪个镜像作为基础进行制作，用法是<code>FROM 基础镜像名称</code></li><li><code>维护者信息</code>：需要写下该Dockerfile编写人的姓名或邮箱，用法是<code>MANITAINER 名字/邮箱</code></li><li><code>镜像操作命令</code>：对基础镜像要进行的改造命令，比如安装新的软件，进行哪些特殊配置等，常见的是<code>RUN</code>命令</li><li><code>容器启动命令</code>：当基于该镜像的容器启动时需要执行哪些命令，常见的是<code>CMD</code>命令或<code>ENTRYPOINT</code></li></ul><p>下面创建一份Dockerfile 输入如下内容,<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Version 0.1</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 基础镜像</span></span><br><span class="line">FROM nbuntu:latest</span><br><span class="line"></span><br><span class="line"><span class="comment"># 维护者信息</span></span><br><span class="line">MAINTAINER lihong/leehongitrd@163.com </span><br><span class="line"></span><br><span class="line"><span class="comment"># 镜像操作命令</span></span><br><span class="line">RUN apt-get -yqq update &amp;&amp; apt-get install -yqq apache2 &amp;&amp; apt-get clean</span><br><span class="line"></span><br><span class="line"><span class="comment"># 容器启动命令</span></span><br><span class="line">CMD [<span class="string">"/usr/sbin/apache2ctl"</span>, <span class="string">"-D"</span>, <span class="string">"FOREGROUND"</span>]</span><br></pre></td></tr></table></figure></p><blockquote><p>因为直接FROM ubuntu:latest 创建的镜像, 然后基于这个镜像运行的容器中是没有<code>ifconfig, ping</code>等命令的， 所以为了本次试验自己就新建了一个镜像nbuntu, 这个镜像就包含了<code>ifconfig, ping</code>等命令</p></blockquote><p>上面的<code>Dockerfile</code>就做了一件事，即创建一个apache的镜像,</p><ul><li><code>FROM</code>指定基础镜像，如果镜像名称中没有制定<code>TAG</code>, 默认为<code>latest</code>。</li><li><code>RUN</code>命令默认使用/bin/sh Shell执行，默认为root权限。如果命令过长需要换行，需要在行末尾加<code>\\</code>。</li><li><code>CMD</code> 命令也是默认在/bin/sh Shell中执行，并且默认只能有一条，如果是多条CMD命令则只有最后一条执行。用户也可以在docker run命令创建容器时指定新的CMD命令来覆盖Dockerfile里的CMD。</li></ul><p>用<code>docker build</code>将上述<code>Dockerfile</code>构建名为<code>test:0.1</code>的新镜像,<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line">lihong@dev:~/docker$ docker build -t <span class="built_in">test</span>:0.1 .</span><br><span class="line">Sending build context to Docker daemon 2.048 kB</span><br><span class="line">Step 1 : FROM nbuntu:latest</span><br><span class="line"> ---&gt; f16a2621960a</span><br><span class="line">Step 2 : MAINTAINER lihong/leehongitrd@163.com</span><br><span class="line"> ---&gt; Running <span class="keyword">in</span> 668004fe61bd</span><br><span class="line"> ---&gt; cb74681dcdc9</span><br><span class="line">Removing intermediate container 668004fe61bd</span><br><span class="line">Step 3 : RUN apt -yqq update &amp;&amp; apt install -yqq apache2 &amp;&amp; apt clean</span><br><span class="line"> ---&gt; Running <span class="keyword">in</span> 00968a59fa09</span><br><span class="line"></span><br><span class="line">The following additional packages will be installed:</span><br><span class="line">  apache2-bin apache2-data apache2-utils file ifupdown iproute2</span><br><span class="line">  isc-dhcp-client isc-dhcp-common libapr1 libaprutil1 libaprutil1-dbd-sqlite3</span><br><span class="line">  libaprutil1-ldap libasn1-8-heimdal libatm1 libdns-export162 libexpat1</span><br><span class="line">  libgdbm3 libgssapi3-heimdal libhcrypto4-heimdal libheimbase1-heimdal</span><br><span class="line">  libheimntlm0-heimdal libhx509-5-heimdal libicu55 libisc-export160</span><br><span class="line">  libkrb5-26-heimdal libldap-2.4-2 liblua5.1-0 libmagic1 libmnl0 libperl5.22</span><br><span class="line">  libroken18-heimdal libsasl2-2 libsasl2-modules libsasl2-modules-db</span><br><span class="line">  libsqlite3-0 libssl1.0.0 libwind0-heimdal libxml2 libxtables11 mime-support</span><br><span class="line">  netbase openssl perl perl-modules-5.22 rename sgml-base ssl-cert xml-core</span><br><span class="line">Suggested packages:</span><br><span class="line">  www-browser apache2-doc apache2-suexec-pristine | apache2-suexec-custom ufw</span><br><span class="line">  ppp rdnssd iproute2-doc resolvconf avahi-autoipd isc-dhcp-client-ddns</span><br><span class="line">  apparmor libsasl2-modules-otp libsasl2-modules-ldap libsasl2-modules-sql</span><br><span class="line">  libsasl2-modules-gssapi-mit | libsasl2-modules-gssapi-heimdal</span><br><span class="line">  ca-certificates perl-doc libterm-readline-gnu-perl</span><br><span class="line">  | libterm-readline-perl-perl make sgml-base-doc openssl-blacklist debhelper</span><br><span class="line">The following NEW packages will be installed:</span><br><span class="line">  apache2 apache2-bin apache2-data apache2-utils file ifupdown iproute2</span><br><span class="line">  isc-dhcp-client isc-dhcp-common libapr1 libaprutil1 libaprutil1-dbd-sqlite3</span><br><span class="line">  libaprutil1-ldap libasn1-8-heimdal libatm1 libdns-export162 libexpat1</span><br><span class="line">  libgdbm3 libgssapi3-heimdal libhcrypto4-heimdal libheimbase1-heimdal</span><br><span class="line">  libheimntlm0-heimdal libhx509-5-heimdal libicu55 libisc-export160</span><br><span class="line">  libkrb5-26-heimdal libldap-2.4-2 liblua5.1-0 libmagic1 libmnl0 libperl5.22</span><br><span class="line">  libroken18-heimdal libsasl2-2 libsasl2-modules libsasl2-modules-db</span><br><span class="line">  libsqlite3-0 libssl1.0.0 libwind0-heimdal libxml2 libxtables11 mime-support</span><br><span class="line">  netbase openssl perl perl-modules-5.22 rename sgml-base ssl-cert xml-core</span><br><span class="line">debconf: delaying package configuration, since apt-utils is not installed</span><br><span class="line">0 upgraded, 49 newly installed, 0 to remove and 0 not upgraded.</span><br><span class="line">Need to get 21.4 MB of archives.</span><br><span class="line">After this operation, 98.3 MB of additional disk space will be used.</span><br><span class="line">Step 4 : CMD /usr/sbin/apache2ctl -D FOREGROUND</span><br><span class="line"> ---&gt; Running <span class="keyword">in</span> f954154994b2</span><br><span class="line"> ---&gt; 4abe06cc549a</span><br><span class="line">Removing intermediate container f954154994b2</span><br><span class="line">Successfully built 4abe06cc549a</span><br></pre></td></tr></table></figure></p><p>查看新创建的镜像test:0.1,<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">lihong@dev:~/docker$ docker images</span><br><span class="line">REPOSITORY          TAG                 IMAGE ID            CREATED             SIZE</span><br><span class="line"><span class="built_in">test</span>                0.1                 4abe06cc549a        24 seconds ago      274.1 MB</span><br><span class="line">nbuntu              latest              f16a2621960a        4 hours ago         174.2 MB</span><br><span class="line">redis               latest              e4a35914679d        7 days ago          182.9 MB</span><br><span class="line">ubuntu              latest              0ef2e08ed3fa        8 days ago          130 MB</span><br></pre></td></tr></table></figure></p><p>使用该镜像创建容器web1, 将容器中的端口80映射到本地80端口,<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">lihong@dev:~/docker$ docker run -d -p 80:80 --name web1 <span class="built_in">test</span>:0.1</span><br><span class="line">27479a43f119d213509c9af6cdfcd43330f55ed0c4fbeb08fbc3dd434744f36e</span><br></pre></td></tr></table></figure></p><p>通过firefox浏览器打开localhost进行测试，apache已运行,</p><center><img src="/2017/03/07/docker-dockerfile/apache.png" alt="apache"></center><h2 id="编写Dockerfile常用命令"><a href="#编写Dockerfile常用命令" class="headerlink" title="编写Dockerfile常用命令"></a>编写Dockerfile常用命令</h2><p>如果构建镜像需求变更, 则只需将其增加到Dockerfile中即可。</p><p><strong> 1 指定容器运行的用户 </strong></p><p> 在一些需要指定用户来运行的应用部署时非常关键，比如提供hadoop服务的容器通常会使用hadoop用户来启动服务。该用户将作为后续的RUN命令执行的用户; 例如使用mike用户来执行后续命令, 将下面的命令添加Dockerfile中， 放置到要执行的命令之前即可，<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">USER mike</span><br></pre></td></tr></table></figure></p><p><strong> 2 指定后续命令的执行目录 </strong></p><p>假如后继需要运行的是一个静态网站，将启动后的工作目录切换到/var/www/html目录, 则,<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">WORKDIR /var/www/html</span><br></pre></td></tr></table></figure></p><p><strong> 3 对外连接端口号 </strong><br>由于内部服务会启动Web服务，我们需要把对应的80端口暴露出来，可以提供给容器间互联使用，可以使用<code>EXPOSE</code>命令。<br>在镜像操作部分增加下面一句,<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">EXPOSE 80</span><br></pre></td></tr></table></figure></p><p><strong> 4 设置容器主机名 </strong></p><p><code>ENV</code>命令能够对容器内的环境变量进行设置, 使用该命令设置由该镜像创建的容器的主机名为dev, 向Dockerfile中增加下面一句,<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ENV HOSTNAME dev</span><br></pre></td></tr></table></figure></p><p><strong> 5 向镜像中增加文件 </strong></p><p>向镜像中添加文件有两种命令:<code>COPY</code> 和<code>ADD</code>。</p><p><code>COPY</code>命令可以复制本地文件夹到镜像中,<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">COPY website /var/www/html</span><br></pre></td></tr></table></figure></p><p><code>ADD</code>命令支持添加本地的<code>tar压缩包</code>到容器中指定目录, 压缩包会被自动解压为目录, 也可以自动下载URL并拷贝到镜像, 例如,<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ADD html.tar /var/www</span><br><span class="line">ADD http://www.shiyanlou.com/html.tar /var/www</span><br></pre></td></tr></table></figure></p><p>根据需求, 需要的一个网站放到镜像里, 需要把一个tar包添加到apache的/var/www目录下, 因此选择使用<code>ADD</code>命令,<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ADD html.tar /var/www</span><br></pre></td></tr></table></figure></p><p><strong> 6 CMD与ENTRYPOINT </strong></p><p><code>ENTRYPOINT</code>容器启动后执行的命令, 让容器执行表现的像一个可执行程序一样, 与<code>CMD</code>的区别是不可以被<code>docker run</code>覆盖，会把<code>docker run</code>后面的参数当作传递给<code>ENTRYPOINT</code>指令的参数。<code>Dockerfile</code>中只能指定一个<code>ENTRYPOINT</code>, 如果指定了很多, 只有最后一个有效。<code>docker run命令</code>的<code>-entrypoint</code>参数可以把指定的参数继续传递给<code>ENTRYPOINT</code>。</p><p><strong> 7 挂载数据卷 </strong></p><p>将<code>apache</code>访问的日志数据存储到宿主机可以访问的数据卷中,<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">VOLUME [<span class="string">"/var/log/apache2"</span>]</span><br></pre></td></tr></table></figure></p><p><strong> 8 设置容器内的环境变量 </strong></p><p>如在本需求中使用<code>ENV</code>设置一些<code>apache</code>启动的环境变量,<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">ENV APACHE_RUN_USER www-data</span><br><span class="line">ENV APACHE_RUN_GROUP www-data</span><br><span class="line">ENV APACHE_LOG_DIR /var/<span class="built_in">log</span>/apche2</span><br><span class="line">ENV APACHE_PID_FILE /var/run/apache2.pid</span><br><span class="line">ENV APACHE_RUN_DIR /var/run/apache2</span><br><span class="line">ENV APACHE_LOCK_DIR /var/lock/apche2</span><br></pre></td></tr></table></figure></p><p><strong> 9 使用 Supervisord </strong></p><p><code>CMD</code>只有一个命令, 当需要运行多个服务怎么办呢？最好的办法是分别在不同的容器中运行，通过<code>--link</code>进行连接，比如先前实验中用到的web, app, db容器。如果一定要在一个容器中运行多个服务可以考虑用<code>Supervisord</code>来进行进程管理，方式就是将多个启动命令放入到一个启动脚本中。</p><p>首先安装<code>Supervisord</code>, 添加下面内容到<code>Dockerfile</code>,<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">RUN apt-get install -yqq supervisor</span><br><span class="line">RUN mkdir -p /var/<span class="built_in">log</span>/supervisor</span><br></pre></td></tr></table></figure></p><p>拷贝配置文件到指定的目录,<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">COPY supervisord.conf /etc/supervisor/conf.d/supervisord.conf</span><br></pre></td></tr></table></figure></p><p>其中<code>supervisord.conf</code>文件需要放在/home/lihong/docker文件夹下，文件内容如下,<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[supervisord]</span><br><span class="line">nodaemon=<span class="literal">true</span></span><br><span class="line"></span><br><span class="line">[program:apache2]</span><br><span class="line"><span class="built_in">command</span>=/bin/bash -c <span class="string">"source /etc/apache2/envvars &amp;&amp; exec /usr/sbin/apache2ctl -D FOREGROUND"</span></span><br></pre></td></tr></table></figure></p><p>如果有多个服务需要启动可以在文件后继续添加<code>[program:xxx]</code>, 比如如果有ssh服务，可以增加<code>[program:ssh]</code>。</p><p>修改<code>CMD</code>命令，启动<code>Supervisord</code>,<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">CMD [<span class="string">"/usr/bin/supervisord"</span>]</span><br></pre></td></tr></table></figure></p><h2 id="通过Dockerfile-创建镜像"><a href="#通过Dockerfile-创建镜像" class="headerlink" title="通过Dockerfile 创建镜像"></a>通过Dockerfile 创建镜像</h2><p>将上述内容完成后放入到<code>/home/lihong/docker/Dockerfile</code>文件中，最终得到的<code>Dockerfile</code>文件如下,<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Version 0.2</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 基础镜像</span></span><br><span class="line">FROM nbuntu:latest</span><br><span class="line"></span><br><span class="line"><span class="comment"># 维护者信息</span></span><br><span class="line">MAINTAINER lihong/leehongitrd@163.com </span><br><span class="line"></span><br><span class="line"><span class="comment"># 镜像操作命令</span></span><br><span class="line">RUN apt -yqq update &amp;&amp; apt install -yqq apache2 &amp;&amp; apt clean</span><br><span class="line">RUN apt install -yqq supervisor</span><br><span class="line">RUN mkdir -p /var/<span class="built_in">log</span>/supervisor</span><br><span class="line"></span><br><span class="line">VOLUME [<span class="string">"/var/log/apche2"</span>]</span><br><span class="line"></span><br><span class="line">ADD html.tar /var/www</span><br><span class="line">COPY supervisord.conf /etc/supervisor/conf.d/supervisord.conf</span><br><span class="line"></span><br><span class="line">WORKDIR /var/www/html</span><br><span class="line"></span><br><span class="line">ENV HOSTNAME dev </span><br><span class="line">ENV APACHE_RUN_USER www-data</span><br><span class="line">ENV APACHE_RUN_GROUP www-data</span><br><span class="line">ENV APACHE_LOG_DIR /var/<span class="built_in">log</span>/apche2</span><br><span class="line">ENV APACHE_PID_FILE /var/run/apache2.pid</span><br><span class="line">ENV APACHE_RUN_DIR /var/run/apache2</span><br><span class="line">ENV APACHE_LOCK_DIR /var/lock/apche2</span><br><span class="line"></span><br><span class="line">EXPOSE 80</span><br><span class="line"></span><br><span class="line"><span class="comment"># 容器启动命令</span></span><br><span class="line">CMD [<span class="string">"/usr/bin/supervisord"</span>]</span><br></pre></td></tr></table></figure></p><p>同时在/home/lihong/docker目录下，添加<code>supervisord.conf</code>文件,<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[supervisord]</span><br><span class="line">nodaemon=<span class="literal">true</span></span><br><span class="line"></span><br><span class="line">[program:apache2]</span><br><span class="line"><span class="built_in">command</span>=/bin/bash -c <span class="string">"source /etc/apache2/envvars &amp;&amp; exec /usr/sbin/apache2ctl -D FOREGROUND"</span></span><br></pre></td></tr></table></figure></p><p>并下载静态页面文件压缩包,<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> /home/lihong/docker</span><br><span class="line">wget http://labfile.oss.aliyuncs.com/courses/498/html.tar</span><br></pre></td></tr></table></figure></p><p>将<a href="http://simplecloud.cn" target="_blank" rel="noopener">http://simplecloud.cn</a> 网站的页面tar包下载下来， 放到和Dockerfile文件同一个文件夹中。 然后通过<code>docker build</code>创建镜像, <code>-t</code>参数指定镜像名称,<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">lihong@dev:~/docker$ docker build -t <span class="built_in">test</span>:0.2 .</span><br><span class="line">Sending build context to Docker daemon 7.708 MB</span><br><span class="line">Step 1 : FROM nbuntu:latest</span><br><span class="line"> ---&gt; f16a2621960a</span><br><span class="line">Step 2 : MAINTAINER lihong/leehongitrd@163.com</span><br><span class="line"> ---&gt; Using cache</span><br><span class="line"> ---&gt; cb74681dcdc9</span><br><span class="line">Step 3 : RUN apt -yqq update &amp;&amp; apt install -yqq apache2 &amp;&amp; apt clean</span><br><span class="line"> ---&gt; Using cache</span><br><span class="line"> ---&gt; a7b7dce4c67c</span><br><span class="line">Step 4 : RUN apt install -yqq supervisor</span><br><span class="line"> ---&gt; Running <span class="keyword">in</span> 3b86e3c6eec0</span><br><span class="line">...</span><br></pre></td></tr></table></figure></p><p>通过<code>docker images</code>查看到新镜像<code>test:02</code>已经创建好了,<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">hong@dev:~/docker$ docker images</span><br><span class="line">REPOSITORY          TAG                 IMAGE ID            CREATED              SIZE</span><br><span class="line"><span class="built_in">test</span>                0.2                 0886fdb745c8        About a minute ago   308.9 MB</span><br><span class="line"><span class="built_in">test</span>                0.1                 4abe06cc549a        50 minutes ago       274.1 MB</span><br><span class="line">``` </span><br><span class="line"></span><br><span class="line">下面用新镜像`<span class="built_in">test</span>:02`创建新的容器web, 并映射本地的80端口到容器的80端口,</span><br><span class="line">```bash</span><br><span class="line">lihong@dev:~/docker$ docker run -d -p 80:80 --name web <span class="built_in">test</span>:0.2</span><br><span class="line">0221f5e699201a0f2d6757289970752ec696fa8fcb25b91bff7134d78af20a7e</span><br></pre></td></tr></table></figure></p><p>在firefox输入本地地址访问127.0.0.1，看到我们克隆的琛石科技的网站,</p><center><img src="/2017/03/07/docker-dockerfile/simplecloudhp.png" alt="website"></center><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ul><li>通过实际案例了解Dockerfile编写的基本框架</li><li>简要回顾Dockerfile 编写常用命令</li><li>通过Dockerfile 构建镜像, 并测试成功</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;docker容器是在指定的镜像上运行的, 创建docker镜像的方法也有很多中比如直接到&lt;code&gt;docker Hub&lt;/code&gt;上通过&lt;code&gt;docker pull&lt;/code&gt;创建一个镜像, 也可以通过修改其它镜像然后提交修改&lt;code&gt;docker commit&lt;/code&gt; 来创建新的镜像, 还有如导入某个现有的镜像, 但是在实际中难觅要定制化改进出符合特定场景的镜像, 虽然用上述方式也是可以创建新的镜像的, 但是缺点也很多, 主要缺点是不便于维护, 其实创建docker 镜像还有一种最好的办法就是手工打造&lt;code&gt;Dockerfile&lt;/code&gt;, 然后通过&lt;code&gt;docker build&lt;/code&gt;编译生成新的镜像, 下面本文就来实践怎么编写符合规范的Dockerfile, 然后又是怎么样通过Dockerfile来创建合适的镜像的。&lt;/p&gt;
    
    </summary>
    
      <category term="docker-practice" scheme="http://researchlab.github.io/categories/docker-practice/"/>
    
    
      <category term="docker" scheme="http://researchlab.github.io/tags/docker/"/>
    
  </entry>
  
  <entry>
    <title>docker实践--04 网络管理</title>
    <link href="http://researchlab.github.io/2017/03/07/docker-network-mgr/"/>
    <id>http://researchlab.github.io/2017/03/07/docker-network-mgr/</id>
    <published>2017-03-07T12:01:18.000Z</published>
    <updated>2018-10-18T05:08:14.830Z</updated>
    
    <content type="html"><![CDATA[<p>Docker中的网络一直是比较弱的, 本文从基础配置到访问控制再到容器互联等几个方面进行总结, 在较早期的docker版本中只提供最基本的网络通信支持, 如早期版本支持的最常见的三种场景,<br>1.使用NAT方式连接外部网络;<br>2.映射容器和宿主机的端口, 使外部可以访问容器中的应用;<br>3.容器间网络互联.<br><a id="more"></a></p><h2 id="网络基本配置"><a href="#网络基本配置" class="headerlink" title="网络基本配置"></a>网络基本配置</h2><p><strong> 1. 默认情况 </strong></p><p>Docker服务启动时会自动创建一个<code>docker0</code>的虚拟网桥，后续新创建的容器都会有个虚拟接口连接到这个网桥,<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">lihong@dev:~$ ifconfig docker0</span><br><span class="line">docker0   Link encap:Ethernet  HWaddr 02:42:3e:4c:b6:22</span><br><span class="line">          inet addr:172.17.0.1  Bcast:0.0.0.0  Mask:255.255.0.0</span><br><span class="line">          inet6 addr: fe80::42:3eff:fe4c:b622/64 Scope:Link</span><br><span class="line">          UP BROADCAST RUNNING MULTICAST  MTU:1500  Metric:1</span><br><span class="line">          RX packets:8317 errors:0 dropped:0 overruns:0 frame:0</span><br><span class="line">          TX packets:12931 errors:0 dropped:0 overruns:0 carrier:0</span><br><span class="line">          collisions:0 txqueuelen:0</span><br><span class="line">          RX bytes:341661 (341.6 KB)  TX bytes:27114650 (27.1 MB)</span><br></pre></td></tr></table></figure></p><p>Docker网桥会设置为NAT模式, 自动分配一个网段, 从上面看<code>docker0</code>的地址是<code>172.17.0.1</code>, 每个容器都会自动分配的到一个IP地址,<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">lihong@dev:~$ docker attach demo</span><br><span class="line">root@1b9a2f9bfd51:/<span class="comment">#</span></span><br><span class="line">root@1b9a2f9bfd51:/<span class="comment"># ifconfig</span></span><br><span class="line">eth0      Link encap:Ethernet  HWaddr 02:42:ac:11:00:02</span><br><span class="line">          inet addr:172.17.0.2  Bcast:0.0.0.0  Mask:255.255.0.0</span><br><span class="line">          inet6 addr: fe80::42:acff:fe11:2/64 Scope:Link</span><br><span class="line">          UP BROADCAST RUNNING MULTICAST  MTU:1500  Metric:1</span><br><span class="line">          RX packets:20 errors:0 dropped:0 overruns:0 frame:0</span><br><span class="line">          TX packets:7 errors:0 dropped:0 overruns:0 carrier:0</span><br><span class="line">          collisions:0 txqueuelen:0</span><br><span class="line">          RX bytes:2878 (2.8 KB)  TX bytes:578 (578.0 B)</span><br><span class="line"></span><br><span class="line">lo        Link encap:Local Loopback</span><br><span class="line">          inet addr:127.0.0.1  Mask:255.0.0.0</span><br><span class="line">          inet6 addr: ::1/128 Scope:Host</span><br><span class="line">          UP LOOPBACK RUNNING  MTU:65536  Metric:1</span><br><span class="line">          RX packets:0 errors:0 dropped:0 overruns:0 frame:0</span><br><span class="line">          TX packets:0 errors:0 dropped:0 overruns:0 carrier:0</span><br><span class="line">          collisions:0 txqueuelen:1</span><br><span class="line">          RX bytes:0 (0.0 B)  TX bytes:0 (0.0 B)</span><br></pre></td></tr></table></figure></p><p>可以看到创建<code>demo</code>容器的ip地址是<code>172.17.0.2</code>， 可以通过<code>docker inspect</code>命令来详细查看<code>demo</code>容器的各项配置信息, 如查看<code>demo</code>容器的ip地址和网关地址，<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">lihong@dev:~$ docker inspect -f <span class="string">'&#123;&#123;.NetworkSettings.Gateway&#125;&#125;'</span> demo</span><br><span class="line">172.17.0.1</span><br><span class="line">lihong@dev:~$ docker inspect -f <span class="string">'&#123;&#123;.NetworkSettings.IPAddress&#125;&#125;'</span> demo</span><br><span class="line">172.17.0.2</span><br></pre></td></tr></table></figure></p><p>通过上面可知，用户可以为<code>Docker</code>服务指定不同的网桥以及网段，这些配置都可以写在<code>/etc/default/docker</code>文件中, 作为服务启动的参数。</p><p><strong> 2. 配置文件 /etc/default/docker </strong><br><code>/etc/default/docker</code>文件为Ubuntu 16.04.2操作系统中<code>Docker</code>服务启动时使用的配置文件，不同的操作系统位置会有不同。这个文件本身是个 Shell 脚本, 配置文件内容如下,<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">lihong@dev:~$ cat /etc/default/docker</span><br><span class="line"><span class="comment"># Here in Debian, this file is sourced by:</span></span><br><span class="line"><span class="comment">#   - /etc/init.d/docker (sysvinit)</span></span><br><span class="line"><span class="comment">#   - /etc/init/docker (upstart)</span></span><br><span class="line"><span class="comment">#   - systemd's docker.service</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Use of this file for configuring your Docker daemon is discouraged.</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># The recommended alternative is "/etc/docker/daemon.json", as described in:</span></span><br><span class="line"><span class="comment">#   https://docs.docker.com/v1.11/engine/reference/commandline/daemon/#daemon-configuration-file</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># If that does not suit your needs, try a systemd drop-in file, as described in:</span></span><br><span class="line"><span class="comment">#   https://docs.docker.com/v1.11/engine/admin/systemd/#custom-docker-daemon-options</span></span><br></pre></td></tr></table></figure></p><p>可以看到上述说明已经不建议使用<code>/etc/default/docker</code>来配置<code>docker daemon</code>参数了，并且它给出了使用新方法的参考地址，其实就是在命令行中输入参数。记得老版本的<code>docker</code>要对网络进行配置，只需将必要的配置参数填入<code>/etc/default/docker</code>配置文件中的<code>DOCKER_OPTS</code>启动参数行即可。</p><p>下面通过一个栗子展示如何修改docker网络配置, 具体步骤大致如下,</p><ul><li>删除原有的docker0虚拟网络</li><li>创建一个新的虚拟网络newnet0</li><li>配置newnet0的网段为172.17.100.1/22</li><li>配置Docker使用新的虚拟网络newnet0</li></ul><p>首先, 删除docker0, 删除前需要删除所有容器并停止Docker服务,<br>操作命令如下,<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 安装brctl管理工具</span></span><br><span class="line">sudo apt-get install bridge-utils</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看当前虚拟网络列表</span></span><br><span class="line">sudo brctl show</span><br><span class="line"></span><br><span class="line"><span class="comment"># 停止docker服务</span></span><br><span class="line">sudo service docker stop</span><br><span class="line"></span><br><span class="line"><span class="comment"># 停止docker0</span></span><br><span class="line">sudo ip link <span class="built_in">set</span> dev docker0 down</span><br><span class="line"></span><br><span class="line"><span class="comment"># 删除docker0</span></span><br><span class="line">sudo brctl delbr docker0</span><br></pre></td></tr></table></figure></p><p>操作结果如下,<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">lihong@dev:~$ sudo apt install bridge-utils</span><br><span class="line">[sudo] password <span class="keyword">for</span> lihong:</span><br><span class="line">Reading package lists... Done</span><br><span class="line">Building dependency tree</span><br><span class="line">Reading state information... Done</span><br><span class="line">bridge-utils is already the newest version (1.5-9ubuntu1).</span><br><span class="line">bridge-utils <span class="built_in">set</span> to manually installed.</span><br><span class="line">0 upgraded, 0 newly installed, 0 to remove and 61 not upgraded.</span><br><span class="line">lihong@dev:~$ sudo brctl show</span><br><span class="line">bridge name    bridge id      STP enabled    interfaces</span><br><span class="line">docker08000.02423e4cb622      no     veth136401f</span><br><span class="line">lihong@dev:~$ sudo service docker stop</span><br><span class="line">lihong@dev:~$ sudo ip link <span class="built_in">set</span> dev docker0 down</span><br><span class="line">lihong@dev:~$ sudo brctl delbr docker0</span><br><span class="line">lihong@dev:~$ sudo brctl show</span><br><span class="line">bridge name    bridge id      STP enabled    interfaces</span><br><span class="line">lihong@dev:~$</span><br></pre></td></tr></table></figure></p><p>然后, 开始创建一个新的虚拟网络：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">lihong@dev:~$ sudo brctl addbr newnet0</span><br><span class="line">lihong@dev:~$ sudo brctl show</span><br><span class="line">bridge name    bridge id      STP enabled    interfaces</span><br><span class="line">newnet08000.000000000000      no</span><br></pre></td></tr></table></figure></p><p>配置<code>newnet0</code>的网络,<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">lihong@dev:~$ sudo ip addr add 172.17.100.1/22 dev newnet0</span><br><span class="line">lihong@dev:~$ sudo ip addr show newnet0</span><br><span class="line">8: newnet0: &lt;BROADCAST,MULTICAST&gt; mtu 1500 qdisc noop state DOWN group default qlen 1000</span><br><span class="line">    link/ether 8a:38:24:8d:6c:e6 brd ff:ff:ff:ff:ff:ff</span><br><span class="line">    inet 172.17.100.1/22 scope global newnet0</span><br><span class="line">       valid_lft forever preferred_lft forever</span><br><span class="line">lihong@dev:~$ sudo ip link <span class="built_in">set</span> dev newnet0 up</span><br><span class="line">lihong@dev:~$ sudo brctl show newnet0</span><br><span class="line">bridge name    bridge id      STP enabled    interfaces</span><br><span class="line">newnet08000.000000000000      no</span><br><span class="line">lihong@dev:~$</span><br></pre></td></tr></table></figure></p><p>下面就要重启docker daemon 来修改一下配置参数, 如下,<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">lihong@dev:~$ sudo dockerd -b=newnet0 --icc=<span class="literal">false</span> --ip-forward=<span class="literal">true</span></span><br><span class="line">[sudo] password <span class="keyword">for</span> lihong:</span><br><span class="line">INFO[0000] libcontainerd: new containerd process, pid: 25310</span><br><span class="line">INFO[0006] libcontainerd: new containerd process, pid: 25316</span><br><span class="line">WARN[0000] containerd: low RLIMIT_NOFILE changing to max  current=1024 max=65536</span><br><span class="line">INFO[0011] [graphdriver] using prior storage driver <span class="string">"aufs"</span></span><br><span class="line">INFO[0013] Graph migration to content-addressability took 0.00 seconds</span><br><span class="line">WARN[0013] Your kernel does not support swap memory <span class="built_in">limit</span>.</span><br><span class="line">INFO[0013] Loading containers: start.</span><br><span class="line">.INFO[0015] Firewalld running: <span class="literal">false</span></span><br><span class="line"></span><br><span class="line">INFO[0020] Loading containers: <span class="keyword">done</span>.</span><br><span class="line">INFO[0020] Daemon has completed initialization</span><br><span class="line">INFO[0020] Docker daemon                                 commit=78d1802 graphdriver=aufs version=1.12.6</span><br><span class="line">INFO[0021] API listen on /var/run/docker.sock</span><br></pre></td></tr></table></figure></p><p>docker1.12.6版本启动守护进程不再是<code>docker daemon</code>,而是用<code>dockerd</code>的代替了,下面关于上面参数设置说明,<br><code>-b</code> –bridge ：指定连接的网桥<br><code>--icc</code>=true|false：是否允许容器间网络互通<br><code>--ip-forward</code>=true|false：是否允许IP转发，可以对容器的外网访问进行限制</p><p>可以通过创建新的容器来看下修改后的效果,<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line">lihong@dev:~$ docker run -t -i --name container ubuntu /bin/bash</span><br><span class="line">root@47fc5e302c80:/<span class="comment"># ifconfig</span></span><br><span class="line">bash: ifconfig: <span class="built_in">command</span> not found</span><br><span class="line">root@47fc5e302c80:/<span class="comment"># apt update</span></span><br><span class="line">Get:1 http://archive.ubuntu.com/ubuntu xenial InRelease [247 kB]</span><br><span class="line">....</span><br><span class="line">Get:15 http://archive.ubuntu.com/ubuntu xenial-updates/universe amd64 Packages [545 kB]</span><br><span class="line">Fetched 24.9 MB <span class="keyword">in</span> 52s (473 kB/s)</span><br><span class="line">Reading package lists... Done</span><br><span class="line">Building dependency tree</span><br><span class="line">Reading state information... Done</span><br><span class="line">All packages are up to date.</span><br><span class="line">root@47fc5e302c80:/<span class="comment"># apt install net-tools</span></span><br><span class="line">Reading package lists... Done</span><br><span class="line">Building dependency tree</span><br><span class="line">Reading state information... Done</span><br><span class="line">The following NEW packages will be installed:</span><br><span class="line">  net-tools</span><br><span class="line">0 upgraded, 1 newly installed, 0 to remove and 0 not upgraded.</span><br><span class="line">Unpacking net-tools (1.60-26ubuntu1) ...</span><br><span class="line">Setting up net-tools (1.60-26ubuntu1) ...</span><br><span class="line">root@47fc5e302c80:/<span class="comment"># ifconfig</span></span><br><span class="line">eth0      Link encap:Ethernet  HWaddr 02:42:ac:11:64:02</span><br><span class="line">          inet addr:172.17.100.2  Bcast:0.0.0.0  Mask:255.255.252.0</span><br><span class="line">          inet6 addr: fe80::42:acff:fe11:6402/64 Scope:Link</span><br><span class="line">          UP BROADCAST RUNNING MULTICAST  MTU:1500  Metric:1</span><br><span class="line">          RX packets:12780 errors:0 dropped:0 overruns:0 frame:0</span><br><span class="line">          TX packets:5551 errors:0 dropped:0 overruns:0 carrier:0</span><br><span class="line">          collisions:0 txqueuelen:0</span><br><span class="line">          RX bytes:25924957 (25.9 MB)  TX bytes:305225 (305.2 KB)</span><br><span class="line"></span><br><span class="line">lo        Link encap:Local Loopback</span><br><span class="line">          inet addr:127.0.0.1  Mask:255.0.0.0</span><br><span class="line">          inet6 addr: ::1/128 Scope:Host</span><br><span class="line">          UP LOOPBACK RUNNING  MTU:65536  Metric:1</span><br><span class="line">          RX packets:0 errors:0 dropped:0 overruns:0 frame:0</span><br><span class="line">          TX packets:0 errors:0 dropped:0 overruns:0 carrier:0</span><br><span class="line">          collisions:0 txqueuelen:1</span><br><span class="line">          RX bytes:0 (0.0 B)  TX bytes:0 (0.0 B)</span><br><span class="line"></span><br><span class="line">root@47fc5e302c80:/<span class="comment"># apt install iputils-ping</span></span><br><span class="line">Reading package lists... Done</span><br><span class="line">....</span><br><span class="line">root@47fc5e302c80:/<span class="comment"># ping 172.17.100.1</span></span><br><span class="line">PING 172.17.100.1 (172.17.100.1) 56(84) bytes of data.</span><br><span class="line">64 bytes from 172.17.100.1: icmp_seq=1 ttl=64 time=0.095 ms</span><br><span class="line">root@47fc5e302c80:/<span class="comment">#</span></span><br></pre></td></tr></table></figure></p><p>从上面的实践可知新容器创建时，IP地址被自动分配为<code>172.17.100.2</code>; 此外在容器启动时, <code>docker run</code>命令也有网络相关的参数，可以在容器启动时进行针对单个容器的网络配置, 常见的配置选项,<br><code>-h --hostname</code>：配置容器主机名;<br><code>--link</code>：添加另外一个容器的链接;<br><code>--net=bridge|none|container|host</code>：设置容器的网络模式;<br>下面创建一个新的容器，设置主机名为test1，网络模式为none,<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">lihong@dev:~/docker$ docker run --name test1 --hostname test1 --net none -t -i nbuntu /bin/bash</span><br><span class="line">root@test1:/<span class="comment"># ifconfig</span></span><br><span class="line">lo        Link encap:Local Loopback</span><br><span class="line">          inet addr:127.0.0.1  Mask:255.0.0.0</span><br><span class="line">          inet6 addr: ::1/128 Scope:Host</span><br><span class="line">          UP LOOPBACK RUNNING  MTU:65536  Metric:1</span><br><span class="line">          RX packets:0 errors:0 dropped:0 overruns:0 frame:0</span><br><span class="line">          TX packets:0 errors:0 dropped:0 overruns:0 carrier:0</span><br><span class="line">          collisions:0 txqueuelen:1</span><br><span class="line">          RX bytes:0 (0.0 B)  TX bytes:0 (0.0 B)</span><br><span class="line"></span><br><span class="line">root@test1:/<span class="comment"># hostname</span></span><br><span class="line">test1</span><br></pre></td></tr></table></figure></p><p>可以看到网络模式none设置后，在容器中没有出现<code>eth0</code>网卡了。</p><h2 id="网络访问控制"><a href="#网络访问控制" class="headerlink" title="网络访问控制"></a>网络访问控制</h2><p>容器默认是通过docker0的NAT模式访问外部网络，如果我们希望限制容器访问，有很多种办法,</p><p><strong> 1. 限制容器访问外网 </strong><br>在上面的实践中创建的<code>container</code>容器是可以连接外网的，是通过<code>newnet0</code>虚拟交换机进行了NAT转换,<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">lihong@dev:~/docker$ docker attach demo</span><br><span class="line">root@1b9a2f9bfd51:/<span class="comment">#</span></span><br><span class="line">root@1b9a2f9bfd51:/<span class="comment"># ping www.baidu.com</span></span><br><span class="line">PING www.a.shifen.com (119.75.217.109) 56(84) bytes of data.</span><br><span class="line">64 bytes from 119.75.217.109: icmp_seq=1 ttl=127 time=32.4 ms</span><br><span class="line">64 bytes from 119.75.217.109: icmp_seq=2 ttl=127 time=32.0 ms</span><br><span class="line">--- www.a.shifen.com ping statistics ---</span><br><span class="line">2 packets transmitted, 2 received, 0% packet loss, time 1002ms</span><br><span class="line">rtt min/avg/max/mdev = 32.012/32.206/32.400/0.194 ms</span><br></pre></td></tr></table></figure></p><p>限制容器访问外网，可以关闭IP转发，设置方法是启动Docker时<code>--ip-forward=false</code><br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">lihong@dev:~$ sudo dockerd -b=newnet0 --icc=<span class="literal">false</span> --ip-forward=<span class="literal">false</span></span><br><span class="line">[sudo] password <span class="keyword">for</span> lihong:</span><br><span class="line">INFO[0000] libcontainerd: new containerd process, pid: 27004</span><br><span class="line">WARN[0000] containerd: low RLIMIT_NOFILE changing to max  current=1024 max=65536</span><br><span class="line">INFO[0001] [graphdriver] using prior storage driver <span class="string">"aufs"</span></span><br><span class="line">INFO[0001] Graph migration to content-addressability took 0.00 seconds</span><br><span class="line">WARN[0001] Your kernel does not support swap memory <span class="built_in">limit</span>.</span><br><span class="line">INFO[0001] Loading containers: start.</span><br><span class="line">.INFO[0001] Firewalld running: <span class="literal">false</span></span><br><span class="line"></span><br><span class="line">INFO[0001] Loading containers: <span class="keyword">done</span>.</span><br><span class="line">INFO[0001] Daemon has completed initialization</span><br><span class="line">INFO[0001] Docker daemon                                 commit=78d1802 graphdriver=aufs version=1.12.6</span><br><span class="line">INFO[0001] API listen on /var/run/docker.sock</span><br></pre></td></tr></table></figure></p><p>创建新的容器，查看关闭IP转发后的效果,<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">lihong@dev:~/docker$ docker run -ti --name noip nbuntu /bin/bash</span><br><span class="line">root@04972966e18b:/<span class="comment"># ifconfig</span></span><br><span class="line">eth0      Link encap:Ethernet  HWaddr 02:42:ac:11:64:02</span><br><span class="line">          inet addr:172.17.100.2  Bcast:0.0.0.0  Mask:255.255.252.0</span><br><span class="line">          inet6 addr: fe80::42:acff:fe11:6402/64 Scope:Link</span><br><span class="line">          UP BROADCAST RUNNING MULTICAST  MTU:1500  Metric:1</span><br><span class="line">          RX packets:14 errors:0 dropped:0 overruns:0 frame:0</span><br><span class="line">          TX packets:6 errors:0 dropped:0 overruns:0 carrier:0</span><br><span class="line">          collisions:0 txqueuelen:0</span><br><span class="line">          RX bytes:1938 (1.9 KB)  TX bytes:508 (508.0 B)</span><br><span class="line"></span><br><span class="line">lo        Link encap:Local Loopback</span><br><span class="line">          inet addr:127.0.0.1  Mask:255.0.0.0</span><br><span class="line">          inet6 addr: ::1/128 Scope:Host</span><br><span class="line">          UP LOOPBACK RUNNING  MTU:65536  Metric:1</span><br><span class="line">          RX packets:0 errors:0 dropped:0 overruns:0 frame:0</span><br><span class="line">          TX packets:0 errors:0 dropped:0 overruns:0 carrier:0</span><br><span class="line">          collisions:0 txqueuelen:1</span><br><span class="line">          RX bytes:0 (0.0 B)  TX bytes:0 (0.0 B)</span><br><span class="line"></span><br><span class="line">root@04972966e18b:/<span class="comment"># ping www.baidu.com</span></span><br><span class="line">PING www.a.shifen.com (119.75.217.109) 56(84) bytes of data.</span><br><span class="line">64 bytes from 119.75.217.109: icmp_seq=1 ttl=127 time=32.8 ms</span><br></pre></td></tr></table></figure></p><p>不过并没有效果，依然可以ping <a href="http://www.baidu.com" target="_blank" rel="noopener">www.baidu.com</a>, 然后看<code>dockerd</code>输出的结果是,<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">lihong@dev:~$ sudo dockerd -b=newnet0 --icc=<span class="literal">false</span> --ip-forward=<span class="literal">false</span> --ipv6=<span class="literal">false</span></span><br><span class="line">....</span><br><span class="line">INFO[0021] No non-localhost DNS nameservers are left <span class="keyword">in</span> resolv.conf. Using default external servers : [nameserver 8.8.8.8 nameserver 8.8.4.4]</span><br><span class="line">INFO[0021] IPv6 enabled; Adding default IPv6 external servers : [nameserver 2001:4860:4860::8888 nameserver 2001:4860:4860::8844]</span><br></pre></td></tr></table></figure></p><p>上述<code>--ip-forward=false</code>表示<code>ipv4</code>禁止转发, <code>ipv6=false</code>表示禁<code>ipv6</code>, 但是实际好像不起作用, 目前还不知道什么情况?</p><p>注意, 如果有容器正在运行时重启Docker服务，所有运行的容器都会被强制停止。Docker服务重启后也不会重启被停止的容器。</p><p><strong> 2. 限制容器间的访问 </strong></p><p>限制容器间的访问，可以设置<code>--icc</code>参数，或设置<code>iptables</code>参数。默认容器间可以互相访问，通过设置<code>--icc=false</code>可以禁止, 即此时不同的容器间不能互ping对方，无法进行通信,<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">lihong@dev:~$ docker run --name site1 -ti nbuntu /bin/bash</span><br><span class="line">root@73b9d8b7ec70:/<span class="comment"># ifconfig eth0</span></span><br><span class="line">eth0      Link encap:Ethernet  HWaddr 02:42:ac:11:64:02</span><br><span class="line">          inet addr:172.17.100.2  Bcast:0.0.0.0  Mask:255.255.252.0</span><br><span class="line">          inet6 addr: fe80::42:acff:fe11:6402/64 Scope:Link</span><br><span class="line">          UP BROADCAST RUNNING MULTICAST  MTU:1500  Metric:1</span><br><span class="line">          RX packets:16 errors:0 dropped:0 overruns:0 frame:0</span><br><span class="line">          TX packets:6 errors:0 dropped:0 overruns:0 carrier:0</span><br><span class="line">          collisions:0 txqueuelen:0</span><br><span class="line">          RX bytes:2338 (2.3 KB)  TX bytes:508 (508.0 B)</span><br><span class="line"></span><br><span class="line">root@73b9d8b7ec70:/<span class="comment"># ping 172.17.100.3</span></span><br><span class="line">PING 172.17.100.3 (172.17.100.3) 56(84) bytes of data.</span><br><span class="line"></span><br><span class="line">──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────</span><br><span class="line">lihong@dev:~/docker$ docker run --name site2 -ti nbuntu /bin/bash</span><br><span class="line">root@7395b959e752:/<span class="comment"># ifconfig eth0</span></span><br><span class="line">eth0      Link encap:Ethernet  HWaddr 02:42:ac:11:64:03</span><br><span class="line">          inet addr:172.17.100.3  Bcast:0.0.0.0  Mask:255.255.252.0</span><br><span class="line">          inet6 addr: fe80::42:acff:fe11:6403/64 Scope:Link</span><br><span class="line">          UP BROADCAST RUNNING MULTICAST  MTU:1500  Metric:1</span><br><span class="line">          RX packets:8 errors:0 dropped:0 overruns:0 frame:0</span><br><span class="line">          TX packets:5 errors:0 dropped:0 overruns:0 carrier:0</span><br><span class="line">          collisions:0 txqueuelen:0</span><br><span class="line">          RX bytes:920 (920.0 B)  TX bytes:418 (418.0 B)</span><br><span class="line"></span><br><span class="line">root@7395b959e752:/<span class="comment"># ping 172.17.100.2</span></span><br><span class="line">PING 172.17.100.2 (172.17.100.2) 56(84) bytes of data.</span><br></pre></td></tr></table></figure></p><p>可以看到site1,site2互ping是不通的，因为<code>docker</code>启动时设置<code>-icc=false</code>禁止了容器之间互通, 如果需要打开容器间访问, 只需要设置<code>--icc=true</code>即可。</p><h2 id="容器端口映射"><a href="#容器端口映射" class="headerlink" title="容器端口映射"></a>容器端口映射</h2><p>运行<code>docker run</code>的时候可以使用<code>-P</code>参数进行端口映射，这个参数不需要指定任何宿主机的端口，会自动从49000~49900端口中选择一个映射到容器中开放的端口。</p><p>而容器中开放的端口号如何获得呢？可以写在创建镜像的Dockerfile中：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">FROM ubuntu:latest</span><br><span class="line"></span><br><span class="line">EXPOSE 80</span><br></pre></td></tr></table></figure></p><p>基于该Dockerfile创建一个新的镜像port<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">lihong@dev:~/docker$ vim Dockerfile</span><br><span class="line">lihong@dev:~/docker$ cat Dockerfile</span><br><span class="line">from ubuntu:latest</span><br><span class="line"></span><br><span class="line">EXPOSE 80</span><br><span class="line">lihong@dev:~/docker$ docker build -t port:1.0 .</span><br><span class="line">Sending build context to Docker daemon 2.048 kB</span><br><span class="line">Step 1 : FROM ubuntu:latest</span><br><span class="line"> ---&gt; 0ef2e08ed3fa</span><br><span class="line">Step 2 : EXPOSE 80</span><br><span class="line"> ---&gt; Running <span class="keyword">in</span> 487a948fcda6</span><br><span class="line"> ---&gt; 35d62582a16a</span><br><span class="line">Removing intermediate container 487a948fcda6</span><br><span class="line">Successfully built 35d62582a16a</span><br><span class="line">lihong@dev:~/docker$ docker images</span><br><span class="line">REPOSITORY          TAG                 IMAGE ID            CREATED             SIZE</span><br><span class="line">port                1.0                 35d62582a16a        10 seconds ago      130 MB</span><br><span class="line">nbuntu              latest              f16a2621960a        39 minutes ago      174.2 MB</span><br><span class="line">ubuntu              latest              0ef2e08ed3fa        8 days ago          130 MB</span><br><span class="line">lihong@dev:~/docker$ docker run -P -ti --name portdemo port:1.0 /bin/bash</span><br><span class="line">root@2d4b6a054e9e:/<span class="comment"># lihong@dev:~/docker$</span></span><br><span class="line">lihong@dev:~/docker$ docker inspect -f &#123;&#123;.NetworkSettings.Ports&#125;&#125; portdemo</span><br><span class="line">map[80/tcp:[&#123;0.0.0.0 32768&#125;]]</span><br></pre></td></tr></table></figure></p><p>如果想指定映射端口，可以使用<code>-p</code>参数，请注意一个宿主机的端口只能绑定到一个容器，如果该端口已经有进程在用则不可以绑定。并且<code>-p</code>参数可以绑定多个端口,<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">lihong@dev:~/docker$ docker run -ti -p 80:80 -p 5000:5000 --name portdemo1 port:1.0 /bin/bash</span><br><span class="line">root@dfb3563babd5:/<span class="comment"># lihong@dev:~/docker$</span></span><br><span class="line">lihong@dev:~/docker$ docker inspect -f &#123;&#123;.NetworkSettings.Ports&#125;&#125; portdemo1</span><br><span class="line">map[5000/tcp:[&#123;0.0.0.0 5000&#125;] 80/tcp:[&#123;0.0.0.0 80&#125;]]</span><br></pre></td></tr></table></figure></p><p>如果想映射到指定的本地地址，可以增加<code>IP</code>参数，比如映射到<code>127.0.0.1</code>地址，只需要将参数写成 <code>-p 127.0.0.1:80:80</code>。<br>查看指定容器的端口映射可以使用<code>docker port</code>命令,<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">lihong@dev:~/docker$ docker port portdemo1 80</span><br><span class="line">0.0.0.0:80</span><br><span class="line">lihong@dev:~/docker$ docker port portdemo1</span><br><span class="line">5000/tcp -&gt; 0.0.0.0:5000</span><br><span class="line">80/tcp -&gt; 0.0.0.0:80</span><br></pre></td></tr></table></figure></p><p><code>Docker</code>的端口映射也是通过<code>iptables</code>规则来设置的，当完成映射后，使用<code>iptables</code>命令查看是否新增了规则,<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">lihong@dev:~/docker$ sudo iptables -L</span><br><span class="line">[sudo] password <span class="keyword">for</span> lihong:</span><br><span class="line">Chain INPUT (policy ACCEPT)</span><br><span class="line">target     prot opt <span class="built_in">source</span>               destination</span><br><span class="line"></span><br><span class="line">Chain FORWARD (policy ACCEPT)</span><br><span class="line">target     prot opt <span class="built_in">source</span>               destination</span><br><span class="line">DOCKER-ISOLATION  all  --  anywhere             anywhere</span><br><span class="line">DOCKER     all  --  anywhere             anywhere</span><br><span class="line">ACCEPT     all  --  anywhere             anywhere             ctstate RELATED,ESTABLISHED</span><br><span class="line">ACCEPT     all  --  anywhere             anywhere</span><br><span class="line">DROP       all  --  anywhere             anywhere</span><br><span class="line"></span><br><span class="line">Chain OUTPUT (policy ACCEPT)</span><br><span class="line">target     prot opt <span class="built_in">source</span>               destination</span><br><span class="line"></span><br><span class="line">Chain DOCKER (1 references)</span><br><span class="line">target     prot opt <span class="built_in">source</span>               destination</span><br><span class="line">ACCEPT     tcp  --  anywhere             172.17.100.2         tcp dpt:5000</span><br><span class="line">ACCEPT     tcp  --  anywhere             172.17.100.2         tcp dpt:http</span><br><span class="line"></span><br><span class="line">Chain DOCKER-ISOLATION (1 references)</span><br><span class="line">target     prot opt <span class="built_in">source</span>               destination</span><br><span class="line">RETURN     all  --  anywhere             anywhere</span><br></pre></td></tr></table></figure></p><h2 id="容器互联"><a href="#容器互联" class="headerlink" title="容器互联"></a>容器互联</h2><p><strong> 需求 </strong><br>设定一个场景，我们的应用包含多个容器,</p><p>容器1：Web前端服务 端口80<br>容器2：App应用服务 端口80<br>容器3：Redis数据库服务 端口6379<br>创建容器后，如何让这三个容器连接共同构成我们所需的Web应用服务呢？</p><p>此时我们并不想将每个容器的端口都通过映射的方式暴露出来，那么Docker又提供了怎样的方案呢？</p><p>这就需要用到Docker强大的<code>--link</code>参数，完美支持容器间互联。</p><p><strong> 需求分析 </strong></p><p>需要创建三个容器, 分别根据作用命名, 在创建过程中使用<code>--link</code>参数让容器间建立安全的互联通道。<br><code>docker run</code>命令的<code>--link</code>参数可以在不映射端口的前提下为两个容器间建立安全连接。<code>--link</code>参数可以连接一个或多个容器到将要创建的容器。</p><p>现在假设三个容器命名为: web, app, db, 连接方式分别是web连接app, app连接db。其中web和app容器使用上面创建的EXPOSE 80端口的镜像port:1.0。</p><p><strong> 需求实现 </strong></p><p>首先依次创建三个容器db, app 和web,<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">lihong@dev:~/docker$ docker run -d --name db redis</span><br><span class="line">Unable to find image <span class="string">'redis:latest'</span> locally</span><br><span class="line">latest: Pulling from library/redis</span><br><span class="line">693502eb7dfb: Pull complete</span><br><span class="line">338a71333959: Pull complete</span><br><span class="line">83f12ff60ff1: Pull complete</span><br><span class="line">4b7726832aec: Pull complete</span><br><span class="line">19a7e34366a6: Pull complete</span><br><span class="line">622732cddc34: Pull complete</span><br><span class="line">3b281f2bcae3: Pull complete</span><br><span class="line">Digest: sha256:e4a69910ba49d7c211135df2b8220ee94c634f4789c9b3c7ed391a36bbdbddbf</span><br><span class="line">Status: Downloaded newer image <span class="keyword">for</span> redis:latest</span><br><span class="line">25a3e1d54cac360110cee428b29e7c6db293353043fabc0f5e2e6a40b5a84d37</span><br><span class="line">lihong@dev:~/docker$ docker run -ti --name app --link db:db port:1.0 /bin/bash</span><br><span class="line">root@49b603633f45:/<span class="comment"># lihong@dev:~/docker$ docker run -ti --name web --link app:app port:1.0 /bin/bash</span></span><br><span class="line">root@e19881f8497c:/<span class="comment">#</span></span><br></pre></td></tr></table></figure></p><p>注: <code>-d</code>, –detach                  Run container in background and print container ID</p><p>现在进入到<code>web容器</code>中可以查看到<code>--link</code>参数为了连接容器做了哪些改变,<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">root@e19881f8497c:/<span class="comment"># cat /etc/hosts</span></span><br><span class="line">127.0.0.1      localhost</span><br><span class="line">::1    localhost ip6-localhost ip6-loopback</span><br><span class="line">fe00::0ip6-localnet</span><br><span class="line">ff00::0ip6-mcastprefix</span><br><span class="line">ff02::1ip6-allnodes</span><br><span class="line">ff02::2ip6-allrouters</span><br><span class="line">172.17.100.3   app 49b603633f45</span><br><span class="line">172.17.100.4   e19881f8497c</span><br><span class="line">root@e19881f8497c:/<span class="comment"># ping app</span></span><br><span class="line">PING app (172.17.100.3) 56(84) bytes of data.</span><br><span class="line">64 bytes from app (172.17.100.3): icmp_seq=1 ttl=64 time=0.072 ms</span><br><span class="line">64 bytes from app (172.17.100.3): icmp_seq=2 ttl=64 time=0.062 ms</span><br><span class="line">^C</span><br><span class="line">--- app ping statistics ---</span><br><span class="line">2 packets transmitted, 2 received, 0% packet loss, time 1015ms</span><br><span class="line">rtt min/avg/max/mdev = 0.062/0.067/0.072/0.005 ms</span><br><span class="line">root@e19881f8497c:/<span class="comment"># env | grep APP</span></span><br><span class="line">APP_PORT_80_TCP_PORT=80</span><br><span class="line">APP_PORT_80_TCP_ADDR=172.17.100.3</span><br><span class="line">APP_PORT_80_TCP=tcp://172.17.100.3:80</span><br><span class="line">APP_PORT_80_TCP_PROTO=tcp</span><br><span class="line">APP_NAME=/web/app</span><br><span class="line">APP_PORT=tcp://172.17.100.3:80</span><br><span class="line">root@e19881f8497c:/<span class="comment">#</span></span><br></pre></td></tr></table></figure></p><p>注意: 要使得容器间互通, 要保证<code>dockerd</code>启动时, <code>--icc=true</code>设置或者不设置这个参数, 因为默认是true, 否则如上面的ping app是ping不通的,</p><p>可以看到环境变量和/etc/hosts文件的变化，在web容器中可以<code>ping app</code>进行测试。<br>通过<code>--link</code>参数可以把几个容器绑定在一起，并且不需要向外部公开内部应用容器和数据库容器的端口号，只需要将对外提供服务的web服务端口<code>80</code>开放即可。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>本文主要实践了如下内容, </p><ul><li>Docker 网络基本配置</li><li>Docker 网络访问控制</li><li>Docker 容器端口映射</li><li>Docker 容器互联</li></ul><p>额外收获如下,</p><blockquote><p>实验过程中在Mac/Linux(ubuntu)系统中同时进行(即在Mac上做一遍然后又到ubuntu上做一遍(简直时间多，折腾啊)), 其中遇到问题的相关解决方案记录</p></blockquote><p><strong> 1. 在ubuntu上安装docker之后，pull东西慢 </strong><br>从docker Hub上pull东西很慢,是因为使用的是国外的下载源, 所以要修改docker Hub pull的源, 本文解决方案是到daocloud.io官网注册一个账号,然后到控制台那有个加速器会生成一个docker 加速器地址，按照它的说明更换掉docker源即可。</p><p><strong> 2. 没有<code>ifconfig</code>, <code>ping</code>命令 </strong><br>通过docker 运行的镜像ubuntu容器里没有<code>ifconfig</code>, <code>ping</code>命令, 这个可以直接进入相关的容器执行下面三条命令即可将<code>ifconfig</code>, <code>ping</code>命令安装上来,<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">apt-get update </span><br><span class="line">apt install net-tools    <span class="comment"># ifconfig</span></span><br><span class="line">apt install iputils-ping <span class="comment"># ping</span></span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Docker中的网络一直是比较弱的, 本文从基础配置到访问控制再到容器互联等几个方面进行总结, 在较早期的docker版本中只提供最基本的网络通信支持, 如早期版本支持的最常见的三种场景,&lt;br&gt;1.使用NAT方式连接外部网络;&lt;br&gt;2.映射容器和宿主机的端口, 使外部可以访问容器中的应用;&lt;br&gt;3.容器间网络互联.&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="docker-practice" scheme="http://researchlab.github.io/categories/docker-practice/"/>
    
    
      <category term="docker" scheme="http://researchlab.github.io/tags/docker/"/>
    
  </entry>
  
  <entry>
    <title>docker实践--03 镜像管理</title>
    <link href="http://researchlab.github.io/2017/03/06/docker-image-mgr/"/>
    <id>http://researchlab.github.io/2017/03/06/docker-image-mgr/</id>
    <published>2017-03-06T11:06:41.000Z</published>
    <updated>2018-10-18T05:08:14.830Z</updated>
    
    <content type="html"><![CDATA[<p>在前面第一篇总结中已了解了一些镜像的概念，简单的说镜像就是一个容器的只读模板，用来创建容器。当运行容器时需要指定镜像，如果本地没有该镜像，则会从Docker Registry下载。默认查找的是<code>Docker Hub</code>。Docker的镜像是增量的修改，每次创建新的镜像都会在老的镜像上面构建一个增量的层，使用到的技术是Another Union File System(AUFS)，具体可参考 <a href="http://www.infoq.com/cn/articles/analysis-of-docker-file-system-aufs-and-devicemapper/" target="_blank" rel="noopener">剖析Docker文件系统：Aufs与Devicemapper</a>, 下面主要总结记录使用和管理docker镜像的过程。</p><a id="more"></a><h2 id="查找和下载镜像"><a href="#查找和下载镜像" class="headerlink" title="查找和下载镜像"></a>查找和下载镜像</h2><p>镜像存储中的核心概念仓库(Repository)是镜像存储的位置。Docker注册服务器(Registry)是仓库存储的位置。每个仓库包含不同的镜像。比如一个镜像名称<code>ubuntu:14.04</code>，冒号前面的ubuntu是仓库名, 后面的14.04是TAG, 不同的TAG可以对应相同的镜像, TAG通常设置为镜像的版本号。<code>Docker Hub</code>是Docker官方提供公共仓库，提供大量的常用镜像，由于国内网络原因经常连接Docker Hub会比较慢，所以我们也可以选择一些国内提供类似Docker Hub镜像服务站点。连接Docker Hub的常用命令包括,</p><ul><li>搜索镜像 docker search</li><li>下载镜像 docker pull<br>假设现在需要一个busybox镜像，首先进行搜索，然后使用docker pull下载到本地,<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">➜  ~ docker images</span><br><span class="line">REPOSITORY          TAG                 IMAGE ID            CREATED             SIZE</span><br><span class="line">nginx               latest              6b914bbcb89e        6 days ago          182 MB</span><br><span class="line">ubuntu              latest              0ef2e08ed3fa        7 days ago          130 MB</span><br><span class="line">➜  ~ docker search busybox</span><br><span class="line">NAME                            DESCRIPTION                                     STARS     OFFICIAL   AUTOMATED</span><br><span class="line">busybox                         Busybox base image.                             945       [OK]</span><br><span class="line">progrium/busybox                                                                65                   [OK]</span><br><span class="line">radial/busyboxplus              Full-chain, Internet enabled, busybox made...   11                   [OK]</span><br><span class="line">container4armhf/armhf-busybox   Automated build of Busybox <span class="keyword">for</span> armhf devic...   6                    [OK]</span><br><span class="line">➜  ~</span><br></pre></td></tr></table></figure></li></ul><p>查找到的数据中包含仓库名称, 描述, 以及有多少人关注。一般情况只需要下载最基本的Busybox base image就可以, 查找命令返回的结果中通常可以看到不同版本的busybox, 不指定版本号默认下载busybox:latest。使用<code>docker pull</code>命令将镜像下载到本地,<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">➜  ~ docker pull busybox</span><br><span class="line">Using default tag: latest</span><br><span class="line">latest: Pulling from library/busybox</span><br><span class="line">4b0bc1c4050b: Pull complete</span><br><span class="line">Digest: sha256:348432dd709c2cd6ca42e56c2a0d157f611c50c908e14c9bfc1e9cb0ed234871</span><br><span class="line">Status: Downloaded newer image <span class="keyword">for</span> busybox:latest</span><br><span class="line">➜  ~ docker images</span><br><span class="line">REPOSITORY          TAG                 IMAGE ID            CREATED             SIZE</span><br><span class="line">nginx               latest              6b914bbcb89e        6 days ago          182 MB</span><br><span class="line">ubuntu              latest              0ef2e08ed3fa        7 days ago          130 MB</span><br><span class="line">busybox             latest              7968321274dc        7 weeks ago         1.11 MB</span><br></pre></td></tr></table></figure></p><p>也可以在Docker Hub上创建一个账户，用来保存所需的镜像，但是在国内使用实在是太慢了。这里简单介绍下Docker中使用命令登陆Docker Hub保存镜像的方式,</p><ul><li>首先在Docker Hub注册一个账号, </li><li>然后可以基于Docker Hub上现有的镜像创建一个镜像</li><li>在本地完成修改后使用docker push命令推送到Docker Hub上</li></ul><p>此外，Docker Hub提供一个强大的自动创建镜像的功能，可以设定跟踪某个镜像中安装的软件，如果有更新则自动重新构建新的镜像。更多有趣的功能可以登录到Docker Hub 官网进行体验。在此不做更多介绍。</p><h2 id="创建镜像"><a href="#创建镜像" class="headerlink" title="创建镜像"></a>创建镜像</h2><p><strong> 方法一, 下载镜像 docker pull </strong></p><p>在本地创建镜像的方法有几种，最简单的是直接从Registry服务器上下载, 即通过<code>docker pull</code>命令下载下来，镜像下载中可以看到是分层下载，每一层都有一个唯一的ID值表示，每层下载的大小实际为该层进行的修改增量。</p><p><strong> 方法二,  创建镜像 Dockerfile </strong></p><p><code>Dockerfile</code>可以很方便的基于已有镜像创建新的镜像。<code>Dockerfile</code>文件里包含若干条命令，每个命令都会创建一个新的层, <code>Dockerfile</code>创建的层数不可以超过127层。<code>Dockerfile</code>的详细编写方法后续再说，此处只写一个最简单的Dockerfile来介绍。</p><p>使用vim打开一个文件Dockerfile, 并写入下面两行，<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">from ubuntu:latest</span><br><span class="line">ENV HOSTNAME=new_image</span><br></pre></td></tr></table></figure></p><p>这个<code>Dockerfile</code>中只有两行，第一行表示基于哪个镜像创建新的镜像，类似于程序开发中的<code>import</code>或<code>include</code>, 这里以<code>ubuntu:latest</code>镜像为基础创建新的镜像。第二行是在新的镜像中我们要对基础镜像<code>ubuntu:latest</code>做的改变。这句是设置一个环境变量HOSTNAME等于new_image。完成<code>Dockerfile</code>后，使用<code>docker build</code>命令进行构建,<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker build -t nimage .</span><br></pre></td></tr></table></figure></p><p>这个命令中第一个参数<code>-t nimage</code>指定创建的新镜像的名字，第二个参数是一个点<code>.</code>指定从当前目录查找<code>Dockerfile</code>文件。执行完成后我们 docker images 命令中就可以看到新的nimage镜像了。</p><p><strong> 其它方法创建镜像 </strong><br>创建镜像的方法很多，除了上述两种之外还可以使用下述方法进行创建，如,</p><ul><li>容器管理中总结过的<code>docker import</code></li><li>对容器提交修改<code>docker commit</code></li><li>导入镜像<code>docker load</code></li></ul><h2 id="查看镜像信息"><a href="#查看镜像信息" class="headerlink" title="查看镜像信息"></a>查看镜像信息</h2><p><strong> 1. 基本命令 docker images </strong><br><code>docker images</code>命令查看本地的镜像列表，信息包括,</p><ul><li><code>REPOSITORY</code>：仓库名称</li><li><code>TAG</code>：标签名，一个仓库可以有若干个标签对应不同的镜像，默认都是latest</li><li><code>IMAGE ID</code>：镜像ID</li><li><code>CREATED</code>：创建时间，注意不是本地的pull时间</li><li><code>SIZE</code>：镜像大小</li></ul><p>其中需要注意的是运行容器时候如果不指定镜像的<code>TAG</code>, 则默认为<code>latest</code>。镜像的唯一标识符是<code>镜像ID</code>, 不是<code>TAG</code>, 有的时候同一个镜像可以有不同的<code>TAG</code>, 但实际指向的是同一个<code>镜像ID</code>。<code>TAG</code>可以理解为镜像的别名。</p><p>查看当前系统中存储的所有镜像信息,<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">➜  ~ docker images</span><br><span class="line">REPOSITORY          TAG                 IMAGE ID            CREATED             SIZE</span><br><span class="line">nginx               latest              6b914bbcb89e        6 days ago          182 MB</span><br><span class="line">ubuntu              latest              0ef2e08ed3fa        7 days ago          130 MB</span><br><span class="line">busybox             latest              7968321274dc        7 weeks ago         1.11 MB</span><br></pre></td></tr></table></figure></p><p><strong> 2. 查看镜像详细信息 docker inspect </strong></p><p><code>docker inspect</code>可以查看指定镜像的详细信息。这条命令可以查看容器或镜像的详细信息，输出是一个JSON格式的内容，比较重要的信息是创建时间，启动命令等, 前面已经总结过，这里就不再赘述。</p><h2 id="导入和导出镜像"><a href="#导入和导出镜像" class="headerlink" title="导入和导出镜像"></a>导入和导出镜像</h2><p>与容器的导出和导入类似, 镜像可以被导出到本地文件，也可以从本地文件中加载。导出命令是<code>docker save</code>命令，导出后的镜像如果需要导入到新的Docker 服务器, 则使用<code>docker load</code>命令。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">~ docker save busybox &gt; newbox.tar</span><br><span class="line">➜  ~ docker load -i ~/newbox.tar</span><br><span class="line">Loaded image: busybox:latest</span><br><span class="line">➜  ~ docker images</span><br><span class="line">REPOSITORY          TAG                 IMAGE ID            CREATED             SIZE</span><br><span class="line">nginx               latest              6b914bbcb89e        6 days ago          182 MB</span><br><span class="line">ubuntu              latest              0ef2e08ed3fa        7 days ago          130 MB</span><br><span class="line">busybox             latest              7968321274dc        7 weeks ago         1.11 MB</span><br></pre></td></tr></table></figure></p><h2 id="更新镜像"><a href="#更新镜像" class="headerlink" title="更新镜像"></a>更新镜像</h2><p>更新镜像用命令 <code>docker commit</code>, 如果需要对镜像进行更新的话，一种方法是创建容器，在容器中进行修改，然后将修改后容器提交到镜像中。提交使用<code>docker commit</code>命令。<br>注意：本方法不推荐用在生产系统中，未来会很难维护镜像。最好的创建镜像的方法是<code>Dockerfile</code>，修改镜像的方法是<code>修改Dockerfile</code>，然后重新从Dockerfile中构建新的镜像。</p><p>下面先基于ubuntu镜像创建一个容器,<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run -t -i --name updateimage ubuntu /bin/bash</span><br></pre></td></tr></table></figure></p><p>进入到容器中进行修改，创建三个新的文件夹，然后退出容器, 通过<code>docker diff</code>命令可以查看到确实做出了修改，然后通过<code>docker commit</code>命令将修改后的内容提交到本地，另存为镜像newbuntu, </p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">➜  ~ docker run -t -i --name updateimage ubuntu /bin/bash</span><br><span class="line">root@4a7b3923ad93:/<span class="comment"># touch /tmp/s&#123;1,2,3&#125;</span></span><br><span class="line">root@4a7b3923ad93:/<span class="comment"># ls -la /tmp/</span></span><br><span class="line">total 8</span><br><span class="line">drwxrwxrwt 1 root root 4096 Mar  7 03:53 .</span><br><span class="line">drwxr-xr-x 1 root root 4096 Mar  7 03:53 ..</span><br><span class="line">-rw-r--r-- 1 root root    0 Mar  7 03:53 s1</span><br><span class="line">-rw-r--r-- 1 root root    0 Mar  7 03:53 s2</span><br><span class="line">-rw-r--r-- 1 root root    0 Mar  7 03:53 s3</span><br><span class="line">root@4a7b3923ad93:/<span class="comment"># %                                                                                                                                                              ➜  ~ docker diff updateimage</span></span><br><span class="line">C /tmp</span><br><span class="line">A /tmp/s1</span><br><span class="line">A /tmp/s2</span><br><span class="line">A /tmp/s3</span><br><span class="line">➜  ~ docker images</span><br><span class="line">REPOSITORY          TAG                 IMAGE ID            CREATED             SIZE</span><br><span class="line">nginx               latest              6b914bbcb89e        6 days ago          182 MB</span><br><span class="line">ubuntu              latest              0ef2e08ed3fa        7 days ago          130 MB</span><br><span class="line">➜  ~ docker commit -m <span class="string">'add 3 dirs'</span> -a <span class="string">'newbuntu'</span> -p updateimage newbuntu</span><br><span class="line">sha256:2557af5f7c99b0f1dd61c32e5c70320c5181f8e288109220437ed51e829c996b</span><br><span class="line">➜  ~ docker images</span><br><span class="line">REPOSITORY          TAG                 IMAGE ID            CREATED             SIZE</span><br><span class="line">newbuntu            latest              2557af5f7c99        2 seconds ago       130 MB</span><br><span class="line">nginx               latest              6b914bbcb89e        6 days ago          182 MB</span><br><span class="line">ubuntu              latest              0ef2e08ed3fa        7 days ago          130 MB</span><br><span class="line">➜  ~</span><br></pre></td></tr></table></figure><p><code>docker commit</code>参数说明,</p><ul><li><code>-m</code>: 本次提交的描述</li><li><code>-a</code>: 指定镜像作者信息</li><li><code>-p</code>: 提交时暂停容器运行</li><li><code>updateimage</code>: 容器的ID或名称</li><li><code>newbuntu</code>: 目标镜像</li></ul><p>如果指定了目标镜像，Docker会创建新的镜像。类似我们修改一个word文档后进行的另存为。</p><h2 id="删除镜像"><a href="#删除镜像" class="headerlink" title="删除镜像"></a>删除镜像</h2><p>删除镜像命令:<code>docker rmi</code>, <code>docker rmi</code>命令可以删除本地的镜像，删除前需要先使用<code>docker rm</code> 删除所有依赖该镜像的容器。<code>docker rmi -f</code> 可以强制删除存在容器依赖的镜像，但这不是一个好习惯，请先删除容器再清理镜像。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ul><li>使用Docker Hub查找和下载镜像</li><li>创建镜像</li><li>查看镜像信息</li><li>导入和导出镜像</li><li>修改镜像</li><li>删除镜像</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在前面第一篇总结中已了解了一些镜像的概念，简单的说镜像就是一个容器的只读模板，用来创建容器。当运行容器时需要指定镜像，如果本地没有该镜像，则会从Docker Registry下载。默认查找的是&lt;code&gt;Docker Hub&lt;/code&gt;。Docker的镜像是增量的修改，每次创建新的镜像都会在老的镜像上面构建一个增量的层，使用到的技术是Another Union File System(AUFS)，具体可参考 &lt;a href=&quot;http://www.infoq.com/cn/articles/analysis-of-docker-file-system-aufs-and-devicemapper/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;剖析Docker文件系统：Aufs与Devicemapper&lt;/a&gt;, 下面主要总结记录使用和管理docker镜像的过程。&lt;/p&gt;
    
    </summary>
    
      <category term="docker-practice" scheme="http://researchlab.github.io/categories/docker-practice/"/>
    
    
      <category term="docker" scheme="http://researchlab.github.io/tags/docker/"/>
    
  </entry>
  
  <entry>
    <title>docker实践--02 数据卷管理</title>
    <link href="http://researchlab.github.io/2017/03/05/docker-data-volume/"/>
    <id>http://researchlab.github.io/2017/03/05/docker-data-volume/</id>
    <published>2017-03-05T00:44:31.000Z</published>
    <updated>2018-10-18T05:08:14.826Z</updated>
    
    <content type="html"><![CDATA[<p>Docker中的数据可以存储在类似于虚拟机磁盘的介质中，在Docker中称为<code>数据卷</code>(Data Volume)。数据卷可以用来存储Docker应用的数据，也可以用来在Docker容器间进行数据共享。数据卷呈现给Docker容器的形式就是一个目录，支持多个容器间共享，修改也不会影响镜像。使用Docker的数据卷，类似在系统中使用<code>mount</code> 挂载一个文件系统。<br><a id="more"></a></p><h2 id="创建数据卷"><a href="#创建数据卷" class="headerlink" title="创建数据卷"></a>创建数据卷</h2><p>利用<code>docker run</code>创建容器时, 添加<code>-v</code>参数, 就可以创建并挂载一个到多个数据卷到当前运行的容器中，<code>-v</code>参数的作用是将宿主机的一个目录作为容器的数据卷挂载到容器中，使宿主机和容器之间可以共享一个目录，如果本地路径不存在，Docker也会自动创建。</p><p>下面就通过挂载2个数据卷到新创建的容器上来操作一下,<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 创建两个目录</span></span><br><span class="line">➜  mkdir /tmp/data&#123;1,2&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 分别将两个目录挂载到新创建的data容器上</span></span><br><span class="line">➜  docker run -t -i --name data -v /tmp/data1:/data1 -v /tmp/data2:/data2 ubuntu /bin/bash</span><br></pre></td></tr></table></figure></p><p>上述命令中 -v 参数可以使用多次，并挂在多个数据卷到容器中。后面的参数信息中冒号前面是宿主机的本地目录，冒号后面是容器中的挂载目录, 结果如下,<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">➜  mkdir /tmp/data&#123;1,2&#125;</span><br><span class="line">➜  docker run -t -i --name data -v /tmp/data1:/data1 -v /tmp/data2:/data2 ubuntu /bin/bash</span><br><span class="line">root@8a8754728a1c:/<span class="comment"># ls</span></span><br><span class="line">bin  boot  data1  data2  dev  etc  home  lib  lib64  media  mnt  opt  proc  root  run  sbin  srv  sys  tmp  usr  var</span><br><span class="line">root@8a8754728a1c:/<span class="comment"># mount | grep data</span></span><br><span class="line">osxfs on /data1 <span class="built_in">type</span> fuse.osxfs (rw,nosuid,nodev,relatime,user_id=0,group_id=0,allow_other,max_read=1048576)</span><br><span class="line">osxfs on /data2 <span class="built_in">type</span> fuse.osxfs (rw,nosuid,nodev,relatime,user_id=0,group_id=0,allow_other,max_read=1048576)</span><br><span class="line">/dev/vda1 on /etc/resolv.conf <span class="built_in">type</span> ext4 (rw,relatime,data=ordered)</span><br><span class="line">/dev/vda1 on /etc/hostname <span class="built_in">type</span> ext4 (rw,relatime,data=ordered)</span><br><span class="line">/dev/vda1 on /etc/hosts <span class="built_in">type</span> ext4 (rw,relatime,data=ordered)</span><br><span class="line">root@8a8754728a1c:/<span class="comment"># ls -l data*</span></span><br><span class="line">data1:</span><br><span class="line">total 0</span><br><span class="line"></span><br><span class="line">data2:</span><br><span class="line">total 0</span><br><span class="line">root@8a8754728a1c:/<span class="comment">#</span></span><br></pre></td></tr></table></figure></p><p>进入容器后我们可以查看和使用容器卷，尝试向这个容器卷中写入数据，然后在宿主机中查看是否存在,<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">root@8a8754728a1c:/<span class="comment"># touch /data1/test1</span></span><br><span class="line">root@8a8754728a1c:/<span class="comment"># touch /data2/test2</span></span><br><span class="line">root@8a8754728a1c:/<span class="comment"># %                                                                                                ➜  helloworldimage ls /tmp/data1/test1</span></span><br><span class="line">➜  helloworldimage <span class="built_in">cd</span> /tmp/data2/test2</span><br><span class="line"><span class="built_in">cd</span>: not a directory: /tmp/data2/test2</span><br><span class="line">➜  helloworldimage <span class="built_in">cd</span> /tmp/data2</span><br><span class="line">➜  data2 ls</span><br><span class="line">test2</span><br></pre></td></tr></table></figure></p><p>可以看到容器中挂载的数据卷具备可写权限，那么如何对数据卷的权限进行管理呢？比如如何创建一个只读的数据卷呢？</p><h2 id="管理数据卷权限"><a href="#管理数据卷权限" class="headerlink" title="管理数据卷权限"></a>管理数据卷权限</h2><p>挂载的数据卷默认为可读写权限，除非外部文件系统做了特殊限制，在<code>docker run</code>时也可以执行为只读权限,<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 创建一个数据卷目录</span></span><br><span class="line">➜  mkdir /tmp/readonlydata</span><br><span class="line"><span class="comment"># 以只读的方式挂载到data容器上</span></span><br><span class="line">➜  docker run -t -i --name data -v /tmp/readonlydata:/rodata:ro ubuntu /bin/bash</span><br></pre></td></tr></table></figure></p><p>上面的命令中参数很简单, <code>ro</code>表示<code>readonly</code>, 挂载后的数据卷就是只读权限了, 此时再次尝试向数据卷中写入,<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">t@ad5299bae606:/<span class="comment"># mount | grep rodata</span></span><br><span class="line">osxfs on /rodata <span class="built_in">type</span> fuse.osxfs (ro,relatime,user_id=0,group_id=0,allow_other,max_read=1048576)</span><br><span class="line">root@ad5299bae606:/<span class="comment"># ls -l /rodata/</span></span><br><span class="line">total 0</span><br><span class="line">root@ad5299bae606:/<span class="comment"># touch /rodata/readonlydatafile</span></span><br><span class="line">touch: cannot touch <span class="string">'/rodata/readonlydatafile'</span>: Read-only file system</span><br></pre></td></tr></table></figure></p><p>除了可以挂载目录之外，文件也可以作为数据卷挂载到容器中。</p><h2 id="挂载宿主机文件"><a href="#挂载宿主机文件" class="headerlink" title="挂载宿主机文件"></a>挂载宿主机文件</h2><p>如果想让所有的容器都可以共享宿主机的/etc/apt/sources.list，从而只需要改变宿主机的apt源就能够影响到所有的容器。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run -t -i --name file -v /etc/apt/sources.list:/etc/apt/sources.list:ro ubuntu /bin/bash</span><br></pre></td></tr></table></figure></p><blockquote><p>此命令适合linux系统中执行，在mac os中无/etc/apt/sources.list文件</p></blockquote><p>如果想共享一个数据卷给多个容器怎么办，比如设想一个场景，我们有两个处理上传数据的应用运行在不同的容器中，但需要同时读取同一个文件夹下的文件，此时，最好的方式是使用数据卷容器。</p><h2 id="使用数据卷容器共享数据"><a href="#使用数据卷容器共享数据" class="headerlink" title="使用数据卷容器共享数据"></a>使用数据卷容器共享数据</h2><p>如果需要在多个容器间共享数据，并希望永久保存这些数据，最好的方式是使用数据卷容器，类似于一个提供网络文件共享服务的NFS服务器。</p><p>数据卷容器创建方法跟普通容器一样，只需要指定宿主机的一个文件夹作为数据卷即可，使用<code>docker create</code>命令创建但不启动数据卷容器,<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">➜ docker create -v /sharedb --name sharedb ubuntu /bin/<span class="literal">true</span></span><br><span class="line">b73abf556db4e76edc79bb7514cfa4067fd891ffb4d26105eec32ab612b83d78</span><br><span class="line">➜ docker ps</span><br><span class="line">dCONTAINER ID        IMAGE               COMMAND             CREATED             STATUS              PORTS               NAMES</span><br><span class="line">➜ docker ps -a</span><br><span class="line">CONTAINER ID        IMAGE               COMMAND             CREATED             STATUS              PORTS               NAMES</span><br><span class="line">b73abf556db4        ubuntu              <span class="string">"/bin/true"</span>         4 hours ago         Created                                 sharedb</span><br></pre></td></tr></table></figure></p><p>其他使用该数据卷容器的容器创建时候需要使用<code>--volumes-from</code>参数，指定该容器名称或ID,<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run --volumes-from sharedb...</span><br></pre></td></tr></table></figure></p><p>创建site1和site2两个容器挂载数据卷容器sharedb,<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">➜  ~ docker run --volumes-from sharedb --name site1 -t -i ubuntu /bin/bash</span><br><span class="line">root@e0984656600a:/# %                                                                                                ➜  ~ docker run --volumes-from sharedb --name site2 -t -i ubuntu /bin/bash</span><br><span class="line">root@7bf4a2ebe458:/# %                                                                                                ➜  ~ docker attach site1</span><br><span class="line">root@e0984656600a:/#</span><br><span class="line">root@e0984656600a:/# ls -l /sharedb/</span><br><span class="line">total 0</span><br><span class="line">root@e0984656600a:/# touch /sharedb/site1file</span><br><span class="line">root@e0984656600a:/# %                                                                                                ➜  ~ docker attach site2</span><br><span class="line">root@7bf4a2ebe458:/#</span><br><span class="line">root@7bf4a2ebe458:/# ls -l /sharedb/</span><br><span class="line">total 0</span><br><span class="line">-rw-r--r-- 1 root root 0 Mar  6 13:01 site1file</span><br><span class="line">root@7bf4a2ebe458:/# touch /sharedb/fromsite2file</span><br><span class="line">root@7bf4a2ebe458:/# %                                                                                                ➜  ~ docker attach site1</span><br><span class="line">root@e0984656600a:/#</span><br><span class="line">root@e0984656600a:/# ls /sharedb/</span><br><span class="line">fromsite2file  site1file</span><br><span class="line">root@e0984656600a:/#</span><br></pre></td></tr></table></figure></p><p>上面通过连接到这两个容器中对数据卷进行操作，并查看彼此之间已经有了共享文件。</p><h2 id="数据卷备份"><a href="#数据卷备份" class="headerlink" title="数据卷备份"></a>数据卷备份</h2><p>既然可以利用数据卷容器共享数据， 那如何备份这些共享数据呢？下面通过一个完整的案例来操作如何进行数据卷备份，</p><p>1.创建一个新的容器<br>2.挂载数据卷容器<br>3.挂载宿主机本地目录作为数据卷<br>4.将数据卷容器的内容备份到宿主机本地目录挂载的数据卷中<br>5.完成备份操作后容器销毁</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">➜  ~ docker run --rm --volumes-from sharedb -v /tmp/backup:/backup ubuntu tar cvf /backup/sharedb.tar /sharedb</span><br><span class="line">tar: Removing leading `/<span class="string">' from member names</span></span><br><span class="line"><span class="string">/sharedb/</span></span><br><span class="line"><span class="string">/sharedb/fromsite2_file</span></span><br><span class="line"><span class="string">/sharedb/fromsite1_file</span></span><br><span class="line"><span class="string">/sharedb/fromsite2file</span></span><br><span class="line"><span class="string">/sharedb/site1file</span></span><br><span class="line"><span class="string">➜  ~ docker ps</span></span><br><span class="line"><span class="string">CONTAINER ID        IMAGE               COMMAND             CREATED             STATUS              PORTS               NAMES</span></span><br><span class="line"><span class="string">2207035e4d5c        ubuntu              "/bin/bash"         4 hours ago         Up 2 minutes                            site2</span></span><br><span class="line"><span class="string">350af1aa2bc6        ubuntu              "/bin/bash"         4 hours ago         Up 3 minutes                            site1</span></span><br><span class="line"><span class="string">➜  ~ ls /tmp/backup/sharedb.tar</span></span><br></pre></td></tr></table></figure><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ul><li>创建数据卷</li><li>管理数据卷权限</li><li>挂载宿主机文件</li><li>使用数据卷容器共享数据</li><li>数据卷备份</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Docker中的数据可以存储在类似于虚拟机磁盘的介质中，在Docker中称为&lt;code&gt;数据卷&lt;/code&gt;(Data Volume)。数据卷可以用来存储Docker应用的数据，也可以用来在Docker容器间进行数据共享。数据卷呈现给Docker容器的形式就是一个目录，支持多个容器间共享，修改也不会影响镜像。使用Docker的数据卷，类似在系统中使用&lt;code&gt;mount&lt;/code&gt; 挂载一个文件系统。&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="docker-practice" scheme="http://researchlab.github.io/categories/docker-practice/"/>
    
    
      <category term="docker" scheme="http://researchlab.github.io/tags/docker/"/>
    
  </entry>
  
  <entry>
    <title>docker实践--01 创建docker应用</title>
    <link href="http://researchlab.github.io/2017/03/04/docker-basic-use/"/>
    <id>http://researchlab.github.io/2017/03/04/docker-basic-use/</id>
    <published>2017-03-04T09:05:58.000Z</published>
    <updated>2018-10-18T05:08:14.826Z</updated>
    
    <content type="html"><![CDATA[<p>很早就使用docker了，只是工作上一直没用起来， 加之工作多/杂，就只是断断续续自己瞎折腾，现在打算系统的整理总结一下docker使用经历，这个第一篇主要总结一下几个方面，<br><a id="more"></a></p><ul><li>理解Docker是什么</li><li>学习如何在Linux上安装Docker</li><li>学习如何使用Docker Hub</li><li>创建第一个Docker应用HelloWorld</li><li>Docker基本的容器和镜像管理</li></ul><h2 id="Docker-概念"><a href="#Docker-概念" class="headerlink" title="Docker 概念"></a>Docker 概念</h2><p>对比虚拟化技术，Docker容器与主机共享操作系统内核，不能像虚拟机那样运行独立的内核, 容器比虚拟化更轻量级, 对资源的消耗小很多。容器操作也更快捷，启动和停止都要比虚拟机快。Docker容器技术为使用者提供了更好的容器操作接口, 其中包括一系列的容器，镜像，网络等管理工具，可以让用户简单的创建和使用容器。<br>Docker支持将应用打包进一个可以移植的容器中，重新定义了应用开发，测试，部署上线的过程，核心理念就是<font color="red">Build once, Run anywhere</font>, Docker容器技术的典型应用场景是开发运维上提供持续集成和持续部署的服务。<br>在学习Docker容器技术时，首选要了解什么是<code>镜像</code>, 什么是<code>容器</code>, 什么是<code>仓库</code>等基础概念， 不过在阐述这些概念前推荐先阅读以下两篇文章，</p><ul><li><a href="http://www.infoq.com/cn/articles/docker-core-technology-preview" target="_blank" rel="noopener">深入浅出Docker(一): Docker核心技术预览</a><br>  这篇文章介绍了Docker产生的技术发展历程，Docker中的核心技术以及相关的子项目，非常好的入门资料。</li><li><a href="https://docs.docker.com/engine/understanding-docker/" target="_blank" rel="noopener">了解Docker容器技术的架构设计</a><br>  这篇Docker 官方的文章详细介绍了Docker的运行机制和必要的组件。不涉及到很底层的技术，可以做为对Docker的一个初步了解。</li></ul><p><strong> 什么是镜像? </strong></p><p>Docker的镜像概念类似于虚拟机里的镜像，是一个只读的模板，一个独立的文件系统，包括运行容器所需的数据，可以用来创建新的容器。<br>镜像可以基于Dockerfile构建，Dockerfile是一个描述文件，里面包含若干条命令，每条命令都会对基础文件系统创建新的层次结构。<br>用户可以通过编写Dockerfile创建新的镜像，也可以直接从类似github的Docker Hub上下载镜像使用。</p><p><strong> 什么是容器? </strong></p><p>Docker容器是由Docker镜像创建的运行实例。Docker容器类似虚拟机，可以支持的操作包括启动，停止，删除等。每个容器间是相互隔离的，但隔离的效果比不上虚拟机。容器中会运行特定的应用，包含特定应用的代码及所需的依赖文件。<br>在Docker容器中，每个容器之间的隔离使用Linux的 CGroups 和 Namespaces 技术实现的。其中 CGroups 对CPU，内存，磁盘等资源的访问限制，Namespaces 提供了环境的隔离。</p><p><strong> 什么是仓库? </strong></p><p>使用过git 和 github 就很容易理解Docker的仓库概念。Docker仓库相当于一个 github 上的代码库。<br>Docker 仓库是用来包含镜像的位置，Docker提供一个注册服务器（Registry）来保存多个仓库，每个仓库又可以包含多个具备不同tag的镜像。Docker运行中使用的默认仓库是 Docker Hub 公共仓库。<br>仓库支持的操作类似 git，创建了新的镜像后，我们可以 push 提交到仓库，也可以从指定仓库 pull 拉取镜像到本地。</p><h2 id="安装docker"><a href="#安装docker" class="headerlink" title="安装docker"></a>安装docker</h2><p>安装官方说明在Mac 上安装docker非常简单，直接在官方下载docker for mac的安装程序双击安装即可，安装完后，可以使用<code>docker version</code>查看Docker的版本信息，如我的,<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">er version</span><br><span class="line">Client:</span><br><span class="line"> Version:      17.03.0-ce</span><br><span class="line"> API version:  1.26</span><br><span class="line"> Go version:   go1.7.5</span><br><span class="line"> Git commit:   60ccb22</span><br><span class="line"> Built:        Thu Feb 23 10:40:59 2017</span><br><span class="line"> OS/Arch:      darwin/amd64</span><br><span class="line"></span><br><span class="line">Server:</span><br><span class="line"> Version:      17.03.0-ce</span><br><span class="line"> API version:  1.26 (minimum version 1.12)</span><br><span class="line"> Go version:   go1.7.5</span><br><span class="line"> Git commit:   3a232c8</span><br><span class="line"> Built:        Tue Feb 28 07:52:04 2017</span><br><span class="line"> OS/Arch:      linux/amd64</span><br><span class="line"> Experimental: <span class="literal">true</span></span><br></pre></td></tr></table></figure></p><p>如果可以看到version信息的话，说明docker 已经安装成功了，下面可以尝试执行如下命令，在docker中运行一个nginx 服务器，<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run -d -p 80:80 --name webserver nginx</span><br></pre></td></tr></table></figure></p><p>运行这个命令，docker首先会在本地找nginx:lastest镜像，如果没找到就会自动去<code>Docker Hub</code>公有仓库中去拉一个下来运行，运行上述命令之后， 就启动一个docker 应用nginx服务器了， 通过docker ps 命令查看 当前正在运行的服务器， 可以看到如下,<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">➜  ~ docker ps</span><br><span class="line">CONTAINER ID        IMAGE               COMMAND                  CREATED             STATUS              PORTS                         NAMES</span><br><span class="line">c1760b8f9359        nginx               <span class="string">"nginx -g 'daemon ..."</span>   3 hours ago         Up About an hour    0.0.0.0:80-&gt;80/tcp, 443/tcp   webserver</span><br></pre></td></tr></table></figure></p><blockquote><p>注: 在国内直接运行docker run -d -p 80:80 –name webserver nginx 命令多半会出现xxx Timeout 的提示，因为国内docker Hub站点被强了，所以需要先更换Docker Hub源再运行上述docker run 命令就可以成功，要更换Docker Hub源可以通过DaoCloud公司提供的Docker Hub加速器地址来解决， 具体做法可参考<a href="http://blog.daocloud.io/how-to-master-docker-image/" target="_blank" rel="noopener">how to master docker image</a>; </p></blockquote><p>此时就可以在浏览器中输入<code>http://0.0.0.0/</code>, 看到nginx服务器的欢迎界面咯，</p><center><img src="/2017/03/04/docker-basic-use/hi-nginx.png" alt="webserver-nginx"></center><p>可以通过<code>docker stats</code>命令查看当前所有container的运行状态,<code>docker stats</code> 可以查看到运行状态容器的CPU，内存及网络使用率。在实际工作中，我们通常会把这个命令的输出连接到类似Logstash一类的服务用来分析。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">➜  ~ docker stats</span><br><span class="line">CONTAINER           CPU %               MEM USAGE / LIMIT       MEM %               NET I/O             BLOCK I/O           PIDS</span><br><span class="line">c1760b8f9359        0.00%               1.859 MiB / 1.952 GiB   0.09%               16.1 kB / 4.58 kB   0 B / 0 B           2</span><br><span class="line">CONTAINER           CPU %               MEM USAGE / LIMIT       MEM %               NET I/O             BLOCK I/O           PIDS</span><br><span class="line">c1760b8f9359        0.00%               1.859 MiB / 1.952 GiB   0.09%               16.1 kB / 4.58 kB   0 B / 0 B           2</span><br></pre></td></tr></table></figure></p><p>这个命令的输出是实时刷新的(类似Linux上的top命令），如果需要退出可以使用<code>Ctrl-C</code>组合键。</p><h2 id="创建docker应用"><a href="#创建docker应用" class="headerlink" title="创建docker应用"></a>创建docker应用</h2><p><strong> 需求描述 </strong></p><p>Docker 安装后，下面来创建第一个Docker 应用。这个应用很简单，作用就是输出一句 HelloWorld!。</p><p><strong> 需求分析 </strong></p><p>应用执行的命令是 echo “HelloWorld”，可以为这条命令构建一个运行的容器，让这条命令在容器中运行，运行后容器自动退出。</p><p><strong>  解决方案 </strong></p><p>首先，需要有一个镜像来运行这个应用，这里选择用busybox镜像，直接使用docker run 命令来运行容器<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run busybox <span class="built_in">echo</span> <span class="string">"HelloWorld"</span></span><br></pre></td></tr></table></figure></p><p>首先docker run 会先在本地找busybox 这个镜像，如果找不到就会到Docker Hub上去下载一个下来，然后docker run 命令会基于指定的镜像busyzbox运行一个容器实例，然后把 echo “HelloWorld”命令传递给该容器执行,所以上述命令最终会再屏幕上输出 “HelloWorld”, 如下,<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">➜  ~ docker run busybox <span class="built_in">echo</span> <span class="string">"HelloWorld"</span></span><br><span class="line">Unable to find image <span class="string">'busybox:latest'</span> locally</span><br><span class="line">latest: Pulling from library/busybox</span><br><span class="line">4b0bc1c4050b: Pull complete</span><br><span class="line">Digest: sha256:348432dd709c2cd6ca42e56c2a0d157f611c50c908e14c9bfc1e9cb0ed234871</span><br><span class="line">Status: Downloaded newer image <span class="keyword">for</span> busybox:latest</span><br><span class="line">HelloWorld</span><br></pre></td></tr></table></figure></p><p>执行 docker ps 命令查看运行的容器列表，但看不到任何容器在运行，原因是容器运行了echo 命令后已经终止，进入到停止状态，需要用 docker ps -a 命令查看,<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">➜  ~ docker ps</span><br><span class="line">CONTAINER ID        IMAGE               COMMAND             CREATED             STATUS              PORTS               NAMES</span><br><span class="line">➜  ~ docker ps -a</span><br><span class="line">CONTAINER ID        IMAGE               COMMAND                  CREATED             STATUS                          PORTS               NAMES</span><br><span class="line">65948b8f61eb        busybox             <span class="string">"echo HelloWorld"</span>        About an hour ago   Exited (0) 2 minutes ago                            xenodochial_bohr</span><br></pre></td></tr></table></figure></p><p>在这个命令的输出中我们看到列表里有一个处于 Exited (0) 2 minutes ago 的容器，这个容器表示大约2分钟之前终止。列表中还包括该容器的ID，使用的镜像，执行的命令，创建的时间等信息。最后一个是为容器随机设置的名称，也可以通过run的参数进行设置为指定名称，注意同一个服务器上的容器不可以同名。</p><h2 id="容器管理"><a href="#容器管理" class="headerlink" title="容器管理"></a>容器管理</h2><p>上面通过docker run 命令在指定的镜像中运行一个容器，然后在容器中执行我们的应用程序，下面通过实践来了解docker容器管理中最常用的几个命令,</p><p><strong> 1. 创建运行并容器: docker run </strong></p><p>最主要的是创建运行容器的命令<code>docker run</code>，这个命令的参数非常多，可以通过<code>docker run --help</code> 查看。<br>继续上一节实验，echo 命令运行后容器就退出了，如果我们需要一个保持运行的容器呢，最简单的方法就是给这个容器一个可以保持的应用，比如bash，运行 ubuntu 容器并进入容器的 bash：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run -t -i ubuntu /bin/bash</span><br></pre></td></tr></table></figure></p><p>上面命令的说明：<br><code>-t</code>：分配一个 pseudo-TTY<br><code>-i</code>：–interactive参数缩写，表示交互模式<br><code>ubuntu</code>：运行的镜像名称，默认为latest 标签<br><code>/bin/bash</code>：容器中运行的应用<br>通过这个简单的命令，我们现在进入了新创建容器的bash中，在bash里执行的任何命令都不会影响到我们的宿主机，可以随意操作。你可以看到主机名和环境变量HOSTNAME都已经显示为容器的ID了。在这个bash下，我们可以进行各种Ubuntu系统上的操作，当然因为Docker本身的限制，有些涉及到磁盘、网络、设备等Linux特权命令是无法执行的，可以试试reboot命令，会提示你shutdown: Unable to shutdown system。</p><p>如何退出这个bash呢？有两种方法，两种方法的效果完全不同,</p><ul><li>直接<code>exit</code>，这时候<code>bash</code>程序终止，容器进入到停止状态</li><li>使用组合键退出，仍然保持容器运行，我们可以随时回来到这个bash中来，组合键是<code>Ctrl-p Ctrl-q</code>，你没有看错，是两组组合键，先同时按下Ctrl和p，再按Ctrl和q。就可以退出到我们的宿主机了。</li></ul><p>上述第二种方法比较常用，此时使用<code>docker ps</code> 查看，能看到容器仍然在运行中：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">➜  ~ docker run -t -i ubuntu /bin/bash</span><br><span class="line">Unable to find image <span class="string">'ubuntu:latest'</span> locally</span><br><span class="line">latest: Pulling from library/ubuntu</span><br><span class="line">d54efb8db41d: Pull complete</span><br><span class="line">f8b845f45a87: Pull complete</span><br><span class="line">e8db7bf7c39f: Pull complete</span><br><span class="line">9654c40e9079: Pull complete</span><br><span class="line">6d9ef359eaaa: Pull complete</span><br><span class="line">Digest: sha256:f649e49c1ed34607912626a152efbc23238678af1ac37859b6223ef28e711a3f</span><br><span class="line">Status: Downloaded newer image <span class="keyword">for</span> ubuntu:latest</span><br><span class="line">root@65fc97a6b032:/<span class="comment"># %</span></span><br><span class="line">➜  ~ docker ps</span><br><span class="line">CONTAINER ID        IMAGE               COMMAND             CREATED             STATUS              PORTS               NAMES</span><br><span class="line">65fc97a6b032        ubuntu              <span class="string">"/bin/bash"</span>         About an hour ago   Up 4 minutes                            kickass_goodall</span><br></pre></td></tr></table></figure></p><p>如果想再次回到刚才的bash中，只需要使用<code>docker attach</code>命令就可以再次连接到运行的bash里：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">➜  ~ docker ps</span><br><span class="line">CONTAINER ID        IMAGE               COMMAND             CREATED             STATUS              PORTS               NAMES</span><br><span class="line">65fc97a6b032        ubuntu              <span class="string">"/bin/bash"</span>         About an hour ago   Up 4 minutes                            kickass_goodall</span><br><span class="line">➜  ~ docker attach 65fc9</span><br><span class="line">root@65fc97a6b032:/<span class="comment">#</span></span><br></pre></td></tr></table></figure></p><p><strong> 注意</strong> ：命令后面的参数是容器的ID，并不需要输入完整的数字，只要能唯一定位这个容器即可，通常输入4位就足够了。</p><p><code>docker run</code>命令的执行分一下几步，<br>1.查找镜像或下载镜像<br>2.创建容器<br>3.分配文件系统及虚拟网络（网桥，接口，IP地址），其中容器中的DNS默认挂载宿主机的<code>/etc/resolve.conf</code>和<code>/etc/hosts</code>。<br>4.执行应用, 默认执行镜像中指定的<code>Cmd</code>参数，也可以在<code>docker run</code>后面跟应用来覆盖<code>Cmd</code>命令。</p><p>如果容器中的应用执行完成, 则容器进入到终止状态。</p><p><code>docker run</code>的参数非常多, 假设按如下容器配置设定创建新容器,</p><ul><li>设置容器名称 bash（使用–name，如果不加该参数，Docker会随机产生一个名字）。</li><li>设置容器的主机名 bashHost(使用–hostname参数）</li><li>设定网络信息，这里只使用一个简单的参数设置MAC地址（–mac-address参数）</li><li>设置资源限制，设置容器中最大的进程数，包括soft和hard两个限制值（使用-ulimit nproc=…等参数）</li><li>创建容器过程中也可以挂载数据卷，数据卷在下一节实验中会详细介绍。这里不过多涉及。</li></ul><p>根据上述的需求我们通过查询<code>docker run --help</code>, 使用相关参数, 创建符合要求的容器,<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">➜  docker run --name bash --hostname bashHost --mac-address 00:01:02:03:04:05 --<span class="built_in">ulimit</span> nproc=1024:2048 -t -i ubuntu /bin/bash</span><br></pre></td></tr></table></figure></p><p>进入容器中我们可以对一些参数进行验证,<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">➜  docker run --name bash --hostname bashHost --mac-address 00:01:02:03:04:05 --<span class="built_in">ulimit</span> nproc=1024:2048 -t -i ubuntu /bin/bash</span><br><span class="line">root@bashHost:/<span class="comment"># hostname</span></span><br><span class="line">bashHost</span><br><span class="line">root@bashHost:/<span class="comment"># ulimit</span></span><br><span class="line">unlimited</span><br><span class="line">root@bashHost:/<span class="comment"># % </span></span><br><span class="line">➜  docker inspect -f <span class="string">'&#123;&#123;.HostConfig.Ulimits&#125;&#125;'</span> bash</span><br><span class="line">[nproc=1024:2048]</span><br></pre></td></tr></table></figure></p><p>注，容器中的 ulimit 不会有任何输出，查看实际的ulimit信息可以在宿主机上使用docker inspect查看,</p><p><strong> 2. 查看容器列表: docker ps </strong></p><p><code>docker ps</code>命令用来查看正在运行的容器信息,几个最常用的参数：<br><code>-a</code>：查看所有容器，含停止运行的<br><code>-l</code>：查看刚启动的容器<br><code>-q</code>：只显示容器ID</p><p>例如查看所有容器的ID列表,则执行<code>docker ps -a -q</code>命令即可。</p><p><strong> 3. 查看容器详细信息: docker inspect </strong></p><p>docker inspect 查看容器的细节信息，包括创建时间，操作命令，端口映射信息，IP地址等等。<br>查看Docker容器或镜像的一些内部信息, 默认输出JSON格式的信息，可以通过-f指定输出的项目。 如启动并查看<code>/bin/bash</code>容器,<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">➜  ~ docker start 65fc</span><br><span class="line">65fc</span><br><span class="line">➜  ~ docker inspect 65fc</span><br><span class="line">[</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="string">"Id"</span>: <span class="string">"65fc97a6b0324436f4f9843f06657473d6cf441318937d243b395aff13d6d466"</span>,</span><br><span class="line">        <span class="string">"Created"</span>: <span class="string">"2017-03-05T12:47:04.372874677Z"</span>,</span><br><span class="line">        <span class="string">"Path"</span>: <span class="string">"/bin/bash"</span>,</span><br><span class="line">        <span class="string">"Args"</span>: [],</span><br><span class="line">.....</span><br><span class="line">➜  docker ps -a</span><br><span class="line">CONTAINER ID        IMAGE               COMMAND                  CREATED             STATUS              PORTS               NAMES</span><br><span class="line">d3efa7a729ba        ubuntu              <span class="string">"/bin/bash -c 'whi..."</span>   4 hours ago         Up 6 minutes                            bash</span><br><span class="line">➜  docker inspect -f <span class="string">'&#123;&#123;.NetworkSettings.IPAddress&#125;&#125;'</span> d3ef</span><br><span class="line">172.17.0.2</span><br><span class="line">➜  docker inspect -f <span class="string">'&#123;&#123;.NetworkSettings.Gateway&#125;&#125;'</span> bash</span><br><span class="line">172.17.0.1</span><br></pre></td></tr></table></figure></p><p>返回的信息非常多，是JSON格式，每一项内容具体含义本节不做详细介绍，可以参考官方文档。<br>上述命令中我们查看了网络配置信息中的IP地址和Gateway地址。</p><p><strong> 4. 查看容器内进程信息: docker top </strong></p><p>查看容器中运行的进程信息，显示容器中进程的PID，UID，PPID，时间，tty等信息,<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">➜  ~ docker top 65fc</span><br><span class="line">PID                 USER                TIME                COMMAND</span><br><span class="line">3073                root                0:00                /bin/bash</span><br></pre></td></tr></table></figure></p><p><strong> 5. 查看容器输出信息: docker logs </strong><br>获取容器的输出信息可以使用<code>docker logs</code>命令，使用<code>docker attach</code> 回到刚才创建的<code>/bin/bash容器</code>中，写一个循环输出信息的脚本，然后再使用<code>Ctrl-P Ctrl-Q</code>组合键退出。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">➜  docker run -t -i --name bash ubuntu /bin/bash -c <span class="string">"while true; do echo 'Hello world'; sleep 1; done"</span></span><br></pre></td></tr></table></figure></p><p>在宿主机的终端中，我们可以用<code>docker logs</code>命令查看输出信息。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">➜  docker logs bash</span><br><span class="line">Hello world</span><br><span class="line">Hello world</span><br><span class="line">Hello world</span><br></pre></td></tr></table></figure></p><p><code>docker logs</code>只会显示截止到当前的所有输出，如果想动态查看实时输出，也可以加<code>-f</code>参数，类似<code>tail</code>命令</p><p><strong> 6. 查看容器中的修改: docker diff </strong></p><p><code>docker diff</code> 查看容器中对镜像做了哪些变化。</p><p>先执行<code>docker diff</code> 查看现有的容器中的变化，发现没有任何文件变化, 连接到容器内部，<code>Ctrl-C</code>中断先前实验的死循环,再创建几个文件,退出到宿主机,再次使用docker diff命令查看是否有新的修改<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">➜  docker diff bash</span><br><span class="line">➜  docker attach bash</span><br><span class="line">root@efb833099bb1:/<span class="comment">#</span></span><br><span class="line">root@efb833099bb1:/<span class="comment"># cd tmp/</span></span><br><span class="line">root@efb833099bb1:/tmp<span class="comment"># touch s&#123;1,2,3&#125;</span></span><br><span class="line">root@efb833099bb1:/tmp<span class="comment"># %                                                                                             </span></span><br><span class="line">➜  docker diff bash</span><br><span class="line">C /tmp</span><br><span class="line">A /tmp/s1</span><br><span class="line">A /tmp/s2</span><br><span class="line">A /tmp/s3</span><br><span class="line">➜  docker attach bash</span><br><span class="line">root@efb833099bb1:/tmp<span class="comment">#</span></span><br><span class="line">root@efb833099bb1:/tmp<span class="comment"># rm s1</span></span><br><span class="line">root@efb833099bb1:/tmp<span class="comment"># % </span></span><br><span class="line">➜  docker diff bash</span><br><span class="line">C /tmp</span><br><span class="line">A /tmp/s2</span><br><span class="line">A /tmp/s3</span><br></pre></td></tr></table></figure></p><p>输出的信息中<code>A</code> 表示添加，后面的三个新建文件的路径。可以尝试下修改或删除文件会有怎样的diff输出。</p><p><strong> 7. 容器的守护状态 </strong></p><p>首先需要了解的概念是容器的守护状态，类似于守护进程，需要为<code>run</code>命令增加参数<code>-d</code>，此时容器在后台以守护状态(Daemonized)形式运行。</p><p>创建一个守护状态的容器,<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">➜  docker run --name bash -d ubuntu /bin/bash -c <span class="string">"while true; do echo 'Hello world'; sleep 1; done"</span></span><br></pre></td></tr></table></figure></p><p>会启动一个守护状态的容器在后台运行, 使用<code>docker attach</code> 登录上去可以看到循环输出Hello world 的字符串。</p><p><strong> 8. 停止容器: docker stop </strong></p><p>停止运行状态的容器，进入到终止状态。停止状态的容器可以通过 docker ps -a 查看到。</p><p>首先使用 <code>docker stop container</code> 命令停止名称为container的容器,然后使用docker ps -a 查看容器状态，</p><p><strong> 9. 启动容器: docker start </strong></p><p>启动停止状态的容器。再次启动名称为container的容器,<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker start container</span><br></pre></td></tr></table></figure></p><p><strong> 10. 重启容器: docker restart </strong></p><p>可以将运行状态的容器终止，然后重新启动。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker restart container</span><br></pre></td></tr></table></figure></p><p><strong> 11. 杀死容器: docker kill </strong></p><p>跟进程相同，有的时候正常的终止操作不起作用时，需要使用<code>kill</code>命令杀死进程，在<code>docker kill</code>可以处理异常的运行状态的容器，强制退出, 杀死名为<code>container</code>的容器命令,<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker <span class="built_in">kill</span> container</span><br></pre></td></tr></table></figure></p><p><strong> 12. 暂停和恢复容器: docker pause/unpause </strong></p><p>类似Windows操作系统的睡眠，我们可以先临时将容器的运行挂起，不再使用CPU资源，当需要的时候再恢复成正常的运行状态。<br>先启动容器, 再执行pause操作, 再unpause恢复,<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">docker start container </span><br><span class="line">docker pause container </span><br><span class="line">docker unpause container</span><br></pre></td></tr></table></figure></p><p><strong> 13. 删除容器: docker rm </strong></p><p>当一个容器不再需要时，我们可以删除这个容器。对于停止的容器直接执行<code>docker rm 容器ID</code>, 对于运行状态的容器也可以执行<code>docker rm -f 容器ID强制删除</code>。</p><p>导出和导入容器操作可以将容器导出到压缩包，并可将压缩包导入到Docker系统中成为镜像，为容器的迁移和镜像的制作提供支持。</p><p><strong> 14. 容器导出: docker export </strong></p><p>导出容器快照到本地的tar包。导出后的文件可以拷贝到其他<code>Docker服务器</code>上执行导入命令形成新的镜像，下面选择导出刚才建立的容器new_container到到tar包, 保存到当前目录, 具体命令如下,<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">docker run --name new_container -t -i ubuntu /bin/bash</span><br><span class="line">root@6c8edd28ad65:/<span class="comment"># cd tmp/</span></span><br><span class="line">root@6c8edd28ad65:/tmp<span class="comment"># touch s&#123;1,2,3&#125;</span></span><br><span class="line">root@6c8edd28ad65:/tmp<span class="comment"># ls</span></span><br><span class="line">s1  s2  s3</span><br><span class="line">root@6c8edd28ad65:/tmp<span class="comment"># %                                                                                             </span></span><br><span class="line">➜  docker diff new_container</span><br><span class="line">C /tmp</span><br><span class="line">A /tmp/s1</span><br><span class="line">A /tmp/s2</span><br><span class="line">A /tmp/s3</span><br><span class="line">➜  docker ps -a</span><br><span class="line">CONTAINER ID        IMAGE               COMMAND             CREATED             STATUS              PORTS               NAMES</span><br><span class="line">6c8edd28ad65        ubuntu              <span class="string">"/bin/bash"</span>         4 hours ago         Up 44 seconds                           new_container</span><br><span class="line">➜  docker <span class="built_in">export</span> 6c8e &gt; new_container.tar</span><br><span class="line">➜  ls</span><br><span class="line">Dockerfile        new_container.tar</span><br></pre></td></tr></table></figure></p><blockquote><p>需要注意的是，当容器导出后，容器仍然在Docker环境中运行，只是拷贝了一份内容到tar包。</p></blockquote><p><strong>  15. 容器导入: docker import </strong></p><p>执行导入命令，将该文件加载到docker系统中，文件加载后会成为镜像，命令执行时需要制定导入后生成的镜像的名字,<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cat new_container.tar | docker import new_container:1.0</span><br></pre></td></tr></table></figure></p><p>执行导入后，使用docker images 查看是否有新的镜像产生,<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">➜  docker images</span><br><span class="line">REPOSITORY          TAG                 IMAGE ID            CREATED             SIZE</span><br><span class="line">nginx               latest              6b914bbcb89e        6 days ago          182 MB</span><br><span class="line">ubuntu              latest              0ef2e08ed3fa        6 days ago          130 MB</span><br><span class="line">busybox             latest              7968321274dc        7 weeks ago         1.11 MB</span><br><span class="line">➜  cat new_container.tar| docker import - new_container:1.0</span><br><span class="line">sha256:dd10880b0d88c4d4159c3c29c034d46dc52c5d8d9d52ee5385aff687d0967216</span><br><span class="line">➜  docker images</span><br><span class="line">REPOSITORY          TAG                 IMAGE ID            CREATED             SIZE</span><br><span class="line">new_container       1.0                 dd10880b0d88        4 hours ago         111 MB</span><br><span class="line">nginx               latest              6b914bbcb89e        6 days ago          182 MB</span><br><span class="line">ubuntu              latest              0ef2e08ed3fa        6 days ago          130 MB</span><br><span class="line">busybox             latest              7968321274dc        7 weeks ago         1.11 MB</span><br></pre></td></tr></table></figure></p><p>docker import 命令比较灵活，也可以直接从URL链接进行导入。所以可以记住这是一种创建镜像的方式，将容器导出后拷贝到目标服务器然后导入成镜像。</p><p>使用新镜像创建容器，查看是否与导出的容器内容一致,<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">➜  docker run --name new_new_container -t -i new_container:1.0 /bin/bash</span><br><span class="line">root@eeef608f020b:/<span class="comment"># cd tmp/</span></span><br><span class="line">root@eeef608f020b:/tmp<span class="comment"># ls</span></span><br><span class="line">s1  s2  s3</span><br><span class="line">root@eeef608f020b:/tmp<span class="comment">#</span></span><br></pre></td></tr></table></figure></p><h2 id="镜像管理"><a href="#镜像管理" class="headerlink" title="镜像管理"></a>镜像管理</h2><p>先来简单了解一下镜像管理的基本概念,</p><p><strong> 查看镜像列表 </strong></p><p><code>docker images</code> 命令可以列出当前系统上所有的镜像信息,<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">➜  ~ docker images</span><br><span class="line">REPOSITORY          TAG                 IMAGE ID            CREATED             SIZE</span><br><span class="line">nginx               latest              6b914bbcb89e        4 days ago          182 MB</span><br><span class="line">ubuntu              latest              0ef2e08ed3fa        5 days ago          130 MB</span><br><span class="line">busybox             latest              7968321274dc        7 weeks ago         1.11 MB</span><br></pre></td></tr></table></figure></p><p>其中：<br><code>REPOSITORY</code>：仓库名称<br><code>TAG</code>：标签名，一个仓库可以有若干个标签对应不同的镜像，默认都是latest<br><code>IMAGE ID</code>：镜像ID<br><code>CREATED</code>：创建时间，注意不是本地的pull时间<br><code>SIZE</code>：镜像大小</p><p><strong> 获取镜像 </strong></p><p>最简单的获取镜像的方式是从 Docker Hub上 pull 最新的镜像，比如我们想要一个<code>busybox</code> 的镜像，直接使用命令<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker pull busybox</span><br></pre></td></tr></table></figure></p><p><strong> 创建镜像 </strong></p><p>最常用的是写一个<code>Dockerfile</code>，从<code>Dockerfile</code>里创建新的镜像。<br><code>Dockerfile</code>的详细编写方法我们后续有专门的实验介绍，此处只写一个最简单的<code>Dockerfile</code>来介绍。<br>使用vim打开一个文件<code>Dockerfile</code>, 写入如下两行保存,<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">from ubuntu:latest</span><br><span class="line">ENV HOSTNAME=HelloWorld</span><br></pre></td></tr></table></figure></p><p>这个<code>Dockerfile</code> 中只有两行，<br>第一行表示基于哪个镜像创建新的镜像，类似于程序开发中的<code>import</code> 或<code>include</code>，这里以<code>ubuntu:latest</code>镜像为基础创建新的镜像。第二行是在新的镜像中我们要对基础镜像 ubuntu:latest 做的改变。这句是设置一个环境变量HOSTNAME等于HelloWorld。完成<code>Dockerfile</code> 后，使用<code>docker build</code> 命令进行构建：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker build -t hellworld .</span><br></pre></td></tr></table></figure></p><p>这个命令中第一个参数<code>-t helloworld</code>指定创建的新镜像的名字，第二个参数是一个点 <code>.</code> 指定从当前目录查找<code>Dockerfile</code> 文件，编译结果如图,<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">➜  docker build -t HelloWorld .</span><br><span class="line">invalid argument <span class="string">"HelloWorld"</span> <span class="keyword">for</span> t: Error parsing reference: <span class="string">"HelloWorld"</span> is not a valid repository/tag: repository name must be lowercase</span><br><span class="line">See <span class="string">'docker build --help'</span>.</span><br><span class="line">➜  docker build -t helloworld .</span><br><span class="line">Sending build context to Docker daemon 2.048 kB</span><br><span class="line">Step 1/2 : FROM ubuntu:latest</span><br><span class="line"> ---&gt; 0ef2e08ed3fa</span><br><span class="line">Step 2/2 : ENV HOSTNAME HelloWorld</span><br><span class="line"> ---&gt; Running <span class="keyword">in</span> d0f16b14164e</span><br><span class="line"> ---&gt; de0c24b4dc2e</span><br><span class="line">Removing intermediate container d0f16b14164e</span><br><span class="line">Successfully built de0c24b4dc2e</span><br></pre></td></tr></table></figure></p><p>如结果所示，镜像名必须小写。执行<code>docker images</code> 命令就可以看到新的<code>helloworld</code>镜像了。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">➜  docker images</span><br><span class="line">REPOSITORY          TAG                 IMAGE ID            CREATED             SIZE</span><br><span class="line">helloworld          latest              de0c24b4dc2e        About an hour ago   130 MB</span><br><span class="line">nginx               latest              6b914bbcb89e        4 days ago          182 MB</span><br><span class="line">ubuntu              latest              0ef2e08ed3fa        5 days ago          130 MB</span><br><span class="line">busybox             latest              7968321274dc        7 weeks ago         1.11 MB</span><br><span class="line">➜  docker run -t -i helloworld /bin/bash</span><br><span class="line">root@3ce776c1ee74:/<span class="comment"># echo $HOSTNAME</span></span><br><span class="line">HelloWorld</span><br><span class="line">root@3ce776c1ee74:/<span class="comment">#</span></span><br></pre></td></tr></table></figure></p><p>上述结果知, 通过<code>docker run</code>命令运行新的镜像，然后通过<code>echo $HOSTNAME</code> 果然是之前设置的<code>HelloWorld</code>名称。</p><p><strong> 清理镜像 </strong></p><p>通过命令退出上述<code>helloworld</code>容器后，可使用<code>docker rm</code> 命令删除容器，并使用<code>docker rmi</code> 删除镜像。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">➜  docker rm -f 3ce7</span><br><span class="line">3ce7</span><br><span class="line">➜  docker rmi helloworld</span><br><span class="line">Untagged: helloworld:latest</span><br><span class="line">Deleted: sha256:de0c24b4dc2ee6512b8c95d15b532b162dc883c7e5caf8aa00939fa5712fb7d1</span><br></pre></td></tr></table></figure></p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ul><li>理解Docker是什么</li><li>学习如何在Mac上安装Docker</li><li>学习如何使用Docker Hub</li><li>创建第一个HelloWorld 的Docker应用</li><li>Docker基本的容器和镜像管理</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;很早就使用docker了，只是工作上一直没用起来， 加之工作多/杂，就只是断断续续自己瞎折腾，现在打算系统的整理总结一下docker使用经历，这个第一篇主要总结一下几个方面，&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="docker-practice" scheme="http://researchlab.github.io/categories/docker-practice/"/>
    
    
      <category term="docker" scheme="http://researchlab.github.io/tags/docker/"/>
    
  </entry>
  
  <entry>
    <title>基于fzzy/radix/redis封装新的redispool</title>
    <link href="http://researchlab.github.io/2017/03/02/redispool-baseon-fzzy-radix/"/>
    <id>http://researchlab.github.io/2017/03/02/redispool-baseon-fzzy-radix/</id>
    <published>2017-03-02T14:42:42.000Z</published>
    <updated>2018-10-18T05:08:14.838Z</updated>
    
    <content type="html"><![CDATA[<p>之前的老项目的redis client sdk 直接大名鼎鼎的<code>github.com/fzzy/radix</code>提供的<code>redis client</code> 和<code>redis pool</code>, 当访问峰值达到一定的值后会出现<code>too many open files</code>等tcp连接错误，同时也没有直接提供authorization 密钥认证的接口，为满足这些新需求基于<code>fzzy/radix</code>封装出的新的<code>redispool</code>, 已投入生产使用半年来暂无问题，本文总结如下,<br><a id="more"></a></p><h2 id="auth认证"><a href="#auth认证" class="headerlink" title="auth认证"></a>auth认证</h2><p>如果redis server 需要密钥访问的话，每新建一个client 连接后都需要先通过authorization认证之后才能被使用，如果每次都通过新建一个redis client 再oauth认证来用显然没什么问题，但对于要频繁进行redis操作的系统而言，最好采用redis pool 的办法来解决，用redis conn 池本来也很好解决， 就是在新建redis conn pool时 每新建一个redis client就auth认证一下然后再保存起来就可以使用了，并且这个连接以后都不需要在进行auth认证了。<br>如果redis pool在新建之后就固定的话， 是可以如上面这么简单的，但是采用的<code>fzzy/radix</code>包在实现的方案是可根据需要自动伸缩地新建redis client conn,之前设置的redis 连接池的大小其实是最小的空闲连接池，当业务需求需要的redis client连接数大于pool中的数目时则会通过redis.Dial()的方法新建一个redis client conn 以满足业务的需求，即在建立redis连接池的时候auth认证的redis client conn 和最后回到pool池中的redis client conn 可能就不是同一个client了，因为当新的redis client conn 塞满redis 连接池后 之前auth认证过的旧的redis client conn就会被Close关闭到而不再回到pool池中，具体实现如下:<br><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p *RedisPool)</span> <span class="title">getRedisClient</span><span class="params">()</span> <span class="params">(*redis.Client, error)</span></span> &#123;</span><br><span class="line">client, err := redis.Dial(p.network, p.addr)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span>, err</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> <span class="built_in">len</span>(p.pwd) != <span class="number">0</span> &#123;</span><br><span class="line"><span class="keyword">if</span> client, err = p.redisAuth(client); err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span>, err</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> client, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p *RedisPool)</span> <span class="title">redisAuth</span><span class="params">(client *redis.Client)</span> <span class="params">(*redis.Client, error)</span></span> &#123;</span><br><span class="line"><span class="keyword">if</span> _, err := client.Cmd(<span class="string">"AUTH"</span>, p.pwd).Str(); err != <span class="literal">nil</span> &#123;</span><br><span class="line">client.Close()</span><br><span class="line"><span class="keyword">return</span> client, err</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> client, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>上述代码提供了一个redisAuth方法来提供auth认证，这样不管是通过新建redis池还是当池中redis client conn耗尽之后单独新建的redis client 都通过上述提供getRedisClient()方法来获取新建的redis client conn ,这样便可保证每次新建的redis client conn 都是通过auth认证的(当然上次实现的时候如果没有设置密码，则不进行密钥认证，只有设置了密钥才会调用auth进行认证授权)。</p><h2 id="qps限制"><a href="#qps限制" class="headerlink" title="qps限制"></a>qps限制</h2><p>因为<code>fzzy/radix</code>包当初始化创建的redis 连接池中的redis client 耗尽后会通过redis.Dial()方法新建一个redis.client, 如果在某一个峰值redis连接池耗尽的同时大量新建redis.client 而不能及时Close掉这些redis.Client,则后继再redis.Dial()新建的redis client conn 就会因为受系统限制无法分配文件句柄地址而报”too many open files”错误。具体试验可以先限制redis连接池为100, 然后同时发起10w redis 连接请求， 可以通过下面的命令观察到当redis client conn最大分配的大小，超过之后程序也会崩掉。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">watch -n 1 <span class="string">"redis-cli -h localhost -p 6379 -a 123456 client list | wc -l"</span> <span class="comment"># redis client 连接数</span></span><br><span class="line">watch -n 1 <span class="string">"lsof -i:6379 | wc -l "</span> <span class="comment"># redis tcp 连接数</span></span><br></pre></td></tr></table></figure></p><p>上述命令可以动态看到每一秒内当前的redis client 连接数目 和 tcp 连接数</p><p>显然程序不能仍由业务需求无限的取申请redis client 连接数， 本文设计通过每次成功Get到一个redis client时 则通过<code>sync/atomic</code>包原子的给qps新增一 进行计数，当Put到池或Empty全部清空时则进行减一 计数操作, 具体实现如下,<br><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Retrieves an available redis client. If there are none available it will</span></span><br><span class="line"><span class="comment">// create a new one on the fly</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p *RedisPool)</span> <span class="title">Get</span><span class="params">()</span> <span class="params">(client *redis.Client, err error)</span></span> &#123;</span><br><span class="line"><span class="keyword">if</span> p.qpsLimit &gt; <span class="number">0</span> &#123;</span><br><span class="line"><span class="keyword">for</span> p.qps &gt; p.qpsLimit &#123;</span><br><span class="line">time.Sleep(time.Millisecond * time.Duration(<span class="number">10</span>))</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">3</span>; i++ &#123;</span><br><span class="line"><span class="keyword">if</span> client, err = p.get(); err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">break</span></span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> pstate, perr := client.Cmd(<span class="string">"PING"</span>).Str(); pstate == <span class="string">"PONG"</span> &amp;&amp; perr == <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">break</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> err == <span class="literal">nil</span> &#123;</span><br><span class="line">atomic.AddInt32(&amp;p.qps, <span class="number">1</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Returns a client back to the pool. If the pool is full the client is closed</span></span><br><span class="line"><span class="comment">// instead. If the client is already closed (due to connection failure or</span></span><br><span class="line"><span class="comment">// what-have-you) it should not be put back in the pool. The pool will create</span></span><br><span class="line"><span class="comment">// more connections as needed.</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p *RedisPool)</span> <span class="title">Put</span><span class="params">(conn *redis.Client)</span></span> &#123;</span><br><span class="line"><span class="keyword">select</span> &#123;</span><br><span class="line"><span class="keyword">case</span> p.pool &lt;- conn:</span><br><span class="line"><span class="keyword">default</span>:</span><br><span class="line">conn.Close()</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> p.qps &gt; <span class="number">0</span> &#123;</span><br><span class="line">atomic.AddInt32(&amp;p.qps, <span class="number">-1</span>)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Removes and calls Close() on all the connections currently in the pool.</span></span><br><span class="line"><span class="comment">// Assuming there are no other connections waiting to be Put back this method</span></span><br><span class="line"><span class="comment">// effectively closes and cleans up the pool.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p *RedisPool)</span> <span class="title">Empty</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">var</span> conn *redis.Client</span><br><span class="line"><span class="keyword">for</span> &#123;</span><br><span class="line"><span class="keyword">select</span> &#123;</span><br><span class="line"><span class="keyword">case</span> conn = &lt;-p.pool:</span><br><span class="line">conn.Close()</span><br><span class="line"><span class="keyword">default</span>:</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> p.qps &gt; <span class="number">0</span> &#123;</span><br><span class="line">atomic.AddInt32(&amp;p.qps, <span class="number">-1</span>)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>完整的代码设计及测试代码请参见: <a href="https://github.com/researchlab/experiments/tree/master/redispool" target="_blank" rel="noopener">https://github.com/researchlab/experiments/tree/master/redispool</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;之前的老项目的redis client sdk 直接大名鼎鼎的&lt;code&gt;github.com/fzzy/radix&lt;/code&gt;提供的&lt;code&gt;redis client&lt;/code&gt; 和&lt;code&gt;redis pool&lt;/code&gt;, 当访问峰值达到一定的值后会出现&lt;code&gt;too many open files&lt;/code&gt;等tcp连接错误，同时也没有直接提供authorization 密钥认证的接口，为满足这些新需求基于&lt;code&gt;fzzy/radix&lt;/code&gt;封装出的新的&lt;code&gt;redispool&lt;/code&gt;, 已投入生产使用半年来暂无问题，本文总结如下,&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="golang" scheme="http://researchlab.github.io/categories/golang/"/>
    
    
      <category term="golang" scheme="http://researchlab.github.io/tags/golang/"/>
    
      <category term="redispool" scheme="http://researchlab.github.io/tags/redispool/"/>
    
  </entry>
  
  <entry>
    <title>beego/orm使用总结</title>
    <link href="http://researchlab.github.io/2017/03/01/use-beego-orm-summary/"/>
    <id>http://researchlab.github.io/2017/03/01/use-beego-orm-summary/</id>
    <published>2017-03-01T10:44:29.000Z</published>
    <updated>2018-10-18T05:08:14.838Z</updated>
    
    <content type="html"><![CDATA[<p>很早之前的一个老项目就使用过ORM，当时使用的是<code>xorm</code>，后来新的项目设计说考虑性能什么的又用写原生sql来做了，在项目中使用一直没什么问题， 但是代码中到处写着原生的sql语句,并且有很多重复的语句，很不好维护，于是最近又重新考虑采用orm的方式来操作数据库，最近看中<code>beego/orm</code>这个包， 它的官方文档也写了很详细的使用说明，下面还是简要总结一下自己在项目中的使用经历,<br><a id="more"></a></p><h2 id="ORM"><a href="#ORM" class="headerlink" title="ORM"></a>ORM</h2><p>ORM, 即Object-Relational Mapping(对象关系映射)，它的作用是在关系型数据库和业务实体对象之间作一个映射，这样在具体的操作业务对象的时候，就不需要再去和复杂的SQL语句打交道，只需简单的操作对象的属性和方法。</p><p><strong> 优势 </strong> </p><ul><li><p>隐藏了数据访问细节，也是ORM的核心所在, “封闭”的通用数据库交互。使数据库交互变得简单易行，并且完全不用考虑SQL语句。快速开发，由此而来。</p></li><li><p>ORM使构造固化数据结构变得简单易行。在使用ORM之前, 需要将对象模型转化为一条一条的SQL语句，通过直连或是DB helper在关系数据库构造想要的数据库体系。而基本上所有的ORM框架都提供了通过对象模型构造关系数据库结构的功能。</p></li></ul><p>ORM有优势也存在缺点，</p><p><strong> 缺点 </strong></p><ul><li><p>无可避免的，自动化意味着映射和关联管理，代价是牺牲性能(早期，这是所有不喜欢ORM人的共同点)。现各种ORM框架都在尝试使用各种方法来减轻这块(LazyLoad，Cache),效果还是很显著的。</p></li><li><p>面向对象的查询语言(X-QL)作为一种数据库与对象之间的过渡, 虽然隐藏了数据层面的业务抽象, 但并不能完全的屏蔽掉数据库层的设计, 并且无疑将增加学习成本。</p></li><li><p>对于复杂查询，ORM仍然力不从心。虽然可以实现，但是不值的。视图可以解决大部分calculated column，case，group，having, order by, exists，但是查询条件(a and b and not c and (d or d))。</p></li></ul><p>从ORM优缺点来看， ORM适合使用在较大型复杂的系统中或数据库操作很多的系统中， 当即便使用了ORM的复杂项目在特殊情况下也应考虑用原生SQL来解决复杂查询和性能问题，小的项目则看性能苛刻来考虑了，如果性能苛刻则用原生的SQL实现更合适，如果没有什么要求则用不用ORM都没啥关系。</p><h2 id="beego-orm-使用"><a href="#beego-orm-使用" class="headerlink" title="beego/orm 使用"></a>beego/orm 使用</h2><p>据beego/orm官方文档说明目前其还处在开发中只支持<code>MySQL</code>,<code>PostgreSQL</code>, <code>Sqlite3</code>三种数据库驱动，目前beego/orm包支持以下特性,</p><ul><li>支持 Go 的所有类型存储</li><li>轻松上手，采用简单的 CRUD 风格</li><li>自动 Join 关联表</li><li>跨数据库兼容查询</li><li>允许直接使用 SQL 查询／映射</li><li>严格完整的测试保证 ORM 的稳定与健壮</li></ul><p>官方使用案例,<br><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">"fmt"</span></span><br><span class="line"></span><br><span class="line"><span class="string">"github.com/astaxie/beego/orm"</span></span><br><span class="line">_ <span class="string">"github.com/go-sql-driver/mysql"</span> <span class="comment">//import your used driver</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">// Model Struct</span></span><br><span class="line"><span class="keyword">type</span> User <span class="keyword">struct</span> &#123;</span><br><span class="line">Id   <span class="keyword">int</span></span><br><span class="line">Name <span class="keyword">string</span> <span class="string">`orm:"size(100)"`</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">init</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="comment">// set default database</span></span><br><span class="line">orm.RegisterDataBase(<span class="string">"default"</span>, <span class="string">"mysql"</span>, <span class="string">"root:123456@/my_db?charset=utf8"</span>, <span class="number">30</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// register model</span></span><br><span class="line">orm.RegisterModel(<span class="built_in">new</span>(User))</span><br><span class="line"></span><br><span class="line"><span class="comment">// create table</span></span><br><span class="line">orm.RunSyncdb(<span class="string">"default"</span>, <span class="literal">false</span>, <span class="literal">true</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">o := orm.NewOrm()</span><br><span class="line"></span><br><span class="line">user := User&#123;Name: <span class="string">"slene"</span>&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// insert</span></span><br><span class="line">id, err := o.Insert(&amp;user)</span><br><span class="line">fmt.Printf(<span class="string">"ID: %d, ERR: %v\n"</span>, id, err)</span><br><span class="line"></span><br><span class="line"><span class="comment">// update</span></span><br><span class="line">user.Name = <span class="string">"astaxie"</span></span><br><span class="line">num, err := o.Update(&amp;user)</span><br><span class="line">fmt.Printf(<span class="string">"NUM: %d, ERR: %v\n"</span>, num, err)</span><br><span class="line"></span><br><span class="line"><span class="comment">// read one</span></span><br><span class="line">u := User&#123;Id: user.Id&#125;</span><br><span class="line">err = o.Read(&amp;u)</span><br><span class="line">fmt.Printf(<span class="string">"ERR: %v\n"</span>, err)</span><br><span class="line">fmt.Println(<span class="string">"u:"</span>, u)</span><br><span class="line"></span><br><span class="line"><span class="comment">// delete</span></span><br><span class="line">num, err = o.Delete(&amp;u)</span><br><span class="line">fmt.Printf(<span class="string">"NUM: %d, ERR: %v\n"</span>, num, err)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>从上述代码可知，使用ORM大致分以下几步，<br>1.注册数据库;<br>2.注册待使用的数据库表结构对象;<br>3.在数据库中生成上述注册的数据库表结构对象;<br>4.得到一个待操作ORMER对象;<br>5.用上述的得到ORMER对象即可对数据库进行CURD操作了。</p><p>可以看到整个过程几乎不用写SQL语句， 并且逻辑清晰，当然性能方面跟直接用原生的SQL语句写肯定要差一些，因为beego/orm源码里面为了判断数据类型/转换数据类型等用了很多反射/强转等操作，这样做虽然是为了最大限度兼容各类数据操作，但对于本就不涉及复杂繁多的SQL的系统而言， 还是多考虑用原生SQL语句来写了。</p><p>下面是工作中应用抽取出来的一个代码片段，<br><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">"log"</span></span><br><span class="line"><span class="string">"strconv"</span></span><br><span class="line"><span class="string">"sync"</span></span><br><span class="line"><span class="string">"time"</span></span><br><span class="line"></span><br><span class="line"><span class="string">"github.com/astaxie/beego/orm"</span></span><br><span class="line">_ <span class="string">"github.com/go-sql-driver/mysql"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> (</span><br><span class="line">DEBUG = <span class="literal">true</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> db orm.Ormer</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">init</span><span class="params">()</span></span> &#123;</span><br><span class="line">orm.RegisterDriver(<span class="string">"mysql"</span>, orm.DRMySQL)</span><br><span class="line">err := orm.RegisterDataBase(<span class="string">"default"</span>, <span class="string">"mysql"</span>, *dsn)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">log.Fatalf(<span class="string">"connect database error: %v\n"</span>, err)</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">log.Println(<span class="string">"connect db success"</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">orm.RegisterModel(<span class="built_in">new</span>(Record))</span><br><span class="line"></span><br><span class="line">err = orm.RunSyncdb(<span class="string">"default"</span>, <span class="literal">false</span>, <span class="literal">false</span>)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">log.Fatalf(err)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">db = orm.NewOrm()</span><br><span class="line"><span class="keyword">if</span> DEBUG &#123;</span><br><span class="line">orm.Debug = <span class="literal">true</span></span><br><span class="line">&#125;</span><br><span class="line">recordsChan = <span class="built_in">make</span>(<span class="keyword">chan</span> *Record, *insertBatchNum)</span><br><span class="line">recordInsterLoop(done)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">GetDB</span><span class="params">()</span> <span class="title">orm</span>.<span class="title">Ormer</span></span> &#123;</span><br><span class="line"><span class="keyword">return</span> db</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">newRecord</span><span class="params">(param *requestParameter, resp *responseData)</span> *<span class="title">Record</span></span> &#123;</span><br><span class="line">r := <span class="built_in">new</span>(Record)</span><br><span class="line">r.Src = param.values.Get(<span class="string">"src"</span>)</span><br><span class="line">r.OpenID = param.values.Get(<span class="string">"openid"</span>)</span><br><span class="line">r.IdempotentStr = param.values.Get(<span class="string">"idempotent_str"</span>)</span><br><span class="line">r.Noncestr = param.values.Get(<span class="string">"noncestr"</span>)</span><br><span class="line">r.ReqTimestamp, _ = strconv.Atoi(param.values.Get(<span class="string">"timestamp"</span>))</span><br><span class="line">r.ActivityID, _ = strconv.Atoi(param.values.Get(<span class="string">"activity_id"</span>))</span><br><span class="line">r.BatchID, _ = strconv.Atoi(param.values.Get(<span class="string">"batch_id"</span>))</span><br><span class="line">r.Sign = param.values.Get(<span class="string">"sign"</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> resp != <span class="literal">nil</span> &#123;</span><br><span class="line">r.ErrorCode = resp.ErrorCode</span><br><span class="line">r.ErrorMsg = resp.ErrorMsg</span><br><span class="line"><span class="keyword">if</span> resp.Timestamp == <span class="number">0</span> &#123;</span><br><span class="line">r.RespTimestamp = <span class="keyword">int</span>(time.Now().Unix())</span><br><span class="line">&#125;</span><br><span class="line">r.CouponID = resp.CouponID</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> r</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Record <span class="keyword">struct</span> &#123;</span><br><span class="line">ID            <span class="keyword">int</span>    <span class="string">`orm:"column(id)" json:"record_id"`</span></span><br><span class="line">Src           <span class="keyword">string</span> <span class="string">`json:"str"`</span></span><br><span class="line">OpenID        <span class="keyword">string</span> <span class="string">`orm:"column(open_id)" json:"open_id"`</span></span><br><span class="line">IdempotentStr <span class="keyword">string</span> <span class="string">`json:"idempotent_str"`</span></span><br><span class="line">Noncestr      <span class="keyword">string</span> <span class="string">`json:"noncestr"`</span></span><br><span class="line">ReqTimestamp  <span class="keyword">int</span>    <span class="string">`json:"req_timestamp"`</span></span><br><span class="line">ActivityID    <span class="keyword">int</span>    <span class="string">`orm:"column(activity_id)" json:"activity_id"`</span></span><br><span class="line">BatchID       <span class="keyword">int</span>    <span class="string">`orm:"column(batch_id)" json:"batch_id"`</span></span><br><span class="line">Sign          <span class="keyword">string</span> <span class="string">`json:"sign"`</span></span><br><span class="line">ErrorCode     <span class="keyword">int</span>    <span class="string">`json:"error_code"`</span></span><br><span class="line">ErrorMsg      <span class="keyword">string</span> <span class="string">`json:"error_msg"`</span></span><br><span class="line">RespTimestamp <span class="keyword">int</span>    <span class="string">`json:"resp_timestamp"`</span></span><br><span class="line">CouponID      <span class="keyword">int</span>    <span class="string">`orm:"column(coupon_id)" json:"coupon_id"`</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(Record)</span> <span class="title">TableName</span><span class="params">()</span> <span class="title">string</span></span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="string">"records"</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> recordsChan <span class="keyword">chan</span> *Record</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(r *Record)</span> <span class="title">InsertRecord</span><span class="params">()</span></span> &#123;</span><br><span class="line">recordsChan &lt;- r</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">recordInsterLoop</span><span class="params">(done &lt;-<span class="keyword">chan</span> <span class="keyword">bool</span>)</span></span> &#123;</span><br><span class="line"><span class="keyword">var</span> mu sync.Mutex</span><br><span class="line"><span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">records := <span class="built_in">make</span>([]*Record, <span class="number">0</span>, *insertBatchNum)</span><br><span class="line"><span class="keyword">for</span> &#123;</span><br><span class="line"><span class="keyword">select</span> &#123;</span><br><span class="line"><span class="keyword">case</span> &lt;-done:</span><br><span class="line">recordCopy, recordLen := Copyrecode(records)</span><br><span class="line">insertMulti(recordLen, recordCopy)</span><br><span class="line"></span><br><span class="line"><span class="keyword">case</span> &lt;-time.After(time.Duration(<span class="number">5</span>) * time.Second):</span><br><span class="line"></span><br><span class="line">recordCopy, recordLen := Copyrecode(records)</span><br><span class="line">insertMulti(recordLen, recordCopy)</span><br><span class="line"></span><br><span class="line"><span class="keyword">case</span> r := &lt;-recordsChan:</span><br><span class="line">records = <span class="built_in">append</span>(records, r)</span><br><span class="line">recordLen := <span class="built_in">len</span>(records)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> recordLen &gt;= *insertBatchNum &#123;</span><br><span class="line">recordCopy, recordLen := Copyrecode(records)</span><br><span class="line">insertMulti(recordLen, recordCopy)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">close</span>(recordsChan)</span><br><span class="line">&#125;()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Copyrecode</span><span class="params">(records []*Record)</span> <span class="params">(recordCopy []*Record, recordLen <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">mu.Lock()</span><br><span class="line">recordLen = <span class="built_in">len</span>(records)</span><br><span class="line">recordCopy = <span class="built_in">make</span>([]*Record, recordLen)</span><br><span class="line"><span class="built_in">copy</span>(recordCopy, records)</span><br><span class="line">records = <span class="built_in">make</span>([]*Record, <span class="number">0</span>, *insertBatchNum)</span><br><span class="line">mu.Unlock()</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">insertMulti</span><span class="params">(n <span class="keyword">int</span>, rs []*Record)</span> <span class="params">(<span class="keyword">int64</span>, error)</span></span> &#123;</span><br><span class="line"><span class="keyword">return</span> GetDB().InsertMulti(n, rs)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>上述代码就是用ORM将数据插入到指定数据库表中，实现过程考虑到了数据插入超时及强制退出时将records中预留的数据插入数据库一定程度上保证数据不丢失。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;很早之前的一个老项目就使用过ORM，当时使用的是&lt;code&gt;xorm&lt;/code&gt;，后来新的项目设计说考虑性能什么的又用写原生sql来做了，在项目中使用一直没什么问题， 但是代码中到处写着原生的sql语句,并且有很多重复的语句，很不好维护，于是最近又重新考虑采用orm的方式来操作数据库，最近看中&lt;code&gt;beego/orm&lt;/code&gt;这个包， 它的官方文档也写了很详细的使用说明，下面还是简要总结一下自己在项目中的使用经历,&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="golang" scheme="http://researchlab.github.io/categories/golang/"/>
    
    
      <category term="golang" scheme="http://researchlab.github.io/tags/golang/"/>
    
      <category term="beego/orm" scheme="http://researchlab.github.io/tags/beego-orm/"/>
    
  </entry>
  
  <entry>
    <title>mysql 数据库表及数据导入导出方法总结</title>
    <link href="http://researchlab.github.io/2017/02/22/mysql-import-export-summary/"/>
    <id>http://researchlab.github.io/2017/02/22/mysql-import-export-summary/</id>
    <published>2017-02-22T10:50:36.000Z</published>
    <updated>2018-10-18T05:08:14.834Z</updated>
    
    <content type="html"><![CDATA[<p>由于公司的MySQL是搭建在服务器上，为了避免对服务器进行直接改动，想远程导出和导入MySQL的数据库表结构及数据进行操作, 刚好Mysql本身提供了命令行导出工具<code>Mysqldump</code>和<code>Mysql Source</code>导入命令进行SQL数据导入导出工作，通过Mysql命令行导出工具Mysqldump命令能够将Mysql数据导出为文本格式(txt)的SQL文件，通过Mysql Source命令能够将SQL文件导入Mysql数据库中，下面通过Mysql导入导出SQL实例详解Mysqldump和Source命令的用法</p><a id="more"></a><h2 id="数据库表及数据导出"><a href="#数据库表及数据导出" class="headerlink" title="数据库表及数据导出"></a>数据库表及数据导出</h2><p>需求说明是要希望导出整个数据库结构脚本，而MySQL提供的Mysqldump命令刚好可达到此目的而且还可以将数据库中的数据也一并导出，</p><p><strong> mysqldump导出语法以及实践 </strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mysqldump -h&#123;hostname&#125; [-P&#123;port&#125;] -u&#123;username&#125; -p&#123;password&#125; [--default-character-set=charset] database [tablename] &gt; &#123;you file path&#125;</span><br><span class="line"><span class="comment"># 注:-h和[hostname]之间并没有空格相连, 后同之, []扩起来的为可选项, 可不填</span></span><br></pre></td></tr></table></figure><ul><li>hostname表示主机名, 本地则填localhost, 远程则填写你的远程IP, 如192.168.0.3;</li><li>username是你的MySQL登录帐号, password则是登录密码;</li><li>default-character-set则是你的字符集编码, 如gb2312、gbk和utf8(没有横杠哦);</li><li>dbname是你的数据库名称, tablename是你的表名, 假如你不填写tablename的话则默认导出所有的表。</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysqldump -h192.168.0.3 -P3307 -uroot -p123456 --default-character-set=utf8  crm_adapter &gt; ./crm_adapter_db.sql</span><br></pre></td></tr></table></figure><p>通过上面的导出语句, 将会在当前目录下面创建一个crm_adapter_db.sql脚本文件, 这个脚本文件是可运行的, 它包含了crm_adapter数据库中所有数据表的建表细节以及其所有的数据。这就是导出命令的特点，它不但会导出数据，还会导出表或者数据库的结构信息。另外如果不带”&gt; {you file path}”这一部分路径信息，mysqldump导出命令或把内容打印在terminal命令界面上。</p><h2 id="数据库表及数据导入"><a href="#数据库表及数据导入" class="headerlink" title="数据库表及数据导入"></a>数据库表及数据导入</h2><p>数据库表及数据导入可用mysqldump 和source 两种方法来操作， </p><p><strong> 通过mysqldump 工具导入</strong><br>mysqldump -h{hostname} [-P{port}] -u{username} -p{password} [–default-character-set=charset] database [tablename] &lt; {you file path}</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysqldump -h192.168.0.3 -P3308 -uroot -p123456  databasename &lt; ./crm_adapter_db.sql</span><br></pre></td></tr></table></figure><p><strong> 通过source 命令导入 </strong></p><p><code>source</code>命令导入不同于mysqldump, 它是一个SQL命令, 必须登录进入MySQL在命令行那里才可以运行, 而mysqldump实则是一个管理工具，无须登入MySQ在命令行那里运行，只须在命令行下运行即可。先登入MySQL:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql -h&#123;hostname&#125; [-p&#123;port&#125;] -u&#123;username&#125; -p&#123;password&#125;</span><br></pre></td></tr></table></figure><p>举例, 我们登入一个远程MySQL可以用下面的命令,</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql -h192.168.0.3 -unikey -p123456</span><br></pre></td></tr></table></figure><p>登入之后，进入我们要作用的数据库,</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql &gt; use my_crm_adapter;</span><br></pre></td></tr></table></figure><p>然后我们可以使用source命令来运行前面导出的sql脚本实现数据的导入,</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql &gt; <span class="built_in">source</span> ./crm_adapter_db.sql;</span><br></pre></td></tr></table></figure><p><strong> mysqldump vs source </strong><br>mysqldump虽然好用, 但它实际上也是运用先登录在运行脚本的策略, 只是其中的细节我们无需关心, 但是, 因为其中有很多远程连接细节, 我们有可能遭遇中文乱码问题。</p><center><img src="/2017/02/22/mysql-import-export-summary/mysqldump_error.png" alt="mysqldump 乱码"></center><p>关于为何在使用mysqldump做导入时会出现中文乱码问题, 我们先用mysql命令登入, 然后输入下面的命令:<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql &gt; show variables like <span class="string">'character%'</span>;</span><br></pre></td></tr></table></figure></p><center><img src="/2017/02/22/mysql-import-export-summary/mysqldump_ret.png" alt="mysqldump character error"></center><p>是否注意到红圈部分的编码是latin1? latin1是MySQL的默认字符集, 可能由于某种原因你没有指定默认编码, 它就会默认为latin1了, 这就是你中文乱码出现的原因。</p><p><strong> <font color="red"> 所以建议优先使用source 命令来导入数据 </font> </strong> </p><h2 id="mysqldump使用总结"><a href="#mysqldump使用总结" class="headerlink" title="mysqldump使用总结"></a>mysqldump使用总结</h2><ul><li><p>导出所有库<br>  系统命令行</p>  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysqldump -uusername -ppassword --all-databases &gt; all.sql</span><br></pre></td></tr></table></figure></li><li><p>导入所有库<br>  mysql命令行</p>  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt;<span class="built_in">source</span> all.sql;</span><br></pre></td></tr></table></figure></li><li><p>导出某些库<br>  系统命令行</p>  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysqldump -uusername -ppassword --databases db1 db2 &gt; db1db2.sql</span><br></pre></td></tr></table></figure></li><li><p>导入某些库<br>  mysql命令行</p>  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt;<span class="built_in">source</span> db1db2.sql;</span><br></pre></td></tr></table></figure></li><li><p>导入某个库<br>  系统命令行</p>  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql -uusername -ppassword db1 &lt; db1.sql;</span><br></pre></td></tr></table></figure><p>  或mysql命令行</p>  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt;<span class="built_in">source</span> db1.sql;</span><br></pre></td></tr></table></figure></li><li><p>导出某些数据表<br>  系统命令行</p>  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysqldump -uusername -ppassword db1 table1 table2 &gt; tb1tb2.sql</span><br></pre></td></tr></table></figure></li><li><p>导入某些数据表<br>  系统命令行</p>  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql -uusername -ppassword db1 &lt; tb1tb2.sql</span><br></pre></td></tr></table></figure><p>  或mysql命令行</p>  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt;user db1;</span><br><span class="line">mysql&gt;<span class="built_in">source</span> tb1tb2.sql;</span><br></pre></td></tr></table></figure></li><li><p>mysqldump字符集设置<br>  mysqldump -uusername -ppassword –default-character-set=gb2312 db1 table1 &gt; tb1.sql<br>  mysqldump客户端可用来转储数据库或搜集数据库进行备份或将数据转移到另一个sql服务器(不一定是一个mysql服务器)。转储包含创建表和/或装载表的sql语句。<br>  如果在服务器上进行备份，并且表均为myisam表，应考虑使用mysqlhotcopy，因为可以更快地进行备份和恢复。<br>  有3种方式来调用mysqldump:<br>  系统命令行</p>  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">mysqldump [options] db_name [tables]</span><br><span class="line"><span class="comment"># 或</span></span><br><span class="line">mysqldump [options] ---database db1 [db2 db3...]</span><br><span class="line"><span class="comment"># 或</span></span><br><span class="line">mysqldump [options] --all--database</span><br></pre></td></tr></table></figure><p>  如果没有指定任何表或使用了—database或–all–database选项，则转储整个数据库。<br>  要想获得你的版本的mysqldump支持的选项，执行mysqldump —help。<br>  如果运行mysqldump没有–quick或–opt选项，mysqldump在转储结果前将整个结果集装入内存。如果转储大数据库可能会出现问题。该选项默认启用，但可以用–skip-opt禁用。<br>  如果使用最新版本的mysqldump程序生成一个转储重装到很旧版本的mysql服务器中，不应使用–opt或-e选项。<br>  mysqldump支持下面的选项:<br>   <code>--help</code> 或<code>-?</code><br>   显示帮助消息并退出。<br>   <code>--add-drop--database</code><br>   在每个create database语句前添加drop database语句。<br>   <code>--add-drop-tables</code><br>   在每个create table语句前添加drop table语句。<br>   <code>--add-locking</code><br>   用lock tables和unlock tables语句引用每个表转储。重载转储文件时插入得更快。<br>   <code>--all--database</code> 或 <code>-a</code><br>  转储所有数据库中的所有表。与使用—database选项相同，在命令行中命名所有数据库。<br>   <code>--allow-keywords</code><br>   允许创建关键字列名。应在每个列名前面加上表名前缀。<br>   <code>--comments[={0|1}]</code><br>   如果设置为0, 禁止转储文件中的其它信息, 例如程序版本, 服务器版本和主机。<code>--skip—comments</code>与<code>--comments=0</code>的结果相同。 默认值为1，即包括额外信息。<br>   <code>--compact</code><br>   产生少量输出。该选项禁用注释并启用<code>--skip-add-drop-tables</code>、<code>--no-set-names</code>、<code>--skip-disable-keys</code>和<code>--skip-add-locking</code>选项。<br>   <code>--compatible=name</code><br>   产生与其它数据库系统或旧的mysql服务器更兼容的输出。值可以为ansi、mysql323、mysql40、postgresql、oracle、mssql、db2、maxdb、no_key_options、no_tables_options或者no_field_options。要使用几个值，用逗号将它们隔开。这些值与设置服务器sql模式的相应选项有相同的含义。该选项不能保证同其它服务器之间的兼容性。它只启用那些目前能够使转储输出更兼容的sql模式值。例如，–compatible=oracle 不映射oracle类型或使用oracle注释语法的数据类型。<br>   <code>--complete-insert</code> 或 <code>-c</code><br>   使用包括列名的完整的insert语句。<br>   <code>--compress</code> 或<code>-c</code><br>   压缩在客户端和服务器之间发送的所有信息（如果二者均支持压缩）。<br>   <code>--create-option</code><br>   在create table语句中包括所有mysql表选项。<br>  <code>--database</code> 或 <code>-b</code><br>  转储几个数据库。通常情况, mysqldump将命令行中的第1个名字参量看作数据库名，后面的名看作表名。使用该选项，它将所有名字参量看作数据库名。create database if not exists db_name和use db_name语句包含在每个新数据库前的输出中。<br>   <code>--debug[=debug_options]</code> 或<code>-# [debug_options]</code><br>   写调试日志。debug_options字符串通常为’d:t:o,file_name’。<br>   <code>--default-character-set=charset</code><br>   使用charsetas默认字符集。如果没有指定，mysqldump使用utf8。<br>   <code>--delayed-insert</code><br>   使用insert delayed语句插入行。<br>   <code>--delete-master-logs</code><br>   在主复制服务器上，完成转储操作后删除二进制日志。该选项自动启用<code>--master-data</code>。<br>   <code>--disable-keys</code> 或 <code>-k</code><br>   对于每个表，用/<em>!40000 alter table tbl_name disable keys </em>/;和/<em>!40000 alter table tbl_name enable keys </em>/;语句引用insert语句。这样可以更快地装载转储文件，因为在插入所有行后创建索引。该选项只适合myisam表。<br>   <code>--extended-insert</code> 或 <code>-e</code><br>   使用包括几个values列表的多行insert语法。这样使转储文件更小，重载文件时可以加速插入。<br>   <code>--fields-terminated-by=...，--fields-enclosed-by=...，--fields-optionally-enclosed-by=...，--fields-escaped-by=...，--行-terminated-by=...</code><br>   这些选项结合-t选项使用，与load data infile的相应子句有相同的含义。<br>   <code>--first-slave</code> 或 <code>-x</code><br>   不赞成使用，现在重新命名为–lock-all-tables。<br>   <code>--flush-logs</code> 或 <code>-f</code><br>   开始转储前刷新mysql服务器日志文件。该选项要求reload权限。请注意如果结合<code>--all--database</code>(或-a)选项使用该选项，根据每个转储的数据库刷新日志。例外情况是当使用<code>--lock-all-tables</code>或<code>--master-data</code>的时候:在这种情况下, 日志只刷新一次, 在所有表被锁定后刷新。如果你想要同时转储和刷新日志，应使用<code>--flush-logs</code>连同<code>--lock-all-tables</code>或<code>--master-data</code>。<br>   <code>--force</code>或<code>-f</code><br>   在表转储过程中, 即使出现sql错误也继续。<br>   <code>--host=host_name</code> 或 <code>-h host_name</code><br>   从给定主机的mysql服务器转储数据。默认主机是localhost。<br>   <code>--hex-blob</code><br>   使用十六进制符号转储二进制字符串列(例如，’abc’ 变为0x616263)。影响到的列有binary、varbinary、blob。<br>   <code>--lock-all-tables</code> 或 <code>-x</code><br>   所有数据库中的所有表加锁。在整体转储过程中通过全局读锁定来实现。该选项自动关闭<code>--single-transaction</code>和<code>--lock-tables</code>。<br>   <code>--lock-tables</code> 或<code>-l</code><br>   开始转储前锁定所有表。用read local锁定表以允许并行插入myisam表。对于事务表例如innodb和bdb，<code>--single-transaction</code>是一个更好的选项，因为它不根本需要锁定表。请注意当转储多个数据库时，–lock-tables分别为每个数据库锁定表。因此，该选项不能保证转储文件中的表在数据库之间的逻辑一致性。不同数据库表的转储状态可以完全不同。<br>   <code>--master-data[=value]</code><br>   该选项将二进制日志的位置和文件名写入到输出中。该选项要求有reload权限，并且必须启用二进制日志。如果该选项值等于1，位置和文件名被写入change master语句形式的转储输出，如果你使用该sql转储主服务器以设置从服务器，从服务器从主服务器二进制日志的正确位置开始。如果选项值等于2，change master语句被写成sql注释。如果value被省略，这是默认动作。<br>   <code>--master-data</code>选项启用<code>--lock-all-tables</code>，除非还指定<code>--single-transaction</code>(在这种情况下，只在刚开始转储时短时间获得全局读锁定。又见<code>--single-transaction</code>。在任何一种情况下，日志相关动作发生在转储时。该选项自动关闭<code>--lock-tables</code>。<br>   <code>--no-create-db</code> 或 <code>-n</code><br>   该选项禁用create database /<em>!32312 if not exists</em>/ db_name语句，如果给出—database或–all–database选项，则包含到输出中。<br>   <code>--no-create-info</code> 或 <code>-t</code><br>   不写重新创建每个转储表的create table语句。<br>   <code>--no-data</code> 或 <code>-d</code><br>   不写表的任何行信息。如果你只想转储表的结构这很有用。<br>   <code>--opt</code><br>   该选项是速记；等同于指定 –add-drop-tables–add-locking –create-option –disable-keys–extended-insert –lock-tables –quick –set-charset。它可以给出很快的转储操作并产生一个可以很快装入mysql服务器的转储文件。该选项默认开启，但可以用–skip-opt禁用。要想只禁用确信用-opt启用的选项，使用–skip形式；例如，–skip-add-drop-tables或–skip-quick。<br>   –password[=password]，-p[password]<br>   连接服务器时使用的密码。如果你使用短选项形式(-p)，不能在选项和密码之间有一个空格。如果在命令行中，忽略了–password或-p选项后面的 密码值，将提示你输入一个。<br>   –port=port_num，-p port_num<br>   用于连接的tcp/ip端口号。<br>   –protocol={tcp | socket | pipe | memory}<br>   使用的连接协议。<br>   –quick，-q<br>   该选项用于转储大的表。它强制mysqldump从服务器一次一行地检索表中的行而不是检索所有行并在输出前将它缓存到内存中。<br>   –quote-names，-q<br>   用”`“字符引用数据库、表和列名。如果服务器sql模式包括ansi_quotes选项，用”字符引用名。默认启用该选项。可以用–skip-quote-names禁用，但该选项应跟在其它选项后面，例如可以启用–quote-names的–compatible。<br>   –result-file=file，-r file<br>  –socket=path，-s path<br>   当连接localhost(为默认主机)时使用的套接字文件。<br>   –skip–comments<br>  参见—comments选项的描述。<br>  –tab=path，-t path<br>  产生tab分割的数据文件。对于每个转储的表，mysqldump创建一个包含创建表的create table语句的tbl_name.sql文件，和一个包含其数据的tbl_name.txt文件。选项值为写入文件的目录。<br>  默认情况，.txt数据文件的格式是在列值和每行后面的新行之间使用tab字符。可以使用–fields-xxx和–行–xxx选项明显指定格式。<br>  注释：该选项只适用于mysqldump与mysqld服务器在同一台机器上运行时。你必须具有file权限，并且服务器必须有在你指定的目录中有写文件的许可。<br>  –tables<br>  覆盖—database或-b选项。选项后面的所有参量被看作表名。<br>  –triggers<br>  为每个转储的表转储触发器。该选项默认启用；用–skip-triggers禁用它。<br>  –tz-utc<br>  在转储文件中加入set time_zone=’+00:00’以便timestamp列可以在具有不同时区的服务器之间转储和重载。(不使用该选项，timestamp列在具有本地时区的源服务器和目的服务器之间转储和重载）。–tz-utc也可以保护由于夏令时带来的更改。–tz-utc默认启用。要想禁用它，使用–skip-tz-utc。该选项在mysql 5.1.2中加入。<br>   –where=’where-condition’, -w ‘where-condition’<br>   只转储给定的where条件选择的记录。请注意如果条件包含命令解释符专用空格或字符，一定要将条件引用起来。<br>   例如:<br>   <code>&quot;--where=user=&#39;jimf&#39;&quot;   &quot;-wuserid&gt;1&quot;   &quot;-wuserid&lt;1&quot;</code><br>   –xml，-x<br>   将转储输出写成xml。<br>   还可以使用–var_name=value选项设置下面的变量:<br>   max_allowed_packet<br>   客户端/服务器之间通信的缓存区的最大大小。最大为1gb。<br>   net_buffer_length<br>   客户端/服务器之间通信的缓存区的初始大小。当创建多行插入语句时(如同使用选项–extended-insert或–opt)，mysqldump创建长度达net_buffer_length的行。如果增加该变量，还应确保在mysql服务器中的net_buffer_length变量至少这么大。<br>   还可以使用–set-variable=var_name=value或-o var_name=value语法设置变量。然而，现在不赞成使用该语法。<br>   mysqldump最常用于备份一个整个的数据库:<br>  mysqldump –opt db_name &gt; backup-file.sql<br>  可以这样将转储文件读回到服务器:<br>  mysql db_name &lt; backup-file.sql<br>   或:<br>  mysql -e “source /path-to–backup/backup-file.sql” db_name<br>   mysqldump也可用于从一个mysql服务器向另一个服务器复制数据时装载数据库:<br>  mysqldump –opt db_name | mysql –host=remote_host -c db_name<br>  可以用一个命令转储几个数据库:<br>  mysqldump —database db_name1 [db_name2 …] &gt; my_databases.sql<br>  如果想要转储所有数据库，使用–all–database选项:<br>  mysqldump –all-databases &gt; all_databases.sql<br>  如果表保存在innodb存储引擎中，mysqldump提供了一种联机备份的途径(参见下面的命令)。该备份只需要在开始转储时对所有表进行全局读锁定(使用flush tables with read lock)。获得锁定后，读取二进制日志的相应内容并将锁释放。因此如果并且只有当发出flush…时正执行一个长的更新语句，mysql服务器才停止直到长语句结束，然后转储则释放锁。因此如果mysql服务器只接收到短(“短执行时间”)的更新语句，即使有大量的语句，也不会注意到锁期间。<br>  mysqldump –all-databases –single-transaction &gt; all_databases.sql<br>  对于点对点恢复(也称为“前滚”，当你需要恢复旧的备份并重放该备份以后的更改时)，循环二进制日志或至少知道转储对应的二进制日志内容很有用：<br>  mysqldump –all-databases –master-data=2 &gt; all_databases.sql<br>  或<br>  mysqldump –all-databases –flush-logs –master-data=2 &gt; all_databases.sql<br>  如果表保存在innodb存储引擎中，同时使用–master-data和–single-transaction提供了一个很方便的方式来进行适合点对点恢复的联机备份。</p></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;由于公司的MySQL是搭建在服务器上，为了避免对服务器进行直接改动，想远程导出和导入MySQL的数据库表结构及数据进行操作, 刚好Mysql本身提供了命令行导出工具&lt;code&gt;Mysqldump&lt;/code&gt;和&lt;code&gt;Mysql Source&lt;/code&gt;导入命令进行SQL数据导入导出工作，通过Mysql命令行导出工具Mysqldump命令能够将Mysql数据导出为文本格式(txt)的SQL文件，通过Mysql Source命令能够将SQL文件导入Mysql数据库中，下面通过Mysql导入导出SQL实例详解Mysqldump和Source命令的用法&lt;/p&gt;
    
    </summary>
    
      <category term="DevOps" scheme="http://researchlab.github.io/categories/DevOps/"/>
    
    
      <category term="mysql" scheme="http://researchlab.github.io/tags/mysql/"/>
    
  </entry>
  
  <entry>
    <title>Linux Signal及Golang中的信号处理</title>
    <link href="http://researchlab.github.io/2017/01/22/linux-signal-golang/"/>
    <id>http://researchlab.github.io/2017/01/22/linux-signal-golang/</id>
    <published>2017-01-22T14:35:45.000Z</published>
    <updated>2018-10-18T05:08:14.834Z</updated>
    
    <content type="html"><![CDATA[<p>信号(Signal)是Linux, 类Unix和其它POSIX兼容的操作系统中用来进程间通讯的一种方式。一个信号就是一个异步的通知，发送给某个进程，或者同进程的某个线程，告诉它们某个事件发生了。<br>当信号发送到某个进程中时，操作系统会中断该进程的正常流程，并进入相应的信号处理函数执行操作，完成后再回到中断的地方继续执行。<br>如果目标进程先前注册了某个信号的处理程序(signal handler),则此处理程序会被调用，否则缺省的处理程序被调用。</p><a id="more"></a><h2 id="发送信号"><a href="#发送信号" class="headerlink" title="发送信号"></a>发送信号</h2><ul><li><code>kill</code> 系统调用(system call)可以用来发送一个特定的信号给进程。</li><li><code>kill</code> 命令允许用户发送一个特定的信号给进程。</li><li><code>raise</code> 库函数可以发送特定的信号给当前进程。</li></ul><p>在Linux下运行man kill可以查看此命令的介绍和用法。</p><blockquote><p>The command kill sends the specified signal to the specified process or process group. If no signal is specified, the TERM signal is sent. The TERM signal will kill processes which do not catch this signal. For other processes, it may be necessary to use the KILL (9) signal, since this signal cannot be caught.<br>Most modern shells have a builtin kill function, with a usage rather similar to that of the command described here. The ‘-a’ and ‘-p’ options, and the possibility to specify pids by command name is a local extension.<br>If sig is 0, then no signal is sent, but error checking is still performed.</p></blockquote><p>一些异常比如除以0或者<code>segmentation violation</code>相应的会产生<code>SIGFPE</code>和<code>SIGSEGV</code>信号，缺省情况下导致<code>core dump</code>和程序退出。<br>内核在某些情况下发送信号，比如在进程往一个已经关闭的管道写数据时会产生<code>SIGPIPE</code>信号.<br>在进程的终端敲入特定的组合键也会导致系统发送某个特定的信号给此进程：</p><ul><li><code>Ctrl-C</code> 发送 INT signal (SIGINT)，通常导致进程结束</li><li><code>Ctrl-Z</code> 发送 TSTP signal (SIGTSTP); 通常导致进程挂起(suspend)</li><li><code>Ctrl-\</code> 发送 QUIT signal (SIGQUIT); 通常导致进程结束 和 dump core.</li><li><code>Ctrl-T</code> (不是所有的UNIX都支持) 发送INFO signal (SIGINFO); 导致操作系统显示此运行命令的信息</li><li><code>kill -9 pid</code> 会发送 SIGKILL信号给进程。</li></ul><h2 id="处理信号"><a href="#处理信号" class="headerlink" title="处理信号"></a>处理信号</h2><p>Signal handler可以通过signal()系统调用进行设置。如果没有设置，缺省的handler会被调用，当然进程也可以设置忽略此信号。<br>有两种信号不能被拦截和处理: <code>SIGKILL</code>和<code>SIGSTOP</code>。</p><p>当接收到信号时，进程会根据信号的响应动作执行相应的操作，信号的响应动作有以下几种：</p><p>1.中止进程(Term)<br>2.忽略信号(Ign)<br>3.中止进程并保存内存信息(Core)<br>4.停止进程(Stop)<br>5.继续运行进程(Cont)<br>6.用户可以通过signal或sigaction函数修改信号的响应动作（也就是常说的”注册信号”）。另外，在多线程中，各线程的信号响应动作都是相同的，不能对某个线程设置独立的响应动作。</p><h2 id="信号类型"><a href="#信号类型" class="headerlink" title="信号类型"></a>信号类型</h2><p>不同平台的信号定义或许有些不同。下面列出了POSIX中定义的信号。<br>Linux 使用34-64信号用作实时系统中。<br>命令man 7 signal提供了官方的信号介绍。</p><p>在POSIX.1-1990标准中定义的信号列表</p><table><thead><tr><th>信号</th><th>值</th><th>动作</th><th>说明</th></tr></thead><tbody><tr><td>SIGHUP</td><td>1</td><td>Term</td><td>终端控制进程结束(终端连接断开)</td></tr><tr><td>SIGINT</td><td>2</td><td>Term</td><td>用户发送INTR字符(Ctrl+C)触发</td></tr><tr><td>SIGQUIT</td><td>3</td><td>Core</td><td>用户发送QUIT字符(Ctrl+/)触发</td></tr><tr><td>SIGILL</td><td>4</td><td>Core</td><td>非法指令(程序错误、试图执行数据段、栈溢出等)</td></tr><tr><td>SIGABRT</td><td>6</td><td>Core</td><td>调用abort函数触发</td></tr><tr><td>SIGFPE</td><td>8</td><td>Core</td><td>算术运行错误(浮点运算错误、除数为零等)</td></tr><tr><td>SIGKILL</td><td>9</td><td>Term</td><td>无条件结束程序(不能被捕获、阻塞或忽略)</td></tr><tr><td>SIGSEGV</td><td>11</td><td>Core</td><td>无效内存引用(试图访问不属于自己的内存空间、对只读内存空间进行写操作)</td></tr><tr><td>SIGPIPE</td><td>13</td><td>Term</td><td>消息管道损坏(FIFO/Socket通信时，管道未打开而进行写操作)</td></tr><tr><td>SIGALRM</td><td>14</td><td>Term</td><td>时钟定时信号</td></tr><tr><td>SIGTERM</td><td>15</td><td>Term</td><td>结束程序(可以被捕获、阻塞或忽略)</td></tr><tr><td>SIGUSR1</td><td>30,10,16</td><td>Term</td><td>用户保留</td></tr><tr><td>SIGUSR2</td><td>31,12,17</td><td>Term</td><td>用户保留</td></tr><tr><td>SIGCHLD</td><td>20,17,18</td><td>Ign</td><td>子进程结束(由父进程接收)</td></tr><tr><td>SIGCONT</td><td>19,18,25</td><td>Cont</td><td>继续执行已经停止的进程(不能被阻塞)</td></tr><tr><td>SIGSTOP</td><td>17,19,23</td><td>Stop</td><td>停止进程(不能被捕获、阻塞或忽略)</td></tr><tr><td>SIGTSTP</td><td>18,20,24</td><td>Stop</td><td>停止进程(可以被捕获、阻塞或忽略)</td></tr><tr><td>SIGTTIN</td><td>21,21,26</td><td>Stop</td><td>后台程序从终端中读取数据时触发</td></tr><tr><td>SIGTTOU</td><td>22,22,27</td><td>Stop</td><td>后台程序向终端中写数据时触发</td></tr></tbody></table><p>在SUSv2和POSIX.1-2001标准中的信号列表:</p><table><thead><tr><th>信号</th><th>值</th><th>动作</th><th>说明</th></tr></thead><tbody><tr><td>SIGTRAP</td><td>5</td><td>Core</td><td>Trap指令触发(如断点，在调试器中使用)</td></tr><tr><td>SIGBUS</td><td>0,7,10</td><td>Core</td><td>非法地址(内存地址对齐错误)</td></tr><tr><td>SIGPOLL</td><td></td><td>Term</td><td>Pollable event (Sys V). Synonym for SIGIO</td></tr><tr><td>SIGPROF</td><td>27,27,29</td><td>Term</td><td>性能时钟信号(包含系统调用时间和进程占用CPU的时间)</td></tr><tr><td>SIGSYS</td><td>12,31,12</td><td>Core</td><td>无效的系统调用(SVr4)</td></tr><tr><td>SIGURG</td><td>16,23,21</td><td>Ign</td><td>有紧急数据到达Socket(4.2BSD)</td></tr><tr><td>SIGVTALRM</td><td>26,26,28</td><td>Term</td><td>虚拟时钟信号(进程占用CPU的时间)(4.2BSD)</td></tr><tr><td>SIGXCPU</td><td>24,24,30</td><td>Core</td><td>超过CPU时间资源限制(4.2BSD)</td></tr><tr><td>SIGXFSZ</td><td>25,25,31</td><td>Core</td><td>超过文件大小资源限制(4.2BSD)</td></tr></tbody></table><p>Windows中没有SIGUSR1,可以用SIGBREAK或者SIGINT代替。</p><h2 id="Go中的Signal发送和处理"><a href="#Go中的Signal发送和处理" class="headerlink" title="Go中的Signal发送和处理"></a>Go中的Signal发送和处理</h2><p>有时候我们想在Go程序中处理<code>Signal</code>信号，比如收到<code>SIGTERM</code>信号后优雅的关闭程序(参看下一节的应用)。<br>Go信号通知机制可以通过往一个<code>channel</code>中发送<code>os.Signal</code>实现。<br>首先我们创建一个<code>os.Signal channel</code>，然后使用<code>signal.Notify</code>注册要接收的信号。</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"><span class="keyword">import</span> <span class="string">"os"</span></span><br><span class="line"><span class="keyword">import</span> <span class="string">"os/signal"</span></span><br><span class="line"><span class="keyword">import</span> <span class="string">"syscall"</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    sigs := <span class="built_in">make</span>(<span class="keyword">chan</span> os.Signal, <span class="number">1</span>)</span><br><span class="line">    done := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">bool</span>, <span class="number">1</span>)</span><br><span class="line">    signal.Notify(sigs, syscall.SIGINT, syscall.SIGTERM)</span><br><span class="line">    <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">        sig := &lt;-sigs</span><br><span class="line">        fmt.Println(sig)</span><br><span class="line">        done &lt;- <span class="literal">true</span></span><br><span class="line">    &#125;()</span><br><span class="line">    fmt.Println(<span class="string">"awaiting signal"</span>)</span><br><span class="line">    &lt;-done</span><br><span class="line">    fmt.Println(<span class="string">"exiting"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>go run main.go执行这个程序，敲入<code>ctrl-C</code>会发送<code>SIGINT</code>信号。 此程序接收到这个信号后会打印退出。</p><p>在工作中，遇到这样一个场景:需要往阿里日志服务写数据，但要等到满了200条数据才会触发写入阿里日志服务操作， 辣就会遇到一个问题，当程序被人为中断退出时，但是又没有达到200数据，如果不做其它处理，则这些数据就会丢失了， 为防止存在上述情况的丢失，可以使用Signal来做，<br><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">ch := <span class="built_in">make</span>(<span class="keyword">chan</span> os.Signal, <span class="number">1</span>)</span><br><span class="line">signal.Notify(ch, syscall.SIGINT, syscall.SIGQUIT, syscall.SIGABRT, syscall.SIGTERM, syscall.SIGPIPE)</span><br><span class="line"><span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">for</span> sig := <span class="keyword">range</span> ch &#123;</span><br><span class="line"><span class="keyword">switch</span> sig &#123;</span><br><span class="line"><span class="keyword">case</span> syscall.SIGPIPE:</span><br><span class="line"><span class="keyword">default</span>:</span><br><span class="line">this.Terminate()</span><br><span class="line">&#125;</span><br><span class="line">glog.Info(<span class="string">"[服务] 收到信号 "</span>, sig)</span><br><span class="line">&#125;</span><br><span class="line">&#125;()</span><br></pre></td></tr></table></figure></p><blockquote><p>上述代码的好处时当收到Signal信号之后，就可以选择调用this.Terminate()方法来作出相应的处理</p></blockquote><h2 id="Go网络服务器如果无缝重启"><a href="#Go网络服务器如果无缝重启" class="headerlink" title="Go网络服务器如果无缝重启"></a>Go网络服务器如果无缝重启</h2><p>Go很适合编写服务器端的网络程序。DevOps经常会遇到的一个情况是升级系统或者重新加载配置文件，在这种情况下我们需要重启此网络程序，如果网络程序暂停的时间较长，则给客户的感觉很不好。</p><p>如何实现优雅地重启一个Go网络程序呢。主要要解决两个问题:</p><ul><li>进程重启不需要关闭监听的端口</li><li>既有请求应当完全处理或者超时</li></ul><p>文章<a href="https://grisha.org/blog/2014/06/03/graceful-restart-in-golang/" target="_blank" rel="noopener">Graceful Restart in Golang</a>中提供了一种方式，而Florian von Bock根据此思路实现了一个框架<a href="https://github.com/fvbock/endless" target="_blank" rel="noopener">endless</a>。</p><p>此框架使用起来超级简单:<br><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">err := endless.ListenAndServe(<span class="string">"localhost:4242"</span>, mux)</span><br></pre></td></tr></table></figure></p><p>只需替换<code>http.ListenAndServe</code>和<code>http.ListenAndServeTLS</code>。</p><p>它会监听这些信号： <code>syscall.SIGHUP</code>, <code>syscall.SIGUSR1</code>, <code>syscall.SIGUSR2</code>, <code>syscall.SIGINT</code>, <code>syscall.SIGTERM</code>和<code>syscall.SIGTSTP</code>。</p><p>此文章提到的思路是：</p><p>通过<code>exec.Command</code> fork一个新的进程，同时继承当前进程的打开的文件(输入输出，socket等)<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">file := netListener.File() // this returns a Dup()</span><br><span class="line">path := <span class="string">"/path/to/executable"</span></span><br><span class="line">args := []string&#123;</span><br><span class="line">    <span class="string">"-graceful"</span>&#125;</span><br><span class="line">cmd := exec.Command(path, args...)</span><br><span class="line">cmd.Stdout = os.Stdout</span><br><span class="line">cmd.Stderr = os.Stderr</span><br><span class="line">cmd.ExtraFiles = []*os.File&#123;file&#125;</span><br><span class="line">err := cmd.Start()</span><br><span class="line"><span class="keyword">if</span> err != nil &#123;</span><br><span class="line">    log.Fatalf(<span class="string">"gracefulRestart: Failed to launch, error: %v"</span>, err)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>子进程初始化</p><p>网络程序的启动代码</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">server := &amp;http.Server&#123;Addr: <span class="string">"0.0.0.0:8888"</span>&#125;</span><br><span class="line"> <span class="keyword">var</span> gracefulChild <span class="keyword">bool</span></span><br><span class="line"> <span class="keyword">var</span> l net.Listever</span><br><span class="line"> <span class="keyword">var</span> err error</span><br><span class="line"> flag.BoolVar(&amp;gracefulChild, <span class="string">"graceful"</span>, <span class="literal">false</span>, <span class="string">"listen on fd open 3 (internal use only)"</span>)</span><br><span class="line"> <span class="keyword">if</span> gracefulChild &#123;</span><br><span class="line">     log.Print(<span class="string">"main: Listening to existing file descriptor 3."</span>)</span><br><span class="line">     f := os.NewFile(<span class="number">3</span>, <span class="string">""</span>)</span><br><span class="line">     l, err = net.FileListener(f)</span><br><span class="line"> &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">     log.Print(<span class="string">"main: Listening on a new file descriptor."</span>)</span><br><span class="line">     l, err = net.Listen(<span class="string">"tcp"</span>, server.Addr)</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p>父进程停止</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> gracefulChild &#123;</span><br><span class="line">    parent := syscall.Getppid()</span><br><span class="line">    log.Printf(<span class="string">"main: Killing parent pid: %v"</span>, parent)</span><br><span class="line">    syscall.Kill(parent, syscall.SIGTERM)</span><br><span class="line">&#125;</span><br><span class="line">server.Serve(l)</span><br></pre></td></tr></table></figure><p>因此，处理特定的信号可以实现程序无缝的重启。</p><h2 id="其它"><a href="#其它" class="headerlink" title="其它"></a>其它</h2><p>graceful shutdown实现非常的简单，通过简单的信号处理就可以实现。本文介绍的是graceful restart,要求无缝重启，所以所用的技术相当的hack。</p><p>Facebook的工程师也提供了http和net的实现： <a href="https://github.com/facebookgo/grace" target="_blank" rel="noopener">facebookgo</a>。</p><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p><a href="http://colobu.com/2015/10/09/Linux-Signals/?utm_source=tuicool&amp;utm_medium=referral" target="_blank" rel="noopener">http://colobu.com/2015/10/09/Linux-Signals/?utm_source=tuicool&amp;utm_medium=referral</a></p><p><a href="https://en.wikipedia.org/wiki/Unix_signal" target="_blank" rel="noopener">https://en.wikipedia.org/wiki/Unix_signal</a><br><a href="http://hutaow.com/blog/2013/10/19/linux-signal/" target="_blank" rel="noopener">http://hutaow.com/blog/2013/10/19/linux-signal/</a><br><a href="http://www.ucs.cam.ac.uk/docs/course-notes/unix-courses/Building/files/signals.pdf" target="_blank" rel="noopener">http://www.ucs.cam.ac.uk/docs/course-notes/unix-courses/Building/files/signals.pdf</a><br><a href="https://golang.org/pkg/os/signal/" target="_blank" rel="noopener">https://golang.org/pkg/os/signal/</a><br><a href="https://gobyexample.com/signals" target="_blank" rel="noopener">https://gobyexample.com/signals</a><br><a href="http://grisha.org/blog/2014/06/03/graceful-restart-in-golang/" target="_blank" rel="noopener">http://grisha.org/blog/2014/06/03/graceful-restart-in-golang/</a><br><a href="https://fitstar.github.io/falcore/hot_restart.html" target="_blank" rel="noopener">https://fitstar.github.io/falcore/hot_restart.html</a><br><a href="https://github.com/rcrowley/goagain" target="_blank" rel="noopener">https://github.com/rcrowley/goagain</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;信号(Signal)是Linux, 类Unix和其它POSIX兼容的操作系统中用来进程间通讯的一种方式。一个信号就是一个异步的通知，发送给某个进程，或者同进程的某个线程，告诉它们某个事件发生了。&lt;br&gt;当信号发送到某个进程中时，操作系统会中断该进程的正常流程，并进入相应的信号处理函数执行操作，完成后再回到中断的地方继续执行。&lt;br&gt;如果目标进程先前注册了某个信号的处理程序(signal handler),则此处理程序会被调用，否则缺省的处理程序被调用。&lt;/p&gt;
    
    </summary>
    
      <category term="golang" scheme="http://researchlab.github.io/categories/golang/"/>
    
    
      <category term="signal" scheme="http://researchlab.github.io/tags/signal/"/>
    
  </entry>
  
  <entry>
    <title>golang server 跨域解决总结</title>
    <link href="http://researchlab.github.io/2017/01/20/go-http-cross-origin/"/>
    <id>http://researchlab.github.io/2017/01/20/go-http-cross-origin/</id>
    <published>2017-01-20T15:30:40.000Z</published>
    <updated>2018-10-18T05:08:14.830Z</updated>
    
    <content type="html"><![CDATA[<p>server提供api服务直接对接前端js, 但是存在跨域问题，本文使用先查询请求过来的host 然后判断主域名是否存在，存在,则在返回头部设置这个请求域名充许跨域访问。<br><a id="more"></a></p><h2 id="跨域概念"><a href="#跨域概念" class="headerlink" title="跨域概念"></a>跨域概念</h2><p>浏览器的同源策略，出于防范跨站脚本的攻击，禁止客户端脚本（如 JavaScript）对不同域的服务进行跨站调用。</p><p>一般的，只要网站的 协议名protocol 、 主机host 、 端口号port 这三个中的任意一个不同，网站间的数据请求与传输便构成了跨域调用。</p><p>一般的，发起跨域请求而没有被设置许可跨域时，则会返回类型下面的说明</p><center><img src="/2017/01/20/go-http-cross-origin/cross_website.png" alt=""></center><p>上面返回提示说明: 跨域请求并非是浏览器限制了发起跨站请求，而是请求可以正常发起，到达服务器端，但是服务器返回的结果会被浏览器拦截。</p><blockquote><p>为了防止CSRF的攻击，我们建议修改浏览器在发送POST请求的时候加上一个Origin字段，这个Origin字段主要是用来标识出最初请求是从哪里发起的。如果浏览器不能确定源在哪里，那么在发送的请求里面Origin字段的值就为空。隐私方面：这种Origin字段的方式比Referer更人性化，因为它尊重了用户的隐私。<br>1、Origin字段里只包含是谁发起的请求，并没有其他信息 (通常情况下是方案，主机和活动文档URL的端口)。跟Referer不一样的是，Origin字段并没有包含涉及到用户隐私的URL路径和请求内容，这个尤其重要。<br>2、Origin字段只存在于POST请求，而Referer则存在于所有类型的请求, (随便点击一个超链接（比如从搜索列表里或者企业intranet），并不会发送Origin字段)。</p></blockquote><h2 id="获取完整url"><a href="#获取完整url" class="headerlink" title="获取完整url"></a>获取完整url</h2><p>查阅了r *http.Request对象中的所有属性，没有发现可以直接获取完整的url的方法。于是尝试根据host和请求地址进行拼接。在golang中可以通过r.Host获取hostname，r.RequestURI获取相应的请求地址。</p><p>但是还少一个协议的判断，怎么区分是http和https呢？一开始尝试通过r.Proto属性判断，但是发现该属性不管是http，还是https都是返回HTTP/1.1，又寻找了下发现TLS属性，在https协议下有对应值，在http下为nil。</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"> </span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">"fmt"</span></span><br><span class="line">    <span class="string">"log"</span></span><br><span class="line">    <span class="string">"net/http"</span></span><br><span class="line">    <span class="string">"strings"</span></span><br><span class="line">)</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">index</span><span class="params">(w http.ResponseWriter, r *http.Request)</span></span> &#123;</span><br><span class="line">    fmt.Println(r.Proto)</span><br><span class="line">    <span class="comment">// output:HTTP/1.1</span></span><br><span class="line">    fmt.Println(r.TLS)</span><br><span class="line">    <span class="comment">// output: &lt;nil&gt;</span></span><br><span class="line">    fmt.Println(r.Host)</span><br><span class="line">    <span class="comment">// output: localhost:9090</span></span><br><span class="line">    fmt.Println(r.RequestURI)</span><br><span class="line">    <span class="comment">// output: /index?id=1</span></span><br><span class="line"> </span><br><span class="line">    scheme := <span class="string">"http://"</span></span><br><span class="line">    <span class="keyword">if</span> r.TLS != <span class="literal">nil</span> &#123;</span><br><span class="line">        scheme = <span class="string">"https://"</span></span><br><span class="line">    &#125;</span><br><span class="line">    fmt.Println(strings.Join([]<span class="keyword">string</span>&#123;scheme, r.Host, r.RequestURI&#125;, <span class="string">""</span>))</span><br><span class="line">    <span class="comment">// output: http://localhost:9090/index?id=1</span></span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    http.HandleFunc(<span class="string">"/index"</span>, index)</span><br><span class="line"> </span><br><span class="line">    err := http.ListenAndServe(<span class="string">":9090"</span>, <span class="literal">nil</span>)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        log.Fatal(<span class="string">"ListenAndServe: "</span>, err)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="动态许可跨域"><a href="#动态许可跨域" class="headerlink" title="动态许可跨域"></a>动态许可跨域</h2><p>1.直接取头部的<code>Origin</code>字段， 如果取到， 则判断是否包含主域名，然后设置跨域，如果<code>Origin</code>字段为空不存在，则转下面第2步;<br>2.获取子域名(scheme + r.Host)之后, 先判断是否存在，并且是否包含主域名，然后设置跨域, 如果<code>r.Host</code>字段为空， 则转下面第3步;<br>3.获取子域名(scheme + r.URL.Host)之后， 判断是否存在， 并且是否包含主域名， 然后设置跨域，</p><p>还有一种方法是利用redis缓存，同样通过上述三个方法获取子域名， 然后查询redis缓存是否存在这个域名，如果有则设置许可跨域; redis缓存的数据来源是 另外准备一个后台，当后台有修改许可跨域网站时，写完db(mysql)的同时先清空缓存，然后在回填缓存即可。</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Origin := r.Header.Get(<span class="string">"Origin"</span>)</span><br><span class="line">    <span class="keyword">if</span> <span class="number">0</span> != <span class="built_in">len</span>(Origin) &amp;&amp; strings.Contains(Origin, <span class="string">"domain.com"</span>)&#123;</span><br><span class="line">        w.Header().Add(<span class="string">"Access-Control-Allow-Origin"</span>, Origin)</span><br><span class="line">        w.Header().Add(<span class="string">"Access-Control-Allow-Methods"</span>, <span class="string">"POST,GET,OPTIONS,DELETE"</span>)</span><br><span class="line">        w.Header().Add(<span class="string">"Access-Control-Allow-Headers"</span>, <span class="string">"x-requested-with,content-type"</span>)</span><br><span class="line">        w.Header().Add(<span class="string">"Access-Control-Allow-Credentials"</span>, <span class="string">"true"</span>)</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><blockquote><p>当不添加 <code>Access-Control-Allow-Methods</code>属性时， 默认支持使用GET、HEAD或者POST请求方法跨域请求</p></blockquote><p>更多参考</p><p><a href="http://www.open-open.com/lib/view/open1473667695212.html" target="_blank" rel="noopener">前端跨域请求原理与实践</a></p><p><a href="http://www.cnblogs.com/dojo-lzz/p/4265637.html" target="_blank" rel="noopener">探讨跨域请求资源的几种方式</a></p><p><a href="https://github.com/hstarorg/HstarDoc/blob/master/%E5%89%8D%E7%AB%AF%E7%9B%B8%E5%85%B3/CORS%E8%AF%A6%E8%A7%A3.md" target="_blank" rel="noopener">关于CORS</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;server提供api服务直接对接前端js, 但是存在跨域问题，本文使用先查询请求过来的host 然后判断主域名是否存在，存在,则在返回头部设置这个请求域名充许跨域访问。&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="golang" scheme="http://researchlab.github.io/categories/golang/"/>
    
    
      <category term="golang" scheme="http://researchlab.github.io/tags/golang/"/>
    
  </entry>
  
  <entry>
    <title>git submodule使用总结</title>
    <link href="http://researchlab.github.io/2017/01/18/git-submodule/"/>
    <id>http://researchlab.github.io/2017/01/18/git-submodule/</id>
    <published>2017-01-18T17:11:52.000Z</published>
    <updated>2018-10-18T05:08:14.830Z</updated>
    
    <content type="html"><![CDATA[<p>现在golang已经可以通过<code>vendor</code>来管理第三方依赖包了，但是之前的一个老项目用的是<code>git submodule</code>来管理的，但是<code>.gitsubmodule</code>文件中只记录管理了项目的部分依赖包， 需要把还没有被管理的第三包也加上，下面总结使用<code>git submodule</code>的过程。<br><a id="more"></a></p><h2 id="添加第三方包"><a href="#添加第三方包" class="headerlink" title="添加第三方包"></a>添加第三方包</h2><p>为当前工程添加submodule，命令如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git submodule add 仓库地址 保存路经路径</span><br></pre></td></tr></table></figure><p>例如要为gomail包添加<code>submodule</code>管理，<br>gomail包 仓库地址: <code>https://github.com/go-gomail/gomail.git</code><br>gomail包要保存在项目里的路经为: <code>src/github.com/go-gomail/gomail</code>, 则命令为:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git submodule add https://github.com/go-gomail/gomail   src/github.com/go-gomail/gomail</span><br></pre></td></tr></table></figure><p>但是老项目遇到的情况是在保存路经<code>src/github.com/go-gomail/gomail</code>中已经存在<code>gomail</code>, 这里只是需要把这个第三包用<code>git submodule</code>记录下来编译管理， 所以需要加一个强制参数， 则命令为如下:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git submodule add -f https://github.com/go-gomail/gomail   src/github.com/go-gomail/gomail</span><br></pre></td></tr></table></figure><blockquote><p>其中，仓库地址是指子模块仓库地址，路径指将子模块放置在当前工程下的路径。<br>注意：路径不能以 / 结尾（会造成修改不生效）、不能是现有工程已有的目录（不能順利 Clone）</p></blockquote><p>命令执行完成，会在当前工程根路径下生成一个名为<code>.gitmodules</code>的文件，其中记录了子模块的信息。添加完成以后，再将子模块所在的文件夹添加到工程中即可。</p><h2 id="删除第三方包"><a href="#删除第三方包" class="headerlink" title="删除第三方包"></a>删除第三方包</h2><p>submodule的删除稍微麻烦点:首先，要在“.gitmodules”文件中删除相应配置信息。然后，执行“git rm –cached ”命令将子模块所在的文件从git中删除。</p><h2 id="下载的工程带有submodule"><a href="#下载的工程带有submodule" class="headerlink" title="下载的工程带有submodule"></a>下载的工程带有submodule</h2><p>当使用git clone下来的工程中带有submodule时，初始的时候，submodule的内容并不会自动下载下来的，此时，只需执行如下命令：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git submodule update --init --recursive</span><br></pre></td></tr></table></figure></p><p>即可将子模块内容下载下来后工程才不会缺少相应的文件。</p><h2 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h2><p>当第三包被<code>git submodule</code>记录之后，<code>git status</code>命令会出现下面的情况,<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ git status vendor | grep modified:</span><br><span class="line"><span class="comment">#       modified:   vendor/rails (modified content)</span></span><br></pre></td></tr></table></figure></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">$ git diff vendor/</span><br><span class="line">diff --git a/vendor/rails b/vendor/rails</span><br><span class="line">--- a/vendor/rails</span><br><span class="line">+++ b/vendor/rails</span><br><span class="line">@@ -1 +1 @@</span><br><span class="line">-Subproject commit 046c900df27994d454b7f906caa0e4226bb42b6f</span><br><span class="line">+Subproject commit 046c900df27994d454b7f906caa0e4226bb42b6f-dirty</span><br></pre></td></tr></table></figure><p>如何让<code>git status</code>不显示那个<code>modified content</code>呢？<br>修改<code>.gitmodule</code>文件， 在显示<code>modified content</code>的第三包管理下添加一个<code>ignore = dirty</code>， 如下:<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[submodule <span class="string">"bundle/fugitive"</span>]</span><br><span class="line">    path = bundle/fugitive</span><br><span class="line">    url = git://github.com/tpope/vim-fugitive.git</span><br><span class="line">    ignore = dirty</span><br></pre></td></tr></table></figure></p><p>上述三个步骤一般就能解决问题了， 如果想深入理解<code>git submodule</code>,可进一步参考<a href="http://www.kafeitu.me/git/2012/03/27/git-submodule.html" target="_blank" rel="noopener">git submodule使用完整教程</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;现在golang已经可以通过&lt;code&gt;vendor&lt;/code&gt;来管理第三方依赖包了，但是之前的一个老项目用的是&lt;code&gt;git submodule&lt;/code&gt;来管理的，但是&lt;code&gt;.gitsubmodule&lt;/code&gt;文件中只记录管理了项目的部分依赖包， 需要把还没有被管理的第三包也加上，下面总结使用&lt;code&gt;git submodule&lt;/code&gt;的过程。&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="DevOps" scheme="http://researchlab.github.io/categories/DevOps/"/>
    
    
      <category term="submodule" scheme="http://researchlab.github.io/tags/submodule/"/>
    
  </entry>
  
</feed>

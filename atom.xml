<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>一线攻城狮</title>
  
  <subtitle>十年磨一剑，一步一步脚踏实地的耕种</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://researchlab.github.io/"/>
  <updated>2018-10-16T13:03:07.485Z</updated>
  <id>http://researchlab.github.io/</id>
  
  <author>
    <name>Lee Hong</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Docker操作提示Get Permission Denied</title>
    <link href="http://researchlab.github.io/2018/06/06/docker-permission-denied/"/>
    <id>http://researchlab.github.io/2018/06/06/docker-permission-denied/</id>
    <published>2018-06-06T15:40:41.000Z</published>
    <updated>2018-10-16T13:03:07.485Z</updated>
    
    <content type="html"><![CDATA[<p>在ubuntu16.04上重新安装docker后，执行docker相关命令，出现”Got permission denied”提示,如下,<br><a id="more"></a><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">~ » docker ps </span><br><span class="line">Got permission denied while trying to connect to the Docker daemon socket at unix:///var/run/docker.sock: Get http://%2Fvar%2Frun%2Fdocker.sock/v1.37/containers/json: dial unix /var/run/docker.sock: connect: permission denied</span><br></pre></td></tr></table></figure></p><h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><p>摘自docker mannual上的一段话<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Manage Docker as a non-root user</span><br><span class="line"></span><br><span class="line">The docker daemon binds to a Unix socket instead of a TCP port. By default that Unix socket is owned by the user root and other users can only access it using sudo. The docker daemon always runs as the root user.</span><br><span class="line"></span><br><span class="line">If you don’t want to use sudo when you use the docker command, create a Unix group called docker and add users to it. When the docker daemon starts, it makes the ownership of the Unix socket read/writable by the docker group.</span><br></pre></td></tr></table></figure></p><p>大概的意思就是：docker进程使用Unix Socket而不是TCP端口。而默认情况下，Unix socket属于root用户，需要root权限才能访问。</p><h2 id="解决方法"><a href="#解决方法" class="headerlink" title="解决方法"></a>解决方法</h2><p>docker守护进程启动的时候，会默认赋予名字为docker的用户组读写Unix socket的权限，因此只要创建docker用户组，并将当前用户加入到docker用户组中，那么当前用户就有权限访问Unix socket了，进而也就可以执行docker相关命令;<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">sudo groupadd docker#添加docker用户组</span><br><span class="line">sudo gpasswd -a $USER docker #将登陆用户加入到docker用户组中</span><br><span class="line">newgrp docker#更新用户组</span><br><span class="line">docker ps#测试docker命令是否可以使用sudo正常使用</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在ubuntu16.04上重新安装docker后，执行docker相关命令，出现”Got permission denied”提示,如下,&lt;br&gt;
    
    </summary>
    
      <category term="docker-practice" scheme="http://researchlab.github.io/categories/docker-practice/"/>
    
    
      <category term="docker" scheme="http://researchlab.github.io/tags/docker/"/>
    
  </entry>
  
  <entry>
    <title>redis专题01 基础数据结构</title>
    <link href="http://researchlab.github.io/2018/01/16/redis-01-%E5%9F%BA%E7%A1%80%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    <id>http://researchlab.github.io/2018/01/16/redis-01-基础数据结构/</id>
    <published>2018-01-16T11:31:18.000Z</published>
    <updated>2018-10-16T13:03:07.485Z</updated>
    
    <content type="html"><![CDATA[<p>在日常应用开发中，redis常应用于热点内容缓存，分布式锁，权限认证等场景中，此redis专题试图对redis技术在内容缓存,分布式及redis集群场景中的应用，使用特性，原理及源码进行分析总结，内容来源于个人工作经验实践及网络学习资源的融合归纳总结;<br><a id="more"></a></p><h3 id="1-redis-环境搭建"><a href="#1-redis-环境搭建" class="headerlink" title="1 redis 环境搭建"></a>1 redis 环境搭建</h3><p>通过docker方式搭建一个redis 环境<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"># 拉取 redis 镜像</span><br><span class="line">&gt; docker pull redis</span><br><span class="line"># 运行 redis 容器</span><br><span class="line">&gt; docker run --name myredis -d -p6379:6379 redis</span><br><span class="line"># 执行容器中的 redis-cli，可以直接使用命令行操作 redis</span><br><span class="line">&gt; docker exec -it myredis redis-cli</span><br></pre></td></tr></table></figure></p><h5 id="2-redis基础结构"><a href="#2-redis基础结构" class="headerlink" title="2 redis基础结构"></a>2 redis基础结构</h5><p>redis有5种基础数据结构: string(字符串), list(列表), set(集合), hash(哈希), zset(有序集合);</p><blockquote><p><a href="http://doc.redisfans.com/" target="_blank" rel="noopener">redis命令参考链接</a></p></blockquote><h6 id="2-1-string-字符串"><a href="#2-1-string-字符串" class="headerlink" title="2.1 string(字符串)"></a>2.1 string(字符串)</h6>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在日常应用开发中，redis常应用于热点内容缓存，分布式锁，权限认证等场景中，此redis专题试图对redis技术在内容缓存,分布式及redis集群场景中的应用，使用特性，原理及源码进行分析总结，内容来源于个人工作经验实践及网络学习资源的融合归纳总结;&lt;br&gt;
    
    </summary>
    
      <category term="redis专题" scheme="http://researchlab.github.io/categories/redis%E4%B8%93%E9%A2%98/"/>
    
    
      <category term="redis" scheme="http://researchlab.github.io/tags/redis/"/>
    
  </entry>
  
  <entry>
    <title>快速排序算法总结</title>
    <link href="http://researchlab.github.io/2017/09/19/quicksort-summary/"/>
    <id>http://researchlab.github.io/2017/09/19/quicksort-summary/</id>
    <published>2017-09-19T10:04:47.000Z</published>
    <updated>2018-10-16T13:03:07.485Z</updated>
    
    <content type="html"><![CDATA[<p>本文首先分别详细阐述了单向扫描、双向扫描快速排序算法原理,并用golang分别设计实现了这两种经典的快速排序算法; 然后本文从性能的角度分不同场景进一步讨论了快速排序改进算法并在文中通过程序设计实现了相关算法，最后基于上述场景从上述算法总结了快速算法的特性及适用场景;<br><a id="more"></a></p><blockquote><p>快速排序是对冒泡排序的一种改进, 采用分治策略, 通过一趟排序将要排序的数据分割成独立的两部分，其中一部分的所有数据都比另外一部分的所有数据都要小，然后再按此方法对这两部分数据分别进行快速排序，整个排序过程可以递归进行，以此达到整个数据变成有序序列。</p></blockquote><p>下面首先来阐述快排的两种经典实现方式: 单向扫描及双向扫描,</p><h2 id="单向扫描"><a href="#单向扫描" class="headerlink" title="单向扫描"></a>单向扫描</h2><p><strong>算法原理:</strong> 主要由两部分组成, 一部分是递归部分QuickSort, 它将调用partition进行划分, 并取得划分元素P, 然后分别对P之前的部分和P 之后的部分递归调用QuickSort; 另一部分是partition, 选取划分元素P（随机选取数组中的一个元素, 交换到数组末尾位置）, 定义两个标记值left和right, 随着划分的进行, 这两个标记值将数组分成三部分, left之左的部分是小于划分元素P的值, left和right之间的部分是大 于等于划分元素P的值（等于p的值没有必要进行交换）, right之右的部分是未划分的部分。运行中right自左向右遍历, left指向最左的一个不小于P的值, 当right遇见小于P的元素就与left当前索引的值交换, right和left同时前进，否则right直接前进，直到数组末尾，最后将P与left当前指向的值交换, 并且返回i的值;</p><h2 id="双向扫描"><a href="#双向扫描" class="headerlink" title="双向扫描"></a>双向扫描</h2><h2 id="三中值扫描"><a href="#三中值扫描" class="headerlink" title="三中值扫描"></a>三中值扫描</h2>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文首先分别详细阐述了单向扫描、双向扫描快速排序算法原理,并用golang分别设计实现了这两种经典的快速排序算法; 然后本文从性能的角度分不同场景进一步讨论了快速排序改进算法并在文中通过程序设计实现了相关算法，最后基于上述场景从上述算法总结了快速算法的特性及适用场景;&lt;br&gt;
    
    </summary>
    
      <category term="algorithm" scheme="http://researchlab.github.io/categories/algorithm/"/>
    
    
      <category term="golang" scheme="http://researchlab.github.io/tags/golang/"/>
    
      <category term="quicksort" scheme="http://researchlab.github.io/tags/quicksort/"/>
    
  </entry>
  
  <entry>
    <title>搭建Docker Registry容器服务</title>
    <link href="http://researchlab.github.io/2017/09/15/docker-registry-v2/"/>
    <id>http://researchlab.github.io/2017/09/15/docker-registry-v2/</id>
    <published>2017-09-15T14:32:05.000Z</published>
    <updated>2018-10-16T13:03:07.485Z</updated>
    
    <content type="html"><![CDATA[<p>Docker Registry 是一个用来管理Docker镜像的服务，本身也是一个Docker容器。搭建一个私有的Docker Registry的使用场景主要有下面几个:<br>1.当需要对容器镜像存储进行完全控制,就不能依赖官方提供的Docker Hub进行管理;<br>2.当内部使用存在网络问题或安全问题等情况都适合搭建私有的Docker Registry对镜像进行管理;</p><p>下面从需频繁pull镜像到某内部机器上新建容器的需求来搭建需要认证访问的Docker Registry,这样同时可以解决网络依赖问题及安全问题, 下面是搭建Docker Registry过程的记录和总结;<br><a id="more"></a></p><h2 id="搭建Docker-Registry"><a href="#搭建Docker-Registry" class="headerlink" title="搭建Docker Registry"></a>搭建Docker Registry</h2><p>1.要搭建本地私有Registry, 首先需要一个Docker Registry基础镜像,直接pull官方镜像即可,<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker pull registry</span><br></pre></td></tr></table></figure></p><p>2.通过下面的命令运行一个基于上面pull的Registry容器服务,<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run -d -p 5000:5000 --restart=always -v /opt/registry-var/:/var/lib/registry/ registry:latest</span><br></pre></td></tr></table></figure></p><p><strong>注:</strong> </p><ul><li>上面需要注意的是新registry仓库数据目录的位置。容器内部新registry的仓库目录是在/var/lib/registry, 所以运行时挂载目录需要注意,因为挂着到别的目录是运行不的;</li><li>其中<code>-v</code>选项 是将本地(宿主机)/opt/registry-var/目录挂载到容器的/var/lib/registry/目录上,</li></ul><p>当上面Registry服务启动之后可通过curl <a href="http://100.73.41.17:5000/v2/_catalog" target="_blank" rel="noopener">http://100.73.41.17:5000/v2/_catalog</a> (假设上面启动Registry服务的的机器ip为:100.73.41.17)能看到json格式的返回值时，说明registry已经运行起来了。</p><p>但上面运行的Registry服务是没有设置认证权限的,即未授权用户也是可以访问上述Registry服务的，为了安全起见一般都会设置认证权限用于访问,</p><p>3.配置带用户权限的registry<br>现在registry已经可以使用了。如果想要控制registry的使用权限，使其只有在登录用户名和密码之后才能使用的话，还需要做额外的设置。<br>registry的用户名密码文件可以通过htpasswd来生成,<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mkdir /opt/registry-var/auth/</span><br><span class="line">docker run --entrypoint htpasswd registry:latest -Bbn felix felix  &gt;&gt; /opt/registry-var/auth/htpasswd</span><br></pre></td></tr></table></figure></p><p>上面这条命令是为felix用户名生成密码为felix的一条用户信息，存在/opt/registry-var/auth/htpasswd文件里面，文件中存的密码是被加密过的。<br>启动带权限配置的docker Registry服务就需要多加几个配置参数了, 启动命令如下:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">docker run -d -p 5000:5000 --restart=always \</span><br><span class="line">  -v /opt/registry-var/auth/:/auth/ \</span><br><span class="line">  -e <span class="string">"REGISTRY_AUTH=htpasswd"</span> \</span><br><span class="line">  -e <span class="string">"REGISTRY_AUTH_HTPASSWD_REALM=Registry Realm"</span> \</span><br><span class="line">  -e REGISTRY_AUTH_HTPASSWD_PATH=/auth/htpasswd \</span><br><span class="line">  -v /opt/registry-var/:/var/lib/registry/ \</span><br><span class="line">  registry:latest</span><br></pre></td></tr></table></figure><p><strong>注:</strong></p><ul><li>挂载认证目录到容器中: <code>-v /opt/registry-var/auth/:/auth/</code></li><li>设置认证方式: <code>-e &quot;REGISTRY_AUTH=htpasswd&quot;</code> </li><li>设置认证方式: <code>-e &quot;REGISTRY_AUTH_HTPASSWD_REALM=Registry Realm&quot;</code> </li><li>设置认证路径: <code>-e REGISTRY_AUTH_HTPASSWD_PATH=/auth/htpasswd</code></li><li>挂载镜像目录: <code>-v /opt/registry-var/:/var/lib/registry/</code></li><li>端口映射 <code>-p 5000:5000</code> 注意Docker Registry容器内部默认监听的是<code>5000</code>端口,如果要修改内部监听端口可通过指定参数<code>REGISTRY_HTTP_ADDR</code>即可修改，如修改为内部监听<code>5001</code>端口,</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">docker run -d --restart=always \</span><br><span class="line">-e REGISTRY_HTTP_ADDR=0.0.0.0:5001 \</span><br><span class="line">  -p 5000:5001 \</span><br><span class="line">  -v /opt/registry-var/auth/:/auth/ \</span><br><span class="line">  -e <span class="string">"REGISTRY_AUTH=htpasswd"</span> \</span><br><span class="line">  -e <span class="string">"REGISTRY_AUTH_HTPASSWD_REALM=Registry Realm"</span> \</span><br><span class="line">  -e REGISTRY_AUTH_HTPASSWD_PATH=/auth/htpasswd \</span><br><span class="line">  -v /opt/registry-var/:/var/lib/registry/ \</span><br><span class="line">  registry:latest</span><br></pre></td></tr></table></figure><h2 id="管理镜像"><a href="#管理镜像" class="headerlink" title="管理镜像"></a>管理镜像</h2><p>上面认证Docker Registry 服务准备好之后，就可以用来管理镜像了，管理镜像一般分下面三步,<br>1.认证登录Docker Registry<br>因为需要认证所以在管理镜像时首选需要通过下面的命令认证登录,<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker login 100.73.41.17:5000</span><br></pre></td></tr></table></figure></p><p>通过上述命令按照提示输入登录名和密码即可登录，但是有可能会遇到下面的提示,而登录失败,<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">➜  docker login 100.73.41.17:5000</span><br><span class="line">Username (xxx): xxx </span><br><span class="line">Password:</span><br><span class="line">Error response from daemon: Get https://100.73.41.17:5000/v2/: http: server gave HTTP response to HTTPS client</span><br></pre></td></tr></table></figure></p><p>这个提示已经很明显告诉你是因为client(https)请求与server(http)接收端协议对不上导致,那如何解决？ 网上千篇一律的告诉你要做如下设置:<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">➜  cat /etc/docker/daemon.json</span><br><span class="line">&#123;</span><br><span class="line"><span class="string">"insecure-registries"</span>:[<span class="string">"100.73.41.17:5000"</span>]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>是的没错, 是通过上述设置即可解决问题,但是这个设置不是设置在Docker Registry启动的那台机器上(上面是:100.73.41.17), 这个是要设置在你在那台机器上进行登录上传下载镜像操作的机器上，</p><p>如上面所设置，我的Docker Registry是搭建在100.73.41.17这台远程机器上,而我需要在本地的Mac 机器上登录远程得这个私有的Docker Registry 进行上传下载操作，那么上面的设置就要设置在我的Mac机器的Docker配置中;</p><p>但是在Mac机器上好像没有发现/etc/docker/daemon.json这个文件，后来通过docker client的图形界面进行设置的，如下，设置之后需要重启docker server,如我需要重启Mac机器上的docker server;</p><p><center><img src="set_insecure_registries.png" alt=""><br>图1 设置insecure-registries</center><br>不过设置<code>insecure-registries</code>是非常不安全的，官方文档中也不推荐而是给出自己生成证书的方式进行认证，<a href="https://docs.docker.com/registry/insecure/#troubleshoot-insecure-registry" target="_blank" rel="noopener">官方链接</a><br>而生产环境中一般需要配置两道认证，第一道认证即证书认证就是将启动Docker Registry 服务的认证证书copy一份到操作Docker Registry机器上（如我的Mac机器）， 第二道认证即上面的用户名密码认证; 具体<a href="https://docs.docker.com/registry/deploying/#native-basic-auth" target="_blank" rel="noopener">官方链接</a><br>1.写入本地镜像到私有Docker Registry,<br>上面登录成功后，接着就可以把本地的镜像推送到远程私有Docker Registry上去了,不过这里需要注意的是待推送到远程Registry上去的本地镜像其名字前缀必须设置为<code>100.73.41.17:5000/</code>, 因为下面要去取镜像时,按照docker读取镜像的规则是<code>镜像地址/镜像名称</code>, 通过镜像地址读取镜像名称, 如果在读取镜像是只给出镜像名称, 则Docker会到官方的Docker Hub上去下载相应的镜像而非本地私有Registry库;下面假设已经制作了一个jenkins镜像但是其前缀不是上面的Registry服务地址,可通过docker tag命令给镜像重新命名然后上传到私有Registry即可，具体命令如下,<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">docker tag jenkins:latest 100.73.41.17:5000/jenkins:latest</span><br><span class="line">docker push 100.73.41.17:5000/jenkins:latest</span><br></pre></td></tr></table></figure></p><p>2.读取镜像到本地<br>上面成功把镜像推送到远程Docker Registry服务上之后，要用时怎么读取到本地？ 在认证登录远程私有Docker Registry通过如下pull命令即可取回目标镜像,<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker pull 100.73.41.17:5000/jenkins:latest</span><br></pre></td></tr></table></figure></p><p>3.删除镜像<br>当镜像上传到远程私有Docker Registry 之后, 发现不需要想删除怎么办？ docker registry应该提供了删除镜像的方法的,不过这个好像在启动Docker Registry 需要配置可删除的开关才行,那么有什么简单的办法可以直接删除呢？办法当然有, 还记得在启动Docker Registry容器服务时, 挂载的镜像目录<code>-v /opt/registry-var/:/var/lib/registry/</code> ？ 是的你上传的镜像其实都在本地的<code>/opt/registry-var/</code>目录下,在这里手动删除即可，虽然简单粗暴；</p><h2 id="详细配置"><a href="#详细配置" class="headerlink" title="详细配置"></a>详细配置</h2><p>上面启动Docker Registry 服务对镜像进行管理,但是这个Registry还有些什么特性可以用于对镜像的管理呢？可以通过设置镜像启动容器的配置来管理,<br>首先在本地配置好自定义配置然后通过volume挂载到容器内部即可，这样Registry容器启动命令如下,<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">docker run -d --restart=always \</span><br><span class="line">-e REGISTRY_HTTP_ADDR=0.0.0.0:5001 \</span><br><span class="line">  -p 5000:5001 \</span><br><span class="line">  -v /opt/registry-var/auth/:/auth/ \</span><br><span class="line">  -e <span class="string">"REGISTRY_AUTH=htpasswd"</span> \</span><br><span class="line">  -e <span class="string">"REGISTRY_AUTH_HTPASSWD_REALM=Registry Realm"</span> \</span><br><span class="line">  -e REGISTRY_AUTH_HTPASSWD_PATH=/auth/htpasswd \</span><br><span class="line">  -v /opt/registry-var/:/var/lib/registry/ \</span><br><span class="line">-v /<span class="built_in">local</span>/path/to/config.yml:/etc/docker/registry/config.yml \</span><br><span class="line">  registry:latest</span><br></pre></td></tr></table></figure></p><p>其中Registry 容器的官方配置文件及配置字段参考官方即可<a href="https://docs.docker.com/registry/configuration/#list-of-configuration-options" target="_blank" rel="noopener">Registry配置文件及配置字段官方文档</a></p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ul><li>本文总结了如何搭建私有Docker Registry服务;</li><li>本文总结了如何设置认证权限,并建议在生成环境中同时配置证书认证及密码认证两道安全认证措施;</li><li>同时也演示了如何用搭建好的私有Docker Registry服务进行镜像上传下载删除等管理工作；</li><li>在总结本文时重点参考了官方文档, 发现之前在搭建Docker  Registry服务时并没有这么清楚，包括出现的错误等问题也是先通过搜索引擎来解决问题，但现在看来其实官方文档中也给出了可能存在的异常情况并给出了较为全面的解决方案;</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Docker Registry 是一个用来管理Docker镜像的服务，本身也是一个Docker容器。搭建一个私有的Docker Registry的使用场景主要有下面几个:&lt;br&gt;1.当需要对容器镜像存储进行完全控制,就不能依赖官方提供的Docker Hub进行管理;&lt;br&gt;2.当内部使用存在网络问题或安全问题等情况都适合搭建私有的Docker Registry对镜像进行管理;&lt;/p&gt;
&lt;p&gt;下面从需频繁pull镜像到某内部机器上新建容器的需求来搭建需要认证访问的Docker Registry,这样同时可以解决网络依赖问题及安全问题, 下面是搭建Docker Registry过程的记录和总结;&lt;br&gt;
    
    </summary>
    
      <category term="docker-practice" scheme="http://researchlab.github.io/categories/docker-practice/"/>
    
    
      <category term="docker" scheme="http://researchlab.github.io/tags/docker/"/>
    
  </entry>
  
  <entry>
    <title>一步一步构建自己的RPC server</title>
    <link href="http://researchlab.github.io/2017/03/20/build-rpc-server-in-golang/"/>
    <id>http://researchlab.github.io/2017/03/20/build-rpc-server-in-golang/</id>
    <published>2017-03-20T21:28:14.000Z</published>
    <updated>2018-10-16T13:03:07.481Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://en.wikipedia.org/wiki/Remote_procedure_call" target="_blank" rel="noopener">远程程序调用(Remote procedure call, RPC)</a>是进程间通信的一种基本形式， 并且广泛用于分布式计算中。下面就通过一步一步构建一个简单的RPC服务器来总结加深对RPC应用的理解。</p><a id="more"></a><h2 id="公共接口和结构"><a href="#公共接口和结构" class="headerlink" title="公共接口和结构"></a>公共接口和结构</h2><p>方便起见，假设有一个包含<code>Multiply</code>和<code>Divide</code>方法的接口， 这两个接口分别表示乘法<code>*</code>和除法<code>/</code>操作，另外存在一个<code>Args</code>的结构体用于将客户端参数传递到服务器端， 还存在一个<code>Quotient</code>的公共结构，用于表示乘法和除法操作的输出结果，具体如下，</p><p>公共结构<br><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//file: shared_structs.go</span></span><br><span class="line"><span class="keyword">package</span> shared </span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Args <span class="keyword">struct</span> &#123;</span><br><span class="line">A, B <span class="keyword">int</span> </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Quotient <span class="keyword">struct</span> &#123;</span><br><span class="line">Quo, Rem <span class="keyword">int</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>公共接口<br><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//file interface.go </span></span><br><span class="line"></span><br><span class="line"><span class="keyword">package</span> shared </span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Arith <span class="keyword">interface</span> &#123;</span><br><span class="line">Multiply(args *Args, reply *<span class="keyword">int</span>) error</span><br><span class="line">Divide(args *Args, quo *Quotient) error</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="接口实现"><a href="#接口实现" class="headerlink" title="接口实现"></a>接口实现</h2><p>下面简单实现上述定义的公共接口， 具体如下，<br><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//file interface_implementation.go </span></span><br><span class="line"></span><br><span class="line"><span class="keyword">package</span> main </span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span>(</span><br><span class="line"><span class="string">"shared"</span> </span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">// Every method that we want to export must have </span></span><br><span class="line"><span class="comment">// (1) the method has two arguments, both exported(or builtin) types</span></span><br><span class="line"><span class="comment">// (2) the method's second argument is a pointer </span></span><br><span class="line"><span class="comment">// (3) the method has return type error</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Arith <span class="keyword">int</span> </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(t *Arith)</span> <span class="title">Multiply</span><span class="params">(args *shared.Args, reply *<span class="keyword">int</span>)</span> <span class="title">error</span></span>&#123;</span><br><span class="line">*reply = args.A * args.B </span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(t * Arith)</span> <span class="title">Divide</span><span class="params">(args *shared.Args, quo *shared.Quotient)</span> <span class="title">error</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span> args.B == <span class="number">0</span> &#123;</span><br><span class="line"><span class="keyword">return</span> errors.New(<span class="string">"divide by zero"</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">quo.Quo = args.A / args.B</span><br><span class="line">quo.Rem = args.A % args.B </span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span> </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="RPC-server-实现"><a href="#RPC-server-实现" class="headerlink" title="RPC server 实现"></a>RPC server 实现</h2><p>可以通过HTTP协议或TCP协议来实现一个RPC server, 下面用这两种方式分别实现RPC server。</p><h3 id="HTTP-RPC-server-client"><a href="#HTTP-RPC-server-client" class="headerlink" title="HTTP RPC server/client"></a>HTTP RPC server/client</h3><ul><li><p>HTTP RPC server 实现<br>这种方法即先通过监听HTTP 协议链接，然后转换到RPC 协议上， 这种方法的好处是可以很方便对客户端链接请求进行授权验证，因为HTTP可以方便地支持多种授权验证，具体实现如下， </p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// file: server_http.go </span></span><br><span class="line"><span class="keyword">package</span> main </span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span>(</span><br><span class="line"><span class="string">"errors"</span></span><br><span class="line"><span class="string">"log"</span></span><br><span class="line"><span class="string">"net"</span></span><br><span class="line"><span class="string">"net/http"</span></span><br><span class="line"><span class="string">"net/rpc"</span></span><br><span class="line"></span><br><span class="line"><span class="string">"shared"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">registerArith</span><span class="params">(server *rpc.Server, arith shared.Arith)</span></span> &#123;</span><br><span class="line"><span class="comment">// registers Arith interface by name of `Arithmetic`.</span></span><br><span class="line"><span class="comment">// If you want this name to be same as the type name, you can </span></span><br><span class="line"><span class="comment">// use server.Register instead.</span></span><br><span class="line">server.RegisterName(<span class="string">"Arithmetic"</span>, arith)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="comment">// Creating an instance of struct which implement Arith interface </span></span><br><span class="line">arith := <span class="built_in">new</span>(Arith)</span><br><span class="line"></span><br><span class="line"><span class="comment">// Register a new rpc server (In most cases, you will use default server only) </span></span><br><span class="line"><span class="comment">// And register struct we created above by name "Arith"</span></span><br><span class="line"><span class="comment">// The wrapper method here ensures that only structs which implement Arith interface</span></span><br><span class="line"><span class="comment">// are allowed to register themselves. </span></span><br><span class="line"></span><br><span class="line">server := rpc.NewServer()</span><br><span class="line">registerArith(server, arith)</span><br><span class="line"></span><br><span class="line"><span class="comment">// registers an HTTP handler for RPC messages on rpcPath, and a debugging handler on debugPath</span></span><br><span class="line">server.HandleHTTP(<span class="string">"/"</span>, <span class="string">"/debug"</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// Listen for incoming tcp packets on specified port. </span></span><br><span class="line">l, e := net.Listen(<span class="string">"tcp"</span>, <span class="string">":1234"</span>)</span><br><span class="line"><span class="keyword">if</span> e != <span class="literal">nil</span> &#123;</span><br><span class="line">log.Fatal(<span class="string">"listen error:"</span>, e)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// This statement starts go's http server on </span></span><br><span class="line"><span class="comment">// socket specified by l .</span></span><br><span class="line">http.Serve(l, <span class="literal">nil</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>HTTP RPC Client </p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// file: client_http.go </span></span><br><span class="line"></span><br><span class="line"><span class="keyword">package</span> main </span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span>(</span><br><span class="line"><span class="string">"fmt"</span></span><br><span class="line"><span class="string">"log"</span></span><br><span class="line"><span class="string">"net/rpc"</span></span><br><span class="line"></span><br><span class="line"><span class="string">"shared"</span> </span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Arith <span class="keyword">struct</span> &#123;</span><br><span class="line">client *rpc.Client </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(t * Arith)</span> <span class="title">Divide</span><span class="params">(a, b <span class="keyword">int</span>)</span> <span class="title">shared</span>.<span class="title">Quotient</span></span>&#123;</span><br><span class="line">args := &amp;shared.Args&#123;a, b&#125;</span><br><span class="line"><span class="keyword">var</span> reply shared.Quotient </span><br><span class="line">err := t.client.Call(<span class="string">"Arithmetic.Divide"</span>, args, &amp;reply)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">log.Fatal(<span class="string">"arith error:"</span>, err)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> reply</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(t *Arith)</span><span class="title">Multiply</span><span class="params">(a, b <span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">args := &amp;shared.Args&#123;a, b&#125; </span><br><span class="line"><span class="keyword">var</span> reply <span class="keyword">int</span> </span><br><span class="line">err := t.client.Call(<span class="string">"Arithmetic.Multiply"</span>, args, &amp;reply)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">log.Fatal(<span class="string">"arith error:"</span>, err)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> reply</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="comment">// Tries to connect to localhost:1234 using HTTP protocol (The port on which rpc server is listening)</span></span><br><span class="line">client, err := rpc.DialHTTP(<span class="string">"tcp"</span>, <span class="string">"localhost:1234"</span>)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">log.Fatal(<span class="string">"dialing:"</span>, err)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Create a struct, that mimics all methods provided by interface.</span></span><br><span class="line"><span class="comment">// It is not compulsory, we are doing it here, just to simulate a traditional method call.</span></span><br><span class="line">arith := &amp;Arith&#123;client: client&#125;</span><br><span class="line">fmt.Println(arith.Multiply(<span class="number">5</span>, <span class="number">6</span>)) </span><br><span class="line">    fmt.Println(arith.Divide(<span class="number">500</span>, <span class="number">10</span>))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h3 id="TCP-RPC-server-client"><a href="#TCP-RPC-server-client" class="headerlink" title="TCP RPC server/client"></a>TCP RPC server/client</h3><p>上述通过<code>HTTP</code>协议实现来一个RPC server/client, 但是需要先监听HTTP协议链接，然后转换到RPC协议上来， 这就多了一个转换操作， 下面通过TCP协议来实现RPC server， 则可以直接监听链接，无需依赖HTTP协议， 具体实现如下，</p><ul><li>TCP RPC server </li></ul><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// file: tcp_server.go</span></span><br><span class="line"><span class="keyword">package</span> main </span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span>(</span><br><span class="line"><span class="string">"errors"</span></span><br><span class="line"><span class="string">"log"</span></span><br><span class="line"><span class="string">"net"</span></span><br><span class="line"><span class="string">"net/rpc"</span></span><br><span class="line"><span class="string">"shared"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">registerArith</span><span class="params">(server *rpc.Server, arith shared.Arith)</span></span> &#123;</span><br><span class="line"><span class="comment">// registers Arith interface by name of `Arithmetic`. </span></span><br><span class="line"><span class="comment">// If you want this name to be same as the type name, you </span></span><br><span class="line"><span class="comment">// can use server.Register instead. </span></span><br><span class="line">server.RegisterName(<span class="string">"Arithmetic"</span>, arith)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="comment">// Creating an instance of struct which implement Arith interface</span></span><br><span class="line">arith := <span class="built_in">new</span>(Arith)</span><br><span class="line"></span><br><span class="line"><span class="comment">// Register a new rpc server (In most cases, you will use default server only) </span></span><br><span class="line"><span class="comment">// And register struct we created above by name "Arith"</span></span><br><span class="line"><span class="comment">// The wrapper method here ensures that only structs which iplement Arith interface </span></span><br><span class="line"><span class="comment">// are allowed to register themselves.</span></span><br><span class="line">server := rpc.NewServer()</span><br><span class="line">registerArith(server, arith)</span><br><span class="line"></span><br><span class="line"><span class="comment">// Listen for incoming tcp packets on specified port. </span></span><br><span class="line">l, e := net.Listen(<span class="string">"tcp"</span>, <span class="string">":1234"</span>)</span><br><span class="line"><span class="keyword">if</span> e != <span class="literal">nil</span> &#123;</span><br><span class="line">log.Fatal(<span class="string">"listen error:"</span>, e)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//This statment links rpc server to the socket, and allows rpc server to accept </span></span><br><span class="line"><span class="comment">// rpc request comming from that socket. </span></span><br><span class="line">server.Accept(l)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>TCP RPC client </li></ul><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// file: tcp_client.go </span></span><br><span class="line"><span class="keyword">package</span> main </span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span>(</span><br><span class="line"><span class="string">"fmt"</span></span><br><span class="line"><span class="string">"log"</span></span><br><span class="line"><span class="string">"net"</span></span><br><span class="line"><span class="string">"net/rpc"</span></span><br><span class="line"><span class="string">"shared"</span> </span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Arith <span class="keyword">struct</span> &#123;</span><br><span class="line">client *rpc.Client </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(t *Arith)</span> <span class="title">Divide</span><span class="params">(a, b <span class="keyword">int</span>)</span> <span class="title">shared</span>.<span class="title">Quotient</span></span> &#123;</span><br><span class="line">args := &amp;shared.Args&#123;a, b&#125;</span><br><span class="line"><span class="keyword">var</span> reply shared.Quotient </span><br><span class="line">err := t.client.Call(<span class="string">"Arithmetic.Divide"</span>, args, &amp;reply)</span><br><span class="line"><span class="keyword">if</span> err !=<span class="literal">nil</span> &#123;</span><br><span class="line">log.Fatal(<span class="string">"arith error:"</span>, err)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> reply</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(t *Arith)</span> <span class="title">Multiply</span><span class="params">(a, b <span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">args := &amp;shared.Args&#123;a, b&#125;</span><br><span class="line"><span class="keyword">var</span> reply <span class="keyword">int</span> </span><br><span class="line">err := t.client.Call(<span class="string">"Arithmetic.Multiply"</span>, args, &amp;reply)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">log.Fatal(<span class="string">"arith error:"</span>, err)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> reply</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="comment">// Tries to connect to localhost:1234 (The port on which rpc server is listening)</span></span><br><span class="line">conn, err := net.Dial(<span class="string">"tcp"</span>, <span class="string">"localhost:1234"</span>)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">log.Fatal(<span class="string">"Connectiong:"</span>, err)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Create a struct, that mimics all methods provided by interface. </span></span><br><span class="line"><span class="comment">// It is not compulsory, we are doing it here, just to simulate a tradional method call. </span></span><br><span class="line">arith := &amp;Arith&#123;client: rpc.NewClient(conn)&#125;</span><br><span class="line"></span><br><span class="line">fmt.Println(arith.Multiply(<span class="number">5</span>, <span class="number">6</span>))</span><br><span class="line">fmt.Println(arith.Divide(<span class="number">500</span>, <span class="number">10</span>))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ul><li>通过用HTTP协议和TCP协议分别实现了RPC 服务， 加深了对RPC应用的理解， </li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;a href=&quot;https://en.wikipedia.org/wiki/Remote_procedure_call&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;远程程序调用(Remote procedure call, RPC)&lt;/a&gt;是进程间通信的一种基本形式， 并且广泛用于分布式计算中。下面就通过一步一步构建一个简单的RPC服务器来总结加深对RPC应用的理解。&lt;/p&gt;
    
    </summary>
    
      <category term="golang" scheme="http://researchlab.github.io/categories/golang/"/>
    
    
      <category term="golang" scheme="http://researchlab.github.io/tags/golang/"/>
    
      <category term="rpc" scheme="http://researchlab.github.io/tags/rpc/"/>
    
  </entry>
  
  <entry>
    <title>docker实践--06 运行MongoDB和Redis</title>
    <link href="http://researchlab.github.io/2017/03/08/docker-run-mongodb-redis/"/>
    <id>http://researchlab.github.io/2017/03/08/docker-run-mongodb-redis/</id>
    <published>2017-03-08T20:49:20.000Z</published>
    <updated>2018-10-16T13:03:07.485Z</updated>
    
    <content type="html"><![CDATA[<p>上篇文件总结了如何编写<code>Dockerfile</code>及如何通过<code>Dockerfile</code>构建镜像并运行相应的应用需求, 本文将通过编写<code>Dockerfile</code>来创建MongoDB和Redis应用进一步学习实践<code>Docker</code>的运行机制。<br><a id="more"></a></p><blockquote><p>MongoDB 是一个基于分布式文件存储的数据库。由C++语言编写。旨在为WEB应用提供可扩展的高性能数据存储解决方案。MongoDB 是一个介于关系数据库和非关系数据库之间的产品，是非关系数据库当中功能最丰富，最像关系数据库的数据库。特点是高性能、易部署、易使用，存储数据非常方便。 </p><p>Redis是一个开源的使用ANSI C语言编写、支持网络、可基于内存亦可持久化的日志型、Key-Value数据库，并提供多种语言的API。 </p></blockquote><p><strong> 需求 </strong><br>在Docker中创建MongoDB和Redis应用</p><p><strong> 需求分析 </strong></p><p>首先需要安装和配置<code>MongoDB</code> 和<code>Redis</code> 然后编写<code>Dockerfile</code> , 最后通过<code>Dockerfile</code>构建镜像, 并通过<code>docker run</code>基于该新镜像运行容器来创建MongoDB和Redis应用。</p><h2 id="编写Dockerfile"><a href="#编写Dockerfile" class="headerlink" title="编写Dockerfile"></a>编写Dockerfile</h2><p>向<code>Dockerfile</code>文件写入如下命令,<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Version 0.1 </span></span><br><span class="line"></span><br><span class="line"><span class="comment"># basic image</span></span><br><span class="line">FROM nbuntu:latest</span><br><span class="line"></span><br><span class="line"><span class="comment"># Maintainer</span></span><br><span class="line">MAINTAINER lihong/leehongitrd@163.com</span><br><span class="line"></span><br><span class="line"><span class="comment"># RUN </span></span><br><span class="line">RUN apt-get install -yqq supervisor &amp;&amp; apt-get clean </span><br><span class="line"></span><br><span class="line"><span class="comment"># CMD</span></span><br><span class="line"></span><br><span class="line">CMD [<span class="string">"supervisord"</span>]</span><br></pre></td></tr></table></figure></p><p>说明,<br>上述<code>FROM</code>镜像是采用自己重新修改过的镜像, 这个新的<code>nbuntu</code>镜像是安装了<code>ifconfig</code>, <code>ping</code>等<code>net-tools</code>工具的镜像;</p><p>为便于管理, 将安装ssh服务来提供便捷的管理<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">RUN apt-get install -yqq openssh-server openssh-client</span><br></pre></td></tr></table></figure></p><p>创建运行目录<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">RUN mkdir /var/run/sshd</span><br></pre></td></tr></table></figure></p><p>设置root密码及充许root通过ssh登录,<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">RUN <span class="built_in">echo</span> <span class="string">'root:123456'</span> | chpasswd</span><br><span class="line"><span class="comment">#RUN sed -i 's/PermitRootLogin without-password/PermitRootLogin yes/' /etc/ssh/sshd_config</span></span><br><span class="line">RUN sed -i <span class="string">'s/PermitRootLogin prohibit-password/PermitRootLogin yes/'</span> /etc/ssh/sshd_config</span><br></pre></td></tr></table></figure></p><p>注: ubuntu系统的不同版本中设置充许root通过ssh登录的命令是不同的，如在ubuntu14.04版本中是如下命令，<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">RUN sed -i <span class="string">'s/PermitRootLogin without-password/PermitRootLogin yes/'</span> /etc/ssh/sshd_config</span><br></pre></td></tr></table></figure></p><p>而在ubuntu16.04.2版本中, 则为如下命令,<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">RUN sed -i <span class="string">'s/PermitRootLogin prohibit-password/PermitRootLogin yes/'</span> /etc/ssh/sshd_config</span><br></pre></td></tr></table></figure></p><p>现在<code>Dockerfile</code>如下所示,<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Version 0.1</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 基础镜像</span></span><br><span class="line">FROM nbuntu:latest</span><br><span class="line"></span><br><span class="line"><span class="comment"># 维护者信息</span></span><br><span class="line">MAINTAINER lihong/leehongitrd@163.com</span><br><span class="line"></span><br><span class="line"><span class="comment"># 镜像操作命令</span></span><br><span class="line">RUN apt-get -yqq update &amp;&amp; apt-get install -yqq supervisor</span><br><span class="line">RUN apt-get install -yqq openssh-server openssh-client</span><br><span class="line"></span><br><span class="line">RUN mkdir /var/run/sshd</span><br><span class="line">RUN <span class="built_in">echo</span> <span class="string">'root:123456'</span> | chpasswd</span><br><span class="line">RUN sed -i <span class="string">'s/PermitRootLogin prohibit-password/PermitRootLogin yes/'</span> /etc/ssh/sshd_config</span><br></pre></td></tr></table></figure></p><p>到目前为止<code>Dockerfile</code>如上述所示, 下面要分别编写<code>MongoDB</code>和<code>Redis</code>的<code>Dockerfile</code>都将基于这个<code>Dockerfile</code>来完成,暂且将当前这个<code>Dockerfile</code>称为第一部分<code>Dockerfile</code>, 以便于区分下文中<code>MongoDB Dockerfile</code>和<code>Redis Dockerfile</code></p><h2 id="编写MongoDB-Dockerfile"><a href="#编写MongoDB-Dockerfile" class="headerlink" title="编写MongoDB Dockerfile"></a>编写MongoDB Dockerfile</h2><p>基于上述已经完成的第一部分<code>Dockerfile</code>编写<code>MongoDB</code>的<code>Dockerfile</code>。 首先将当前目录下(/home/lihong/docker)的<code>Dockerfile</code> 复制一份到/home/lihong/docker/mongodb目录下, 就从/home/lihong/docker/mongodb/Dockerfile的基础上编写下述<code>MongoDB</code>的<code>Dockerfile</code>,</p><p><strong> 1 安装MongoDB </strong></p><p>在Ubuntu上安装MongoDB有两种方法,</p><p>方法一: 添加mongodb的源, 执行<code>apt-get install mongodb-org</code>就可以安装下面的所有软件包,</p><ul><li><code>mongodb-org-server</code>：mongod 服务和配置文件</li><li><code>mongodb-org-mongos</code>：mongos 服务</li><li><code>mongodb-org-shell</code>：mongo shell工具</li><li><code>mongodb-org-tools</code>：mongodump，mongoexport等工具</li></ul><p>方法二: 下载二进制包，然后解压出来就可以。</p><p>本文推荐使用此方案, 从MongoDB官网得知下载链接如下：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">https://fastdl.mongodb.org/linux/mongodb-linux-x86_64-ubuntu1604-3.4.2.tgz</span><br></pre></td></tr></table></figure></p><p>使用<code>ADD</code>命令添加压缩包到镜像, 向<code>Dockerfile</code>中写入如下内容,<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">RUN mkdir -p /opt</span><br><span class="line">ADD https://fastdl.mongodb.org/linux/mongodb-linux-x86_64-ubuntu1604-3.4.2.tgz /opt/mongodb.tar.gz</span><br><span class="line">RUN <span class="built_in">cd</span> /opt &amp;&amp; tar zxvf mongodb.tar.gz &amp;&amp; rm -rf mongodb.tar.gz</span><br><span class="line">RUN mv /opt/mongodb-linux-x86_64-ubuntu1604-3.4.2 /opt/mongodb</span><br></pre></td></tr></table></figure></p><p>接下来创建<code>MongoDB</code>的数据存储目录,<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">RUN mkdir -p /data/db</span><br></pre></td></tr></table></figure></p><p>将<code>MongoDB</code>的执行路径添加到环境变量里,<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ENV PATH=/opt/mongodb/bin:<span class="variable">$PATH</span></span><br></pre></td></tr></table></figure></p><p><code>MongoDB</code>和<code>SSH</code>对外的端口：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">EXPOSE 27017 22</span><br></pre></td></tr></table></figure></p><p><strong> 2 编写Supervisord配置文件 </strong></p><p>添加<code>Supervisord</code>配置文件来启动<code>mongodb</code>和<code>ssh</code>, 创建文件<code>/home/lihong/docker/mongodb/supervisord.conf</code>, 添加以下内容,<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">[supervisord]</span><br><span class="line">nodaemon=<span class="literal">true</span></span><br><span class="line"></span><br><span class="line">[program:mongodb]</span><br><span class="line"><span class="built_in">command</span>=/opt/mongodb/bin/mongod</span><br><span class="line"></span><br><span class="line">[program:ssh]</span><br><span class="line"><span class="built_in">command</span>=/usr/sbin/sshd -D</span><br></pre></td></tr></table></figure></p><p>在<code>Dockerfile</code>中增加向镜像内拷贝该文件的命令,<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">COPY supervisord.conf /etc/supervisor/conf.d/supervisord.conf</span><br></pre></td></tr></table></figure></p><p><strong> 3 完整的MongoDB Dockerfile </strong><br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Version 0.1</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 基础镜像</span></span><br><span class="line">FROM nbuntu:latest</span><br><span class="line"></span><br><span class="line"><span class="comment"># 维护者信息</span></span><br><span class="line">MAINTAINER lihong/leehongitrd@163.com</span><br><span class="line"></span><br><span class="line"><span class="comment"># 镜像操作命令</span></span><br><span class="line">RUN apt-get install -yqq supervisor</span><br><span class="line">RUN apt-get install -yqq openssh-server openssh-client</span><br><span class="line"></span><br><span class="line">RUN mkdir /var/run/sshd</span><br><span class="line">RUN <span class="built_in">echo</span> <span class="string">'root:123456'</span> | chpasswd</span><br><span class="line">RUN sed -i <span class="string">'s/PermitRootLogin prohibit-password/PermitRootLogin yes/'</span> /etc/ssh/sshd_config</span><br><span class="line"></span><br><span class="line">RUN mkdir -p /opt</span><br><span class="line">ADD https://fastdl.mongodb.org/linux/mongodb-linux-x86_64-ubuntu1604-3.4.2.tgz /opt/mongodb.tar.gz</span><br><span class="line">RUN <span class="built_in">cd</span> /opt &amp;&amp; tar zxvf mongodb.tar.gz &amp;&amp; rm -rf mongodb.tar.gz</span><br><span class="line">RUN mv /opt/mongodb-linux-x86_64-ubuntu1604-3.4.2 /opt/mongodb</span><br><span class="line"></span><br><span class="line">RUN mkdir -p /data/db</span><br><span class="line"></span><br><span class="line">ENV PATH=/opt/mongodb/bin:<span class="variable">$PATH</span></span><br><span class="line"></span><br><span class="line">COPY supervisord.conf /etc/supervisor/conf.d/supervisord.conf</span><br><span class="line"></span><br><span class="line">EXPOSE 27017 22</span><br><span class="line"></span><br><span class="line"><span class="comment"># 容器启动命令</span></span><br><span class="line">CMD [<span class="string">"supervisord"</span>]</span><br></pre></td></tr></table></figure></p><p><strong> 注 </strong>: 通常直接从官方ADD mongodb链接 <a href="https://fastdl.mongodb.org/linux/mongodb-linux-x86_64-ubuntu1604-3.4.2.tgz" target="_blank" rel="noopener">https://fastdl.mongodb.org/linux/mongodb-linux-x86_64-ubuntu1604-3.4.2.tgz</a>, 速度很慢, 另一种方法是直接先把这个下载地址通过浏览器把mongodb的tar包下载到/home/lihong/docker/mongodb/目录下, 因为ADD在添加tar包到docker里面时会自己帮你解压缩的, 所以上述命令就要做如下替换, 把原先的从http地址下载,<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">RUN mkdir -p /opt</span><br><span class="line">ADD https://fastdl.mongodb.org/linux/mongodb-linux-x86_64-ubuntu1604-3.4.2.tgz /opt/mongodb.tar.gz</span><br><span class="line">RUN <span class="built_in">cd</span> /opt &amp;&amp; tar zxvf mongodb.tar.gz &amp;&amp; rm -rf mongodb.tar.gz</span><br><span class="line">RUN mv /opt/mongodb-linux-x86_64-ubuntu1604-3.4.2 /opt/mongodb</span><br></pre></td></tr></table></figure></p><p>替换为现在直接加载tar的方式, 具体替换为,<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">RUN mkdir -p /opt</span><br><span class="line">ADD https://fastdl.mongodb.org/linux/mongodb-linux-x86_64-ubuntu1604-3.4.2.tgz /opt/</span><br><span class="line">RUN mv /opt/mongodb-linux-x86_64-ubuntu1604-3.4.2 /opt/mongodb</span><br></pre></td></tr></table></figure></p><h2 id="编写Redis-Dockerfile"><a href="#编写Redis-Dockerfile" class="headerlink" title="编写Redis Dockerfile"></a>编写Redis Dockerfile</h2><p>同样<code>Redis Dockerfile</code>也可以基于已经完成的第一部分<code>Dockerfile</code>来写, 首先将<code>/home/lihong/docker</code>下得第一部分<code>Dockerfile</code>拷贝到<code>/home/lihong/docker/redis</code>文件夹下, </p><p><strong> 1 安装 Redis </strong><br>向<code>Dockerfile</code>中写入如下内容,<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">RUN apt-get install redis-server</span><br></pre></td></tr></table></figure></p><p>添加redis和ssh对外的端口号,<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">EXPOSE 6379 22</span><br></pre></td></tr></table></figure></p><p><strong> 2 编写Supervisord配置文件 </strong></p><p>添加<code>Supervisord</code>配置文件来启动<code>redis-server</code>和<code>ssh</code> 创建文件<code>/home/lihong/docker/redis/supervisord.conf</code>, 添加以下内容,<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">[supervisord]</span><br><span class="line">nodaemon=<span class="literal">true</span></span><br><span class="line"></span><br><span class="line">[program:redis]</span><br><span class="line"><span class="built_in">command</span>=/usr/bin/redis-server</span><br><span class="line"></span><br><span class="line">[program:ssh]</span><br><span class="line"><span class="built_in">command</span>=/usr/sbin/sshd -D</span><br></pre></td></tr></table></figure></p><p>向Dockerfile中增加向镜像内拷贝该文件的命令：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">COPY supervisord.conf /etc/supervisor/conf.d/supervisord.conf</span><br></pre></td></tr></table></figure></p><p><strong> 3 完整的 Dockerfile </strong><br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Version 0.1</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 基础镜像</span></span><br><span class="line">FROM nbuntu:latest</span><br><span class="line"></span><br><span class="line"><span class="comment"># 维护者信息</span></span><br><span class="line">MAINTAINER lihong/leehongitrd@163.com </span><br><span class="line"></span><br><span class="line"><span class="comment"># 镜像操作命令</span></span><br><span class="line">RUN apt-get -yqq update &amp;&amp; apt-get install -yqq supervisor redis-server</span><br><span class="line">RUN apt-get install -yqq openssh-server openssh-client</span><br><span class="line"></span><br><span class="line">RUN mkdir /var/run/sshd</span><br><span class="line">RUN <span class="built_in">echo</span> <span class="string">'root:123456'</span> | chpasswd</span><br><span class="line">RUN sed -i <span class="string">'s/PermitRootLogin prohibit-password/PermitRootLogin yes/'</span> /etc/ssh/sshd_config</span><br><span class="line"></span><br><span class="line">COPY supervisord.conf /etc/supervisor/conf.d/supervisord.conf</span><br><span class="line"></span><br><span class="line">EXPOSE 6379 22</span><br><span class="line"></span><br><span class="line"><span class="comment"># 容器启动命令</span></span><br><span class="line">CMD [<span class="string">"supervisord"</span>]</span><br></pre></td></tr></table></figure></p><h2 id="创建镜像"><a href="#创建镜像" class="headerlink" title="创建镜像"></a>创建镜像</h2><p><strong> 1 创建MongoDB镜像 </strong><br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line">lihong@dev:~/docker/mongodb$ docker build -t mongodb:0.1 .</span><br><span class="line">Sending build context to Docker daemon 484.1 MB</span><br><span class="line">Step 1 : FROM nbuntu:latest</span><br><span class="line"> ---&gt; f16a2621960a</span><br><span class="line">Step 2 : MAINTAINER lihong/leehongitrd@163.com</span><br><span class="line"> ---&gt; Using cache</span><br><span class="line"> ---&gt; 834538265a0a</span><br><span class="line">Step 3 : RUN apt-get install -yqq supervisor</span><br><span class="line"> ---&gt; Running <span class="keyword">in</span> e7b54bcbd69f</span><br><span class="line"> ---&gt; 32e2892fba7c</span><br><span class="line">Step 4 : RUN apt-get install -yqq openssh-server openssh-client</span><br><span class="line"> ---&gt; Running <span class="keyword">in</span> 00102fd9088f</span><br><span class="line"> ---&gt; 5ce7cbf2a50e</span><br><span class="line">Step 5 : RUN mkdir /var/run/sshd</span><br><span class="line"> ---&gt; Running <span class="keyword">in</span> bb408fb2b0ba</span><br><span class="line"> ---&gt; bc1305d8403f</span><br><span class="line">Removing intermediate container bb408fb2b0ba</span><br><span class="line">Step 6 : RUN <span class="built_in">echo</span> <span class="string">'root:123456'</span> | chpasswd</span><br><span class="line"> ---&gt; Running <span class="keyword">in</span> 002fa189da1b</span><br><span class="line"> ---&gt; 2948cab7667d</span><br><span class="line">Removing intermediate container 002fa189da1b</span><br><span class="line">Step 7 : RUN sed -i <span class="string">'s/PermitRootLogin prohibit-password/PermitRootLogin yes/'</span> /etc/ssh/sshd_config</span><br><span class="line"> ---&gt; Running <span class="keyword">in</span> b6bb01e8363c</span><br><span class="line"> ---&gt; 12e5f0b915f6</span><br><span class="line">Removing intermediate container b6bb01e8363c</span><br><span class="line">Step 8 : RUN mkdir -p /opt</span><br><span class="line"> ---&gt; Running <span class="keyword">in</span> 5fceaab69914</span><br><span class="line"> ---&gt; 36e5128476ad</span><br><span class="line">Removing intermediate container 5fceaab69914</span><br><span class="line">Step 9 : ADD mongodb-linux-x86_64-ubuntu1604-3.4.2.tgz /opt/</span><br><span class="line"> ---&gt; 746c06c2955a</span><br><span class="line">Removing intermediate container 1ad6994dffbf</span><br><span class="line">Step 10 : RUN mv /opt/mongodb-linux-x86_64-ubuntu1604-3.4.2 /opt/mongodb</span><br><span class="line"> ---&gt; Running <span class="keyword">in</span> 8aee03f3ff1f</span><br><span class="line"> ---&gt; bb59a44e388e</span><br><span class="line">Removing intermediate container 8aee03f3ff1f</span><br><span class="line">Step 11 : RUN mkdir -p /data/db</span><br><span class="line"> ---&gt; Running <span class="keyword">in</span> d824290aeeda</span><br><span class="line"> ---&gt; 524ea3b42ee7</span><br><span class="line">Removing intermediate container d824290aeeda</span><br><span class="line">Step 12 : ENV PATH /opt/mongodb/bin:<span class="variable">$PATH</span></span><br><span class="line"> ---&gt; Running <span class="keyword">in</span> 528b7eb1ebd2</span><br><span class="line"> ---&gt; 4f20f47cb729</span><br><span class="line">Removing intermediate container 528b7eb1ebd2</span><br><span class="line">Step 13 : COPY supervisord.conf /etc/supervisor/conf.d/supervisord.conf</span><br><span class="line"> ---&gt; 81b25cae6dfb</span><br><span class="line">Removing intermediate container 2925012500cb</span><br><span class="line">Step 14 : EXPOSE 27017 22</span><br><span class="line"> ---&gt; Running <span class="keyword">in</span> e6b39c60ba24</span><br><span class="line"> ---&gt; 357fcd3fce1b</span><br><span class="line">Removing intermediate container e6b39c60ba24</span><br><span class="line">Step 15 : CMD supervisord</span><br><span class="line"> ---&gt; Running <span class="keyword">in</span> 750793c619bf</span><br><span class="line"> ---&gt; 73fc5cf01a32</span><br><span class="line">Removing intermediate container 750793c619bf</span><br><span class="line">Successfully built 73fc5cf01a32</span><br><span class="line">lihong@dev:~/docker/mongodb$ docker images</span><br><span class="line">REPOSITORY          TAG                 IMAGE ID            CREATED             SIZE</span><br><span class="line">mongodb             0.1                 73fc5cf01a32        6 seconds ago       824.1 MB</span><br><span class="line">redis               0.1                 e4bd400dd3fd        12 hours ago        258.9 MB</span><br><span class="line">nbuntu              latest              f16a2621960a        21 hours ago        174.2 MB</span><br><span class="line">redis               latest              e4a35914679d        8 days ago          182.9 MB</span><br><span class="line">ubuntu              latest              0ef2e08ed3fa        9 days ago          130 MB</span><br><span class="line">lihong@dev:~/docker/mongodb$</span><br></pre></td></tr></table></figure></p><p>可以看到新镜像mongodb:0.1已经创建好了, 下面通过mongodb:0.1镜像创建一个新容器mongodb_demo,<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">lihong@dev:~/docker/mongodb$ docker run -P -d --name mongodb_demo mongodb:0.1</span><br><span class="line">7a80d0577f98c9071aaf7c491968bf66a6dc68e6d818c8563ee0b3a08cb25a31</span><br><span class="line">lihong@dev:~/docker/mongodb$ docker ps</span><br><span class="line">CONTAINER ID        IMAGE               COMMAND             CREATED             STATUS              PORTS                                             NAMES</span><br><span class="line">7a80d0577f98        mongodb:0.1         <span class="string">"supervisord"</span>       7 seconds ago       Up 4 seconds        0.0.0.0:32775-&gt;22/tcp, 0.0.0.0:32774-&gt;27017/tcp   mongodb_demo</span><br></pre></td></tr></table></figure></p><p>上述<code>docker ps</code>命令的输出可以看到<code>MongoDB</code>的端口号已经被自动映射到了本地的<code>32774</code>端口，下面对<code>MongoDB</code>是否启动进行测试,<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">lihong@dev:~/docker/mongodb$ docker ps</span><br><span class="line">CONTAINER ID        IMAGE               COMMAND             CREATED             STATUS              PORTS                                             NAMES</span><br><span class="line">7a80d0577f98        mongodb:0.1         <span class="string">"supervisord"</span>       4 minutes ago       Up 4 minutes        0.0.0.0:32775-&gt;22/tcp, 0.0.0.0:32774-&gt;27017/tcp   mongodb_demo</span><br><span class="line">cc8b65b87a75        redis:0.1           <span class="string">"supervisord"</span>       12 hours ago        Up 12 hours         0.0.0.0:32773-&gt;22/tcp, 0.0.0.0:32772-&gt;6379/tcp    redis_demo</span><br><span class="line">lihong@dev:~/docker/mongodb$ mongo --host 127.0.0.1 --port 32774</span><br><span class="line">MongoDB shell version: 2.6.10</span><br><span class="line">connecting to: 127.0.0.1:32774/<span class="built_in">test</span></span><br><span class="line">Welcome to the MongoDB shell.</span><br><span class="line">For interactive <span class="built_in">help</span>, <span class="built_in">type</span> <span class="string">"help"</span>.</span><br><span class="line">For more comprehensive documentation, see</span><br><span class="line">       http://docs.mongodb.org/</span><br><span class="line">Questions? Try the support group</span><br><span class="line">       http://groups.google.com/group/mongodb-user</span><br><span class="line">Server has startup warnings:</span><br><span class="line">2017-03-09T03:59:06.614+0000 I CONTROL  [initandlisten]</span><br><span class="line">2017-03-09T03:59:06.614+0000 I CONTROL  [initandlisten] ** WARNING: Access control is not enabled <span class="keyword">for</span> the database.</span><br><span class="line">2017-03-09T03:59:06.615+0000 I CONTROL  [initandlisten] **          Read and write access to data and configuration is unrestricted.</span><br><span class="line">2017-03-09T03:59:06.615+0000 I CONTROL  [initandlisten] ** WARNING: You are running this process as the root user, <span class="built_in">which</span> is not recommended.</span><br><span class="line">2017-03-09T03:59:06.615+0000 I CONTROL  [initandlisten]</span><br><span class="line">2017-03-09T03:59:06.663+0000 I CONTROL  [initandlisten]</span><br><span class="line">2017-03-09T03:59:06.664+0000 I CONTROL  [initandlisten] ** WARNING: /sys/kernel/mm/transparent_hugepage/enabled is <span class="string">'always'</span>.</span><br><span class="line">2017-03-09T03:59:06.664+0000 I CONTROL  [initandlisten] **        We suggest setting it to <span class="string">'never'</span></span><br><span class="line">2017-03-09T03:59:06.664+0000 I CONTROL  [initandlisten]</span><br><span class="line">&gt; show dbs;</span><br><span class="line">admin  0.000GB</span><br><span class="line"><span class="built_in">local</span>  0.000GB</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></p><p>可以看到mongodb服务可用,<br><strong> 2 创建Redis镜像 </strong><br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">lihong@dev:~/docker/redis$ docker build -t redis:0.1 .</span><br><span class="line">Sending build context to Docker daemon 3.072 kB</span><br><span class="line">Step 1 : FROM nbuntu:latest</span><br><span class="line"> ---&gt; f16a2621960a</span><br><span class="line">Step 2 : MAINTAINER lihong/leehongitrd@163.com</span><br><span class="line"> ---&gt; Running <span class="keyword">in</span> 92081132374d</span><br><span class="line"> ---&gt; a33c13bf12cb</span><br><span class="line">Removing intermediate container 92081132374d</span><br><span class="line">Step 3 : RUN apt-get install -yqq supervisor redis-server</span><br><span class="line"> ---&gt; bdc6e761ea22</span><br><span class="line">Removing intermediate container c77d8bfd1c78</span><br><span class="line">Step 4 : RUN apt-get install -yqq openssh-server openssh-client</span><br><span class="line"> ---&gt; Running <span class="keyword">in</span> 970a77bef632</span><br><span class="line">Step 5 : RUN mkdir /var/run/sshd</span><br><span class="line"> ---&gt; Running <span class="keyword">in</span> e68f56b9eba0</span><br><span class="line"> ---&gt; 707b8b2bd7bc</span><br><span class="line">Removing intermediate container e68f56b9eba0</span><br><span class="line">Step 6 : RUN <span class="built_in">echo</span> <span class="string">'root:123456'</span> | chpasswd</span><br><span class="line"> ---&gt; Running <span class="keyword">in</span> e3c6f371c513</span><br><span class="line"> ---&gt; fc81cd175615</span><br><span class="line">Removing intermediate container e3c6f371c513</span><br><span class="line">Step 7 : RUN sed -i <span class="string">'s/PermitRootLogin prohibit-password/PermitRootLogin yes/'</span> /etc/ssh/sshd_config</span><br><span class="line"> ---&gt; Running <span class="keyword">in</span> c5a0a941b971</span><br><span class="line"> ---&gt; 2bef0836db0d</span><br><span class="line">Removing intermediate container c5a0a941b971</span><br><span class="line">Step 8 : COPY supervisord.conf /etc/supervisor/conf.d/supervisord.conf</span><br><span class="line"> ---&gt; 3e2692da94bc</span><br><span class="line">Removing intermediate container cf851760235f</span><br><span class="line">Step 9 : EXPOSE 6379 22</span><br><span class="line"> ---&gt; Running <span class="keyword">in</span> 84e24be61ab6</span><br><span class="line"> ---&gt; 9ed91e3e5d23</span><br><span class="line">Removing intermediate container 84e24be61ab6</span><br><span class="line">Step 10 : CMD supervisord</span><br><span class="line"> ---&gt; Running <span class="keyword">in</span> 3352a31501ce</span><br><span class="line"> ---&gt; d59c4c42bc34</span><br><span class="line">Removing intermediate container 3352a31501ce</span><br><span class="line">Successfully built d59c4c42bc34</span><br><span class="line">lihong@dev:~/docker/redis$ docker images</span><br><span class="line">REPOSITORY          TAG                 IMAGE ID            CREATED              SIZE</span><br><span class="line">redis               0.1                 d59c4c42bc34        About a minute ago   261.1 MB</span><br><span class="line">nbuntu              latest              f16a2621960a        8 hours ago          174.2 MB</span><br><span class="line">redis               latest              e4a35914679d        7 days ago           182.9 MB</span><br><span class="line">ubuntu              latest              0ef2e08ed3fa        8 days ago           130 MB</span><br><span class="line">lihong@dev:~/docker/redis$</span><br></pre></td></tr></table></figure></p><p>为检查新镜像redis:0.1能否提供redis服务, 下面基于新镜像redis:0.1创建新容器redis_demo,<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">lihong@dev:~/docker/redis$ docker run -P -d --name redis_demo redis:0.1</span><br><span class="line">cc8b65b87a75b02fef26dd4735841503ccea9db414cd88675d38b5359785d570</span><br></pre></td></tr></table></figure></p><p>通过<code>docker ps</code>命令可以看到<code>redis</code>的端口号已经被自动映射到了本地的<code>32770</code>端口，SSH服务的端口号也映射到了<code>32771</code> 端口。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">lihong@dev:~/docker/redis$ docker ps</span><br><span class="line">CONTAINER ID        IMAGE               COMMAND             CREATED             STATUS              PORTS                                            NAMES</span><br><span class="line">cc8b65b87a75        redis:0.1           <span class="string">"supervisord"</span>       6 seconds ago       Up 5 seconds        0.0.0.0:32773-&gt;22/tcp, 0.0.0.0:32772-&gt;6379/tcp   redis_demo</span><br></pre></td></tr></table></figure></p><p>通过ssh连接到redis_demo容器, 看到redis服务是可用的,<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">lihong@dev:~/docker/redis$ ssh root@127.0.0.1 -p 32773</span><br><span class="line">root@127.0.0.1<span class="string">'s password:</span></span><br><span class="line"><span class="string">Welcome to Ubuntu 16.04.2 LTS (GNU/Linux 4.8.0-41-generic x86_64)</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string"> * Documentation:  https://help.ubuntu.com</span></span><br><span class="line"><span class="string"> * Management:     https://landscape.canonical.com</span></span><br><span class="line"><span class="string"> * Support:        https://ubuntu.com/advantage</span></span><br><span class="line"><span class="string">Last login: Wed Mar  8 16:01:01 2017 from 172.17.0.1</span></span><br><span class="line"><span class="string">root@cc8b65b87a75:~# redis-cli</span></span><br><span class="line"><span class="string">127.0.0.1:6379&gt; get name</span></span><br><span class="line"><span class="string">(nil)</span></span><br><span class="line"><span class="string">127.0.0.1:6379&gt; set name mike</span></span><br><span class="line"><span class="string">OK</span></span><br><span class="line"><span class="string">127.0.0.1:6379&gt; get name</span></span><br><span class="line"><span class="string">"mike"</span></span><br><span class="line"><span class="string">127.0.0.1:6379&gt;</span></span><br><span class="line"><span class="string">root@cc8b65b87a75:~# exit</span></span><br><span class="line"><span class="string">logout</span></span><br><span class="line"><span class="string">Connection to 127.0.0.1 closed.</span></span><br><span class="line"><span class="string">lihong@dev:~/docker/redis$ redis-cli -h 127.0.0.1 -p 32772</span></span><br><span class="line"><span class="string">127.0.0.1:32772&gt; get name</span></span><br><span class="line"><span class="string">"mike"</span></span><br><span class="line"><span class="string">127.0.0.1:32772&gt;</span></span><br></pre></td></tr></table></figure></p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ul><li>通过在Docker上创建MongoDB和Redis应用, 进一步熟悉了Dockerfile的编写规则;</li><li>在新构建的镜像上创建容器, 并通过测试确认容器能提供MongoDB和Redis服务, 进一步熟悉容器的使用;</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;上篇文件总结了如何编写&lt;code&gt;Dockerfile&lt;/code&gt;及如何通过&lt;code&gt;Dockerfile&lt;/code&gt;构建镜像并运行相应的应用需求, 本文将通过编写&lt;code&gt;Dockerfile&lt;/code&gt;来创建MongoDB和Redis应用进一步学习实践&lt;code&gt;Docker&lt;/code&gt;的运行机制。&lt;br&gt;
    
    </summary>
    
      <category term="docker-practice" scheme="http://researchlab.github.io/categories/docker-practice/"/>
    
    
      <category term="docker" scheme="http://researchlab.github.io/tags/docker/"/>
    
  </entry>
  
  <entry>
    <title>docker实践--05 编写Dockerfile</title>
    <link href="http://researchlab.github.io/2017/03/07/docker-dockerfile/"/>
    <id>http://researchlab.github.io/2017/03/07/docker-dockerfile/</id>
    <published>2017-03-07T16:03:35.000Z</published>
    <updated>2018-10-16T13:03:07.485Z</updated>
    
    <content type="html"><![CDATA[<p>docker容器是在指定的镜像上运行的, 创建docker镜像的方法也有很多中比如直接到<code>docker Hub</code>上通过<code>docker pull</code>创建一个镜像, 也可以通过修改其它镜像然后提交修改<code>docker commit</code> 来创建新的镜像, 还有如导入某个现有的镜像, 但是在实际中难觅要定制化改进出符合特定场景的镜像, 虽然用上述方式也是可以创建新的镜像的, 但是缺点也很多, 主要缺点是不便于维护, 其实创建docker 镜像还有一种最好的办法就是手工打造<code>Dockerfile</code>, 然后通过<code>docker build</code>编译生成新的镜像, 下面本文就来实践怎么编写符合规范的Dockerfile, 然后又是怎么样通过Dockerfile来创建合适的镜像的。</p><a id="more"></a><p><strong> 需求 </strong><br>需求是完成一个<code>Dockerfile</code>, 通过该<code>Dockerfile</code>创建一个Web应用, 该web应用为apache托管的一个静态页面网站, 换句话说, 我们写一个<code>Dockerfile</code>, 用来创建一个实验楼公司的网站应用, 就是 <a href="http://www.simplecloud.cn" target="_blank" rel="noopener">http://www.simplecloud.cn</a> 这个站点。这个站点是纯静态的页面, 我们也可以直接下载得到。<br>从实现这个需求中去实践和学习关于<code>Dockerfile</code>如下三方面的内容,</p><ul><li>了解Dockerfile 基本框架</li><li>学习Dockerfile 编写常用命令</li><li>通过Dockerfile 构建镜像</li></ul><h2 id="Dockerfile基本框架"><a href="#Dockerfile基本框架" class="headerlink" title="Dockerfile基本框架"></a>Dockerfile基本框架</h2><p>一份Dockerfile一般包含下面几个部分,</p><ul><li><code>基础镜像</code>：以哪个镜像作为基础进行制作，用法是<code>FROM 基础镜像名称</code></li><li><code>维护者信息</code>：需要写下该Dockerfile编写人的姓名或邮箱，用法是<code>MANITAINER 名字/邮箱</code></li><li><code>镜像操作命令</code>：对基础镜像要进行的改造命令，比如安装新的软件，进行哪些特殊配置等，常见的是<code>RUN</code>命令</li><li><code>容器启动命令</code>：当基于该镜像的容器启动时需要执行哪些命令，常见的是<code>CMD</code>命令或<code>ENTRYPOINT</code></li></ul><p>下面创建一份Dockerfile 输入如下内容,<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Version 0.1</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 基础镜像</span></span><br><span class="line">FROM nbuntu:latest</span><br><span class="line"></span><br><span class="line"><span class="comment"># 维护者信息</span></span><br><span class="line">MAINTAINER lihong/leehongitrd@163.com </span><br><span class="line"></span><br><span class="line"><span class="comment"># 镜像操作命令</span></span><br><span class="line">RUN apt-get -yqq update &amp;&amp; apt-get install -yqq apache2 &amp;&amp; apt-get clean</span><br><span class="line"></span><br><span class="line"><span class="comment"># 容器启动命令</span></span><br><span class="line">CMD [<span class="string">"/usr/sbin/apache2ctl"</span>, <span class="string">"-D"</span>, <span class="string">"FOREGROUND"</span>]</span><br></pre></td></tr></table></figure></p><blockquote><p>因为直接FROM ubuntu:latest 创建的镜像, 然后基于这个镜像运行的容器中是没有<code>ifconfig, ping</code>等命令的， 所以为了本次试验自己就新建了一个镜像nbuntu, 这个镜像就包含了<code>ifconfig, ping</code>等命令</p></blockquote><p>上面的<code>Dockerfile</code>就做了一件事，即创建一个apache的镜像,</p><ul><li><code>FROM</code>指定基础镜像，如果镜像名称中没有制定<code>TAG</code>, 默认为<code>latest</code>。</li><li><code>RUN</code>命令默认使用/bin/sh Shell执行，默认为root权限。如果命令过长需要换行，需要在行末尾加<code>\\</code>。</li><li><code>CMD</code> 命令也是默认在/bin/sh Shell中执行，并且默认只能有一条，如果是多条CMD命令则只有最后一条执行。用户也可以在docker run命令创建容器时指定新的CMD命令来覆盖Dockerfile里的CMD。</li></ul><p>用<code>docker build</code>将上述<code>Dockerfile</code>构建名为<code>test:0.1</code>的新镜像,<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line">lihong@dev:~/docker$ docker build -t <span class="built_in">test</span>:0.1 .</span><br><span class="line">Sending build context to Docker daemon 2.048 kB</span><br><span class="line">Step 1 : FROM nbuntu:latest</span><br><span class="line"> ---&gt; f16a2621960a</span><br><span class="line">Step 2 : MAINTAINER lihong/leehongitrd@163.com</span><br><span class="line"> ---&gt; Running <span class="keyword">in</span> 668004fe61bd</span><br><span class="line"> ---&gt; cb74681dcdc9</span><br><span class="line">Removing intermediate container 668004fe61bd</span><br><span class="line">Step 3 : RUN apt -yqq update &amp;&amp; apt install -yqq apache2 &amp;&amp; apt clean</span><br><span class="line"> ---&gt; Running <span class="keyword">in</span> 00968a59fa09</span><br><span class="line"></span><br><span class="line">The following additional packages will be installed:</span><br><span class="line">  apache2-bin apache2-data apache2-utils file ifupdown iproute2</span><br><span class="line">  isc-dhcp-client isc-dhcp-common libapr1 libaprutil1 libaprutil1-dbd-sqlite3</span><br><span class="line">  libaprutil1-ldap libasn1-8-heimdal libatm1 libdns-export162 libexpat1</span><br><span class="line">  libgdbm3 libgssapi3-heimdal libhcrypto4-heimdal libheimbase1-heimdal</span><br><span class="line">  libheimntlm0-heimdal libhx509-5-heimdal libicu55 libisc-export160</span><br><span class="line">  libkrb5-26-heimdal libldap-2.4-2 liblua5.1-0 libmagic1 libmnl0 libperl5.22</span><br><span class="line">  libroken18-heimdal libsasl2-2 libsasl2-modules libsasl2-modules-db</span><br><span class="line">  libsqlite3-0 libssl1.0.0 libwind0-heimdal libxml2 libxtables11 mime-support</span><br><span class="line">  netbase openssl perl perl-modules-5.22 rename sgml-base ssl-cert xml-core</span><br><span class="line">Suggested packages:</span><br><span class="line">  www-browser apache2-doc apache2-suexec-pristine | apache2-suexec-custom ufw</span><br><span class="line">  ppp rdnssd iproute2-doc resolvconf avahi-autoipd isc-dhcp-client-ddns</span><br><span class="line">  apparmor libsasl2-modules-otp libsasl2-modules-ldap libsasl2-modules-sql</span><br><span class="line">  libsasl2-modules-gssapi-mit | libsasl2-modules-gssapi-heimdal</span><br><span class="line">  ca-certificates perl-doc libterm-readline-gnu-perl</span><br><span class="line">  | libterm-readline-perl-perl make sgml-base-doc openssl-blacklist debhelper</span><br><span class="line">The following NEW packages will be installed:</span><br><span class="line">  apache2 apache2-bin apache2-data apache2-utils file ifupdown iproute2</span><br><span class="line">  isc-dhcp-client isc-dhcp-common libapr1 libaprutil1 libaprutil1-dbd-sqlite3</span><br><span class="line">  libaprutil1-ldap libasn1-8-heimdal libatm1 libdns-export162 libexpat1</span><br><span class="line">  libgdbm3 libgssapi3-heimdal libhcrypto4-heimdal libheimbase1-heimdal</span><br><span class="line">  libheimntlm0-heimdal libhx509-5-heimdal libicu55 libisc-export160</span><br><span class="line">  libkrb5-26-heimdal libldap-2.4-2 liblua5.1-0 libmagic1 libmnl0 libperl5.22</span><br><span class="line">  libroken18-heimdal libsasl2-2 libsasl2-modules libsasl2-modules-db</span><br><span class="line">  libsqlite3-0 libssl1.0.0 libwind0-heimdal libxml2 libxtables11 mime-support</span><br><span class="line">  netbase openssl perl perl-modules-5.22 rename sgml-base ssl-cert xml-core</span><br><span class="line">debconf: delaying package configuration, since apt-utils is not installed</span><br><span class="line">0 upgraded, 49 newly installed, 0 to remove and 0 not upgraded.</span><br><span class="line">Need to get 21.4 MB of archives.</span><br><span class="line">After this operation, 98.3 MB of additional disk space will be used.</span><br><span class="line">Step 4 : CMD /usr/sbin/apache2ctl -D FOREGROUND</span><br><span class="line"> ---&gt; Running <span class="keyword">in</span> f954154994b2</span><br><span class="line"> ---&gt; 4abe06cc549a</span><br><span class="line">Removing intermediate container f954154994b2</span><br><span class="line">Successfully built 4abe06cc549a</span><br></pre></td></tr></table></figure></p><p>查看新创建的镜像test:0.1,<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">lihong@dev:~/docker$ docker images</span><br><span class="line">REPOSITORY          TAG                 IMAGE ID            CREATED             SIZE</span><br><span class="line"><span class="built_in">test</span>                0.1                 4abe06cc549a        24 seconds ago      274.1 MB</span><br><span class="line">nbuntu              latest              f16a2621960a        4 hours ago         174.2 MB</span><br><span class="line">redis               latest              e4a35914679d        7 days ago          182.9 MB</span><br><span class="line">ubuntu              latest              0ef2e08ed3fa        8 days ago          130 MB</span><br></pre></td></tr></table></figure></p><p>使用该镜像创建容器web1, 将容器中的端口80映射到本地80端口,<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">lihong@dev:~/docker$ docker run -d -p 80:80 --name web1 <span class="built_in">test</span>:0.1</span><br><span class="line">27479a43f119d213509c9af6cdfcd43330f55ed0c4fbeb08fbc3dd434744f36e</span><br></pre></td></tr></table></figure></p><p>通过firefox浏览器打开localhost进行测试，apache已运行,</p><center><img src="imgs/apache.png" alt="apache"></center><h2 id="编写Dockerfile常用命令"><a href="#编写Dockerfile常用命令" class="headerlink" title="编写Dockerfile常用命令"></a>编写Dockerfile常用命令</h2><p>如果构建镜像需求变更, 则只需将其增加到Dockerfile中即可。</p><p><strong> 1 指定容器运行的用户 </strong></p><p> 在一些需要指定用户来运行的应用部署时非常关键，比如提供hadoop服务的容器通常会使用hadoop用户来启动服务。该用户将作为后续的RUN命令执行的用户; 例如使用mike用户来执行后续命令, 将下面的命令添加Dockerfile中， 放置到要执行的命令之前即可，<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">USER mike</span><br></pre></td></tr></table></figure></p><p><strong> 2 指定后续命令的执行目录 </strong></p><p>假如后继需要运行的是一个静态网站，将启动后的工作目录切换到/var/www/html目录, 则,<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">WORKDIR /var/www/html</span><br></pre></td></tr></table></figure></p><p><strong> 3 对外连接端口号 </strong><br>由于内部服务会启动Web服务，我们需要把对应的80端口暴露出来，可以提供给容器间互联使用，可以使用<code>EXPOSE</code>命令。<br>在镜像操作部分增加下面一句,<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">EXPOSE 80</span><br></pre></td></tr></table></figure></p><p><strong> 4 设置容器主机名 </strong></p><p><code>ENV</code>命令能够对容器内的环境变量进行设置, 使用该命令设置由该镜像创建的容器的主机名为dev, 向Dockerfile中增加下面一句,<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ENV HOSTNAME dev</span><br></pre></td></tr></table></figure></p><p><strong> 5 向镜像中增加文件 </strong></p><p>向镜像中添加文件有两种命令:<code>COPY</code> 和<code>ADD</code>。</p><p><code>COPY</code>命令可以复制本地文件夹到镜像中,<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">COPY website /var/www/html</span><br></pre></td></tr></table></figure></p><p><code>ADD</code>命令支持添加本地的<code>tar压缩包</code>到容器中指定目录, 压缩包会被自动解压为目录, 也可以自动下载URL并拷贝到镜像, 例如,<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ADD html.tar /var/www</span><br><span class="line">ADD http://www.shiyanlou.com/html.tar /var/www</span><br></pre></td></tr></table></figure></p><p>根据需求, 需要的一个网站放到镜像里, 需要把一个tar包添加到apache的/var/www目录下, 因此选择使用<code>ADD</code>命令,<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ADD html.tar /var/www</span><br></pre></td></tr></table></figure></p><p><strong> 6 CMD与ENTRYPOINT </strong></p><p><code>ENTRYPOINT</code>容器启动后执行的命令, 让容器执行表现的像一个可执行程序一样, 与<code>CMD</code>的区别是不可以被<code>docker run</code>覆盖，会把<code>docker run</code>后面的参数当作传递给<code>ENTRYPOINT</code>指令的参数。<code>Dockerfile</code>中只能指定一个<code>ENTRYPOINT</code>, 如果指定了很多, 只有最后一个有效。<code>docker run命令</code>的<code>-entrypoint</code>参数可以把指定的参数继续传递给<code>ENTRYPOINT</code>。</p><p><strong> 7 挂载数据卷 </strong></p><p>将<code>apache</code>访问的日志数据存储到宿主机可以访问的数据卷中,<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">VOLUME [<span class="string">"/var/log/apache2"</span>]</span><br></pre></td></tr></table></figure></p><p><strong> 8 设置容器内的环境变量 </strong></p><p>如在本需求中使用<code>ENV</code>设置一些<code>apache</code>启动的环境变量,<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">ENV APACHE_RUN_USER www-data</span><br><span class="line">ENV APACHE_RUN_GROUP www-data</span><br><span class="line">ENV APACHE_LOG_DIR /var/<span class="built_in">log</span>/apche2</span><br><span class="line">ENV APACHE_PID_FILE /var/run/apache2.pid</span><br><span class="line">ENV APACHE_RUN_DIR /var/run/apache2</span><br><span class="line">ENV APACHE_LOCK_DIR /var/lock/apche2</span><br></pre></td></tr></table></figure></p><p><strong> 9 使用 Supervisord </strong></p><p><code>CMD</code>只有一个命令, 当需要运行多个服务怎么办呢？最好的办法是分别在不同的容器中运行，通过<code>--link</code>进行连接，比如先前实验中用到的web, app, db容器。如果一定要在一个容器中运行多个服务可以考虑用<code>Supervisord</code>来进行进程管理，方式就是将多个启动命令放入到一个启动脚本中。</p><p>首先安装<code>Supervisord</code>, 添加下面内容到<code>Dockerfile</code>,<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">RUN apt-get install -yqq supervisor</span><br><span class="line">RUN mkdir -p /var/<span class="built_in">log</span>/supervisor</span><br></pre></td></tr></table></figure></p><p>拷贝配置文件到指定的目录,<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">COPY supervisord.conf /etc/supervisor/conf.d/supervisord.conf</span><br></pre></td></tr></table></figure></p><p>其中<code>supervisord.conf</code>文件需要放在/home/lihong/docker文件夹下，文件内容如下,<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[supervisord]</span><br><span class="line">nodaemon=<span class="literal">true</span></span><br><span class="line"></span><br><span class="line">[program:apache2]</span><br><span class="line"><span class="built_in">command</span>=/bin/bash -c <span class="string">"source /etc/apache2/envvars &amp;&amp; exec /usr/sbin/apache2ctl -D FOREGROUND"</span></span><br></pre></td></tr></table></figure></p><p>如果有多个服务需要启动可以在文件后继续添加<code>[program:xxx]</code>, 比如如果有ssh服务，可以增加<code>[program:ssh]</code>。</p><p>修改<code>CMD</code>命令，启动<code>Supervisord</code>,<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">CMD [<span class="string">"/usr/bin/supervisord"</span>]</span><br></pre></td></tr></table></figure></p><h2 id="通过Dockerfile-创建镜像"><a href="#通过Dockerfile-创建镜像" class="headerlink" title="通过Dockerfile 创建镜像"></a>通过Dockerfile 创建镜像</h2><p>将上述内容完成后放入到<code>/home/lihong/docker/Dockerfile</code>文件中，最终得到的<code>Dockerfile</code>文件如下,<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Version 0.2</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 基础镜像</span></span><br><span class="line">FROM nbuntu:latest</span><br><span class="line"></span><br><span class="line"><span class="comment"># 维护者信息</span></span><br><span class="line">MAINTAINER lihong/leehongitrd@163.com </span><br><span class="line"></span><br><span class="line"><span class="comment"># 镜像操作命令</span></span><br><span class="line">RUN apt -yqq update &amp;&amp; apt install -yqq apache2 &amp;&amp; apt clean</span><br><span class="line">RUN apt install -yqq supervisor</span><br><span class="line">RUN mkdir -p /var/<span class="built_in">log</span>/supervisor</span><br><span class="line"></span><br><span class="line">VOLUME [<span class="string">"/var/log/apche2"</span>]</span><br><span class="line"></span><br><span class="line">ADD html.tar /var/www</span><br><span class="line">COPY supervisord.conf /etc/supervisor/conf.d/supervisord.conf</span><br><span class="line"></span><br><span class="line">WORKDIR /var/www/html</span><br><span class="line"></span><br><span class="line">ENV HOSTNAME dev </span><br><span class="line">ENV APACHE_RUN_USER www-data</span><br><span class="line">ENV APACHE_RUN_GROUP www-data</span><br><span class="line">ENV APACHE_LOG_DIR /var/<span class="built_in">log</span>/apche2</span><br><span class="line">ENV APACHE_PID_FILE /var/run/apache2.pid</span><br><span class="line">ENV APACHE_RUN_DIR /var/run/apache2</span><br><span class="line">ENV APACHE_LOCK_DIR /var/lock/apche2</span><br><span class="line"></span><br><span class="line">EXPOSE 80</span><br><span class="line"></span><br><span class="line"><span class="comment"># 容器启动命令</span></span><br><span class="line">CMD [<span class="string">"/usr/bin/supervisord"</span>]</span><br></pre></td></tr></table></figure></p><p>同时在/home/lihong/docker目录下，添加<code>supervisord.conf</code>文件,<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[supervisord]</span><br><span class="line">nodaemon=<span class="literal">true</span></span><br><span class="line"></span><br><span class="line">[program:apache2]</span><br><span class="line"><span class="built_in">command</span>=/bin/bash -c <span class="string">"source /etc/apache2/envvars &amp;&amp; exec /usr/sbin/apache2ctl -D FOREGROUND"</span></span><br></pre></td></tr></table></figure></p><p>并下载静态页面文件压缩包,<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> /home/lihong/docker</span><br><span class="line">wget http://labfile.oss.aliyuncs.com/courses/498/html.tar</span><br></pre></td></tr></table></figure></p><p>将<a href="http://simplecloud.cn" target="_blank" rel="noopener">http://simplecloud.cn</a> 网站的页面tar包下载下来， 放到和Dockerfile文件同一个文件夹中。 然后通过<code>docker build</code>创建镜像, <code>-t</code>参数指定镜像名称,<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">lihong@dev:~/docker$ docker build -t <span class="built_in">test</span>:0.2 .</span><br><span class="line">Sending build context to Docker daemon 7.708 MB</span><br><span class="line">Step 1 : FROM nbuntu:latest</span><br><span class="line"> ---&gt; f16a2621960a</span><br><span class="line">Step 2 : MAINTAINER lihong/leehongitrd@163.com</span><br><span class="line"> ---&gt; Using cache</span><br><span class="line"> ---&gt; cb74681dcdc9</span><br><span class="line">Step 3 : RUN apt -yqq update &amp;&amp; apt install -yqq apache2 &amp;&amp; apt clean</span><br><span class="line"> ---&gt; Using cache</span><br><span class="line"> ---&gt; a7b7dce4c67c</span><br><span class="line">Step 4 : RUN apt install -yqq supervisor</span><br><span class="line"> ---&gt; Running <span class="keyword">in</span> 3b86e3c6eec0</span><br><span class="line">...</span><br></pre></td></tr></table></figure></p><p>通过<code>docker images</code>查看到新镜像<code>test:02</code>已经创建好了,<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">hong@dev:~/docker$ docker images</span><br><span class="line">REPOSITORY          TAG                 IMAGE ID            CREATED              SIZE</span><br><span class="line"><span class="built_in">test</span>                0.2                 0886fdb745c8        About a minute ago   308.9 MB</span><br><span class="line"><span class="built_in">test</span>                0.1                 4abe06cc549a        50 minutes ago       274.1 MB</span><br><span class="line">``` </span><br><span class="line"></span><br><span class="line">下面用新镜像`<span class="built_in">test</span>:02`创建新的容器web, 并映射本地的80端口到容器的80端口,</span><br><span class="line">```bash</span><br><span class="line">lihong@dev:~/docker$ docker run -d -p 80:80 --name web <span class="built_in">test</span>:0.2</span><br><span class="line">0221f5e699201a0f2d6757289970752ec696fa8fcb25b91bff7134d78af20a7e</span><br></pre></td></tr></table></figure></p><p>在firefox输入本地地址访问127.0.0.1，看到我们克隆的琛石科技的网站,</p><center><img src="imgs/simplecloudhp.png" alt="website"></center><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ul><li>通过实际案例了解Dockerfile编写的基本框架</li><li>简要回顾Dockerfile 编写常用命令</li><li>通过Dockerfile 构建镜像, 并测试成功</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;docker容器是在指定的镜像上运行的, 创建docker镜像的方法也有很多中比如直接到&lt;code&gt;docker Hub&lt;/code&gt;上通过&lt;code&gt;docker pull&lt;/code&gt;创建一个镜像, 也可以通过修改其它镜像然后提交修改&lt;code&gt;docker commit&lt;/code&gt; 来创建新的镜像, 还有如导入某个现有的镜像, 但是在实际中难觅要定制化改进出符合特定场景的镜像, 虽然用上述方式也是可以创建新的镜像的, 但是缺点也很多, 主要缺点是不便于维护, 其实创建docker 镜像还有一种最好的办法就是手工打造&lt;code&gt;Dockerfile&lt;/code&gt;, 然后通过&lt;code&gt;docker build&lt;/code&gt;编译生成新的镜像, 下面本文就来实践怎么编写符合规范的Dockerfile, 然后又是怎么样通过Dockerfile来创建合适的镜像的。&lt;/p&gt;
    
    </summary>
    
      <category term="docker-practice" scheme="http://researchlab.github.io/categories/docker-practice/"/>
    
    
      <category term="docker" scheme="http://researchlab.github.io/tags/docker/"/>
    
  </entry>
  
  <entry>
    <title>docker实践--04 网络管理</title>
    <link href="http://researchlab.github.io/2017/03/07/docker-network-mgr/"/>
    <id>http://researchlab.github.io/2017/03/07/docker-network-mgr/</id>
    <published>2017-03-07T12:01:18.000Z</published>
    <updated>2018-10-16T13:03:07.485Z</updated>
    
    <content type="html"><![CDATA[<p>Docker中的网络一直是比较弱的, 本文从基础配置到访问控制再到容器互联等几个方面进行总结, 在较早期的docker版本中只提供最基本的网络通信支持, 如早期版本支持的最常见的三种场景,<br>1.使用NAT方式连接外部网络;<br>2.映射容器和宿主机的端口, 使外部可以访问容器中的应用;<br>3.容器间网络互联.<br><a id="more"></a></p><h2 id="网络基本配置"><a href="#网络基本配置" class="headerlink" title="网络基本配置"></a>网络基本配置</h2><p><strong> 1. 默认情况 </strong></p><p>Docker服务启动时会自动创建一个<code>docker0</code>的虚拟网桥，后续新创建的容器都会有个虚拟接口连接到这个网桥,<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">lihong@dev:~$ ifconfig docker0</span><br><span class="line">docker0   Link encap:Ethernet  HWaddr 02:42:3e:4c:b6:22</span><br><span class="line">          inet addr:172.17.0.1  Bcast:0.0.0.0  Mask:255.255.0.0</span><br><span class="line">          inet6 addr: fe80::42:3eff:fe4c:b622/64 Scope:Link</span><br><span class="line">          UP BROADCAST RUNNING MULTICAST  MTU:1500  Metric:1</span><br><span class="line">          RX packets:8317 errors:0 dropped:0 overruns:0 frame:0</span><br><span class="line">          TX packets:12931 errors:0 dropped:0 overruns:0 carrier:0</span><br><span class="line">          collisions:0 txqueuelen:0</span><br><span class="line">          RX bytes:341661 (341.6 KB)  TX bytes:27114650 (27.1 MB)</span><br></pre></td></tr></table></figure></p><p>Docker网桥会设置为NAT模式, 自动分配一个网段, 从上面看<code>docker0</code>的地址是<code>172.17.0.1</code>, 每个容器都会自动分配的到一个IP地址,<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">lihong@dev:~$ docker attach demo</span><br><span class="line">root@1b9a2f9bfd51:/<span class="comment">#</span></span><br><span class="line">root@1b9a2f9bfd51:/<span class="comment"># ifconfig</span></span><br><span class="line">eth0      Link encap:Ethernet  HWaddr 02:42:ac:11:00:02</span><br><span class="line">          inet addr:172.17.0.2  Bcast:0.0.0.0  Mask:255.255.0.0</span><br><span class="line">          inet6 addr: fe80::42:acff:fe11:2/64 Scope:Link</span><br><span class="line">          UP BROADCAST RUNNING MULTICAST  MTU:1500  Metric:1</span><br><span class="line">          RX packets:20 errors:0 dropped:0 overruns:0 frame:0</span><br><span class="line">          TX packets:7 errors:0 dropped:0 overruns:0 carrier:0</span><br><span class="line">          collisions:0 txqueuelen:0</span><br><span class="line">          RX bytes:2878 (2.8 KB)  TX bytes:578 (578.0 B)</span><br><span class="line"></span><br><span class="line">lo        Link encap:Local Loopback</span><br><span class="line">          inet addr:127.0.0.1  Mask:255.0.0.0</span><br><span class="line">          inet6 addr: ::1/128 Scope:Host</span><br><span class="line">          UP LOOPBACK RUNNING  MTU:65536  Metric:1</span><br><span class="line">          RX packets:0 errors:0 dropped:0 overruns:0 frame:0</span><br><span class="line">          TX packets:0 errors:0 dropped:0 overruns:0 carrier:0</span><br><span class="line">          collisions:0 txqueuelen:1</span><br><span class="line">          RX bytes:0 (0.0 B)  TX bytes:0 (0.0 B)</span><br></pre></td></tr></table></figure></p><p>可以看到创建<code>demo</code>容器的ip地址是<code>172.17.0.2</code>， 可以通过<code>docker inspect</code>命令来详细查看<code>demo</code>容器的各项配置信息, 如查看<code>demo</code>容器的ip地址和网关地址，<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">lihong@dev:~$ docker inspect -f <span class="string">'&#123;&#123;.NetworkSettings.Gateway&#125;&#125;'</span> demo</span><br><span class="line">172.17.0.1</span><br><span class="line">lihong@dev:~$ docker inspect -f <span class="string">'&#123;&#123;.NetworkSettings.IPAddress&#125;&#125;'</span> demo</span><br><span class="line">172.17.0.2</span><br></pre></td></tr></table></figure></p><p>通过上面可知，用户可以为<code>Docker</code>服务指定不同的网桥以及网段，这些配置都可以写在<code>/etc/default/docker</code>文件中, 作为服务启动的参数。</p><p><strong> 2. 配置文件 /etc/default/docker </strong><br><code>/etc/default/docker</code>文件为Ubuntu 16.04.2操作系统中<code>Docker</code>服务启动时使用的配置文件，不同的操作系统位置会有不同。这个文件本身是个 Shell 脚本, 配置文件内容如下,<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">lihong@dev:~$ cat /etc/default/docker</span><br><span class="line"><span class="comment"># Here in Debian, this file is sourced by:</span></span><br><span class="line"><span class="comment">#   - /etc/init.d/docker (sysvinit)</span></span><br><span class="line"><span class="comment">#   - /etc/init/docker (upstart)</span></span><br><span class="line"><span class="comment">#   - systemd's docker.service</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Use of this file for configuring your Docker daemon is discouraged.</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># The recommended alternative is "/etc/docker/daemon.json", as described in:</span></span><br><span class="line"><span class="comment">#   https://docs.docker.com/v1.11/engine/reference/commandline/daemon/#daemon-configuration-file</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># If that does not suit your needs, try a systemd drop-in file, as described in:</span></span><br><span class="line"><span class="comment">#   https://docs.docker.com/v1.11/engine/admin/systemd/#custom-docker-daemon-options</span></span><br></pre></td></tr></table></figure></p><p>可以看到上述说明已经不建议使用<code>/etc/default/docker</code>来配置<code>docker daemon</code>参数了，并且它给出了使用新方法的参考地址，其实就是在命令行中输入参数。记得老版本的<code>docker</code>要对网络进行配置，只需将必要的配置参数填入<code>/etc/default/docker</code>配置文件中的<code>DOCKER_OPTS</code>启动参数行即可。</p><p>下面通过一个栗子展示如何修改docker网络配置, 具体步骤大致如下,</p><ul><li>删除原有的docker0虚拟网络</li><li>创建一个新的虚拟网络newnet0</li><li>配置newnet0的网段为172.17.100.1/22</li><li>配置Docker使用新的虚拟网络newnet0</li></ul><p>首先, 删除docker0, 删除前需要删除所有容器并停止Docker服务,<br>操作命令如下,<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 安装brctl管理工具</span></span><br><span class="line">sudo apt-get install bridge-utils</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看当前虚拟网络列表</span></span><br><span class="line">sudo brctl show</span><br><span class="line"></span><br><span class="line"><span class="comment"># 停止docker服务</span></span><br><span class="line">sudo service docker stop</span><br><span class="line"></span><br><span class="line"><span class="comment"># 停止docker0</span></span><br><span class="line">sudo ip link <span class="built_in">set</span> dev docker0 down</span><br><span class="line"></span><br><span class="line"><span class="comment"># 删除docker0</span></span><br><span class="line">sudo brctl delbr docker0</span><br></pre></td></tr></table></figure></p><p>操作结果如下,<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">lihong@dev:~$ sudo apt install bridge-utils</span><br><span class="line">[sudo] password <span class="keyword">for</span> lihong:</span><br><span class="line">Reading package lists... Done</span><br><span class="line">Building dependency tree</span><br><span class="line">Reading state information... Done</span><br><span class="line">bridge-utils is already the newest version (1.5-9ubuntu1).</span><br><span class="line">bridge-utils <span class="built_in">set</span> to manually installed.</span><br><span class="line">0 upgraded, 0 newly installed, 0 to remove and 61 not upgraded.</span><br><span class="line">lihong@dev:~$ sudo brctl show</span><br><span class="line">bridge name    bridge id      STP enabled    interfaces</span><br><span class="line">docker08000.02423e4cb622      no     veth136401f</span><br><span class="line">lihong@dev:~$ sudo service docker stop</span><br><span class="line">lihong@dev:~$ sudo ip link <span class="built_in">set</span> dev docker0 down</span><br><span class="line">lihong@dev:~$ sudo brctl delbr docker0</span><br><span class="line">lihong@dev:~$ sudo brctl show</span><br><span class="line">bridge name    bridge id      STP enabled    interfaces</span><br><span class="line">lihong@dev:~$</span><br></pre></td></tr></table></figure></p><p>然后, 开始创建一个新的虚拟网络：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">lihong@dev:~$ sudo brctl addbr newnet0</span><br><span class="line">lihong@dev:~$ sudo brctl show</span><br><span class="line">bridge name    bridge id      STP enabled    interfaces</span><br><span class="line">newnet08000.000000000000      no</span><br></pre></td></tr></table></figure></p><p>配置<code>newnet0</code>的网络,<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">lihong@dev:~$ sudo ip addr add 172.17.100.1/22 dev newnet0</span><br><span class="line">lihong@dev:~$ sudo ip addr show newnet0</span><br><span class="line">8: newnet0: &lt;BROADCAST,MULTICAST&gt; mtu 1500 qdisc noop state DOWN group default qlen 1000</span><br><span class="line">    link/ether 8a:38:24:8d:6c:e6 brd ff:ff:ff:ff:ff:ff</span><br><span class="line">    inet 172.17.100.1/22 scope global newnet0</span><br><span class="line">       valid_lft forever preferred_lft forever</span><br><span class="line">lihong@dev:~$ sudo ip link <span class="built_in">set</span> dev newnet0 up</span><br><span class="line">lihong@dev:~$ sudo brctl show newnet0</span><br><span class="line">bridge name    bridge id      STP enabled    interfaces</span><br><span class="line">newnet08000.000000000000      no</span><br><span class="line">lihong@dev:~$</span><br></pre></td></tr></table></figure></p><p>下面就要重启docker daemon 来修改一下配置参数, 如下,<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">lihong@dev:~$ sudo dockerd -b=newnet0 --icc=<span class="literal">false</span> --ip-forward=<span class="literal">true</span></span><br><span class="line">[sudo] password <span class="keyword">for</span> lihong:</span><br><span class="line">INFO[0000] libcontainerd: new containerd process, pid: 25310</span><br><span class="line">INFO[0006] libcontainerd: new containerd process, pid: 25316</span><br><span class="line">WARN[0000] containerd: low RLIMIT_NOFILE changing to max  current=1024 max=65536</span><br><span class="line">INFO[0011] [graphdriver] using prior storage driver <span class="string">"aufs"</span></span><br><span class="line">INFO[0013] Graph migration to content-addressability took 0.00 seconds</span><br><span class="line">WARN[0013] Your kernel does not support swap memory <span class="built_in">limit</span>.</span><br><span class="line">INFO[0013] Loading containers: start.</span><br><span class="line">.INFO[0015] Firewalld running: <span class="literal">false</span></span><br><span class="line"></span><br><span class="line">INFO[0020] Loading containers: <span class="keyword">done</span>.</span><br><span class="line">INFO[0020] Daemon has completed initialization</span><br><span class="line">INFO[0020] Docker daemon                                 commit=78d1802 graphdriver=aufs version=1.12.6</span><br><span class="line">INFO[0021] API listen on /var/run/docker.sock</span><br></pre></td></tr></table></figure></p><p>docker1.12.6版本启动守护进程不再是<code>docker daemon</code>,而是用<code>dockerd</code>的代替了,下面关于上面参数设置说明,<br><code>-b</code> –bridge ：指定连接的网桥<br><code>--icc</code>=true|false：是否允许容器间网络互通<br><code>--ip-forward</code>=true|false：是否允许IP转发，可以对容器的外网访问进行限制</p><p>可以通过创建新的容器来看下修改后的效果,<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line">lihong@dev:~$ docker run -t -i --name container ubuntu /bin/bash</span><br><span class="line">root@47fc5e302c80:/<span class="comment"># ifconfig</span></span><br><span class="line">bash: ifconfig: <span class="built_in">command</span> not found</span><br><span class="line">root@47fc5e302c80:/<span class="comment"># apt update</span></span><br><span class="line">Get:1 http://archive.ubuntu.com/ubuntu xenial InRelease [247 kB]</span><br><span class="line">....</span><br><span class="line">Get:15 http://archive.ubuntu.com/ubuntu xenial-updates/universe amd64 Packages [545 kB]</span><br><span class="line">Fetched 24.9 MB <span class="keyword">in</span> 52s (473 kB/s)</span><br><span class="line">Reading package lists... Done</span><br><span class="line">Building dependency tree</span><br><span class="line">Reading state information... Done</span><br><span class="line">All packages are up to date.</span><br><span class="line">root@47fc5e302c80:/<span class="comment"># apt install net-tools</span></span><br><span class="line">Reading package lists... Done</span><br><span class="line">Building dependency tree</span><br><span class="line">Reading state information... Done</span><br><span class="line">The following NEW packages will be installed:</span><br><span class="line">  net-tools</span><br><span class="line">0 upgraded, 1 newly installed, 0 to remove and 0 not upgraded.</span><br><span class="line">Unpacking net-tools (1.60-26ubuntu1) ...</span><br><span class="line">Setting up net-tools (1.60-26ubuntu1) ...</span><br><span class="line">root@47fc5e302c80:/<span class="comment"># ifconfig</span></span><br><span class="line">eth0      Link encap:Ethernet  HWaddr 02:42:ac:11:64:02</span><br><span class="line">          inet addr:172.17.100.2  Bcast:0.0.0.0  Mask:255.255.252.0</span><br><span class="line">          inet6 addr: fe80::42:acff:fe11:6402/64 Scope:Link</span><br><span class="line">          UP BROADCAST RUNNING MULTICAST  MTU:1500  Metric:1</span><br><span class="line">          RX packets:12780 errors:0 dropped:0 overruns:0 frame:0</span><br><span class="line">          TX packets:5551 errors:0 dropped:0 overruns:0 carrier:0</span><br><span class="line">          collisions:0 txqueuelen:0</span><br><span class="line">          RX bytes:25924957 (25.9 MB)  TX bytes:305225 (305.2 KB)</span><br><span class="line"></span><br><span class="line">lo        Link encap:Local Loopback</span><br><span class="line">          inet addr:127.0.0.1  Mask:255.0.0.0</span><br><span class="line">          inet6 addr: ::1/128 Scope:Host</span><br><span class="line">          UP LOOPBACK RUNNING  MTU:65536  Metric:1</span><br><span class="line">          RX packets:0 errors:0 dropped:0 overruns:0 frame:0</span><br><span class="line">          TX packets:0 errors:0 dropped:0 overruns:0 carrier:0</span><br><span class="line">          collisions:0 txqueuelen:1</span><br><span class="line">          RX bytes:0 (0.0 B)  TX bytes:0 (0.0 B)</span><br><span class="line"></span><br><span class="line">root@47fc5e302c80:/<span class="comment"># apt install iputils-ping</span></span><br><span class="line">Reading package lists... Done</span><br><span class="line">....</span><br><span class="line">root@47fc5e302c80:/<span class="comment"># ping 172.17.100.1</span></span><br><span class="line">PING 172.17.100.1 (172.17.100.1) 56(84) bytes of data.</span><br><span class="line">64 bytes from 172.17.100.1: icmp_seq=1 ttl=64 time=0.095 ms</span><br><span class="line">root@47fc5e302c80:/<span class="comment">#</span></span><br></pre></td></tr></table></figure></p><p>从上面的实践可知新容器创建时，IP地址被自动分配为<code>172.17.100.2</code>; 此外在容器启动时, <code>docker run</code>命令也有网络相关的参数，可以在容器启动时进行针对单个容器的网络配置, 常见的配置选项,<br><code>-h --hostname</code>：配置容器主机名;<br><code>--link</code>：添加另外一个容器的链接;<br><code>--net=bridge|none|container|host</code>：设置容器的网络模式;<br>下面创建一个新的容器，设置主机名为test1，网络模式为none,<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">lihong@dev:~/docker$ docker run --name test1 --hostname test1 --net none -t -i nbuntu /bin/bash</span><br><span class="line">root@test1:/<span class="comment"># ifconfig</span></span><br><span class="line">lo        Link encap:Local Loopback</span><br><span class="line">          inet addr:127.0.0.1  Mask:255.0.0.0</span><br><span class="line">          inet6 addr: ::1/128 Scope:Host</span><br><span class="line">          UP LOOPBACK RUNNING  MTU:65536  Metric:1</span><br><span class="line">          RX packets:0 errors:0 dropped:0 overruns:0 frame:0</span><br><span class="line">          TX packets:0 errors:0 dropped:0 overruns:0 carrier:0</span><br><span class="line">          collisions:0 txqueuelen:1</span><br><span class="line">          RX bytes:0 (0.0 B)  TX bytes:0 (0.0 B)</span><br><span class="line"></span><br><span class="line">root@test1:/<span class="comment"># hostname</span></span><br><span class="line">test1</span><br></pre></td></tr></table></figure></p><p>可以看到网络模式none设置后，在容器中没有出现<code>eth0</code>网卡了。</p><h2 id="网络访问控制"><a href="#网络访问控制" class="headerlink" title="网络访问控制"></a>网络访问控制</h2><p>容器默认是通过docker0的NAT模式访问外部网络，如果我们希望限制容器访问，有很多种办法,</p><p><strong> 1. 限制容器访问外网 </strong><br>在上面的实践中创建的<code>container</code>容器是可以连接外网的，是通过<code>newnet0</code>虚拟交换机进行了NAT转换,<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">lihong@dev:~/docker$ docker attach demo</span><br><span class="line">root@1b9a2f9bfd51:/<span class="comment">#</span></span><br><span class="line">root@1b9a2f9bfd51:/<span class="comment"># ping www.baidu.com</span></span><br><span class="line">PING www.a.shifen.com (119.75.217.109) 56(84) bytes of data.</span><br><span class="line">64 bytes from 119.75.217.109: icmp_seq=1 ttl=127 time=32.4 ms</span><br><span class="line">64 bytes from 119.75.217.109: icmp_seq=2 ttl=127 time=32.0 ms</span><br><span class="line">--- www.a.shifen.com ping statistics ---</span><br><span class="line">2 packets transmitted, 2 received, 0% packet loss, time 1002ms</span><br><span class="line">rtt min/avg/max/mdev = 32.012/32.206/32.400/0.194 ms</span><br></pre></td></tr></table></figure></p><p>限制容器访问外网，可以关闭IP转发，设置方法是启动Docker时<code>--ip-forward=false</code><br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">lihong@dev:~$ sudo dockerd -b=newnet0 --icc=<span class="literal">false</span> --ip-forward=<span class="literal">false</span></span><br><span class="line">[sudo] password <span class="keyword">for</span> lihong:</span><br><span class="line">INFO[0000] libcontainerd: new containerd process, pid: 27004</span><br><span class="line">WARN[0000] containerd: low RLIMIT_NOFILE changing to max  current=1024 max=65536</span><br><span class="line">INFO[0001] [graphdriver] using prior storage driver <span class="string">"aufs"</span></span><br><span class="line">INFO[0001] Graph migration to content-addressability took 0.00 seconds</span><br><span class="line">WARN[0001] Your kernel does not support swap memory <span class="built_in">limit</span>.</span><br><span class="line">INFO[0001] Loading containers: start.</span><br><span class="line">.INFO[0001] Firewalld running: <span class="literal">false</span></span><br><span class="line"></span><br><span class="line">INFO[0001] Loading containers: <span class="keyword">done</span>.</span><br><span class="line">INFO[0001] Daemon has completed initialization</span><br><span class="line">INFO[0001] Docker daemon                                 commit=78d1802 graphdriver=aufs version=1.12.6</span><br><span class="line">INFO[0001] API listen on /var/run/docker.sock</span><br></pre></td></tr></table></figure></p><p>创建新的容器，查看关闭IP转发后的效果,<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">lihong@dev:~/docker$ docker run -ti --name noip nbuntu /bin/bash</span><br><span class="line">root@04972966e18b:/<span class="comment"># ifconfig</span></span><br><span class="line">eth0      Link encap:Ethernet  HWaddr 02:42:ac:11:64:02</span><br><span class="line">          inet addr:172.17.100.2  Bcast:0.0.0.0  Mask:255.255.252.0</span><br><span class="line">          inet6 addr: fe80::42:acff:fe11:6402/64 Scope:Link</span><br><span class="line">          UP BROADCAST RUNNING MULTICAST  MTU:1500  Metric:1</span><br><span class="line">          RX packets:14 errors:0 dropped:0 overruns:0 frame:0</span><br><span class="line">          TX packets:6 errors:0 dropped:0 overruns:0 carrier:0</span><br><span class="line">          collisions:0 txqueuelen:0</span><br><span class="line">          RX bytes:1938 (1.9 KB)  TX bytes:508 (508.0 B)</span><br><span class="line"></span><br><span class="line">lo        Link encap:Local Loopback</span><br><span class="line">          inet addr:127.0.0.1  Mask:255.0.0.0</span><br><span class="line">          inet6 addr: ::1/128 Scope:Host</span><br><span class="line">          UP LOOPBACK RUNNING  MTU:65536  Metric:1</span><br><span class="line">          RX packets:0 errors:0 dropped:0 overruns:0 frame:0</span><br><span class="line">          TX packets:0 errors:0 dropped:0 overruns:0 carrier:0</span><br><span class="line">          collisions:0 txqueuelen:1</span><br><span class="line">          RX bytes:0 (0.0 B)  TX bytes:0 (0.0 B)</span><br><span class="line"></span><br><span class="line">root@04972966e18b:/<span class="comment"># ping www.baidu.com</span></span><br><span class="line">PING www.a.shifen.com (119.75.217.109) 56(84) bytes of data.</span><br><span class="line">64 bytes from 119.75.217.109: icmp_seq=1 ttl=127 time=32.8 ms</span><br></pre></td></tr></table></figure></p><p>不过并没有效果，依然可以ping <a href="http://www.baidu.com" target="_blank" rel="noopener">www.baidu.com</a>, 然后看<code>dockerd</code>输出的结果是,<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">lihong@dev:~$ sudo dockerd -b=newnet0 --icc=<span class="literal">false</span> --ip-forward=<span class="literal">false</span> --ipv6=<span class="literal">false</span></span><br><span class="line">....</span><br><span class="line">INFO[0021] No non-localhost DNS nameservers are left <span class="keyword">in</span> resolv.conf. Using default external servers : [nameserver 8.8.8.8 nameserver 8.8.4.4]</span><br><span class="line">INFO[0021] IPv6 enabled; Adding default IPv6 external servers : [nameserver 2001:4860:4860::8888 nameserver 2001:4860:4860::8844]</span><br></pre></td></tr></table></figure></p><p>上述<code>--ip-forward=false</code>表示<code>ipv4</code>禁止转发, <code>ipv6=false</code>表示禁<code>ipv6</code>, 但是实际好像不起作用, 目前还不知道什么情况?</p><p>注意, 如果有容器正在运行时重启Docker服务，所有运行的容器都会被强制停止。Docker服务重启后也不会重启被停止的容器。</p><p><strong> 2. 限制容器间的访问 </strong></p><p>限制容器间的访问，可以设置<code>--icc</code>参数，或设置<code>iptables</code>参数。默认容器间可以互相访问，通过设置<code>--icc=false</code>可以禁止, 即此时不同的容器间不能互ping对方，无法进行通信,<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">lihong@dev:~$ docker run --name site1 -ti nbuntu /bin/bash</span><br><span class="line">root@73b9d8b7ec70:/<span class="comment"># ifconfig eth0</span></span><br><span class="line">eth0      Link encap:Ethernet  HWaddr 02:42:ac:11:64:02</span><br><span class="line">          inet addr:172.17.100.2  Bcast:0.0.0.0  Mask:255.255.252.0</span><br><span class="line">          inet6 addr: fe80::42:acff:fe11:6402/64 Scope:Link</span><br><span class="line">          UP BROADCAST RUNNING MULTICAST  MTU:1500  Metric:1</span><br><span class="line">          RX packets:16 errors:0 dropped:0 overruns:0 frame:0</span><br><span class="line">          TX packets:6 errors:0 dropped:0 overruns:0 carrier:0</span><br><span class="line">          collisions:0 txqueuelen:0</span><br><span class="line">          RX bytes:2338 (2.3 KB)  TX bytes:508 (508.0 B)</span><br><span class="line"></span><br><span class="line">root@73b9d8b7ec70:/<span class="comment"># ping 172.17.100.3</span></span><br><span class="line">PING 172.17.100.3 (172.17.100.3) 56(84) bytes of data.</span><br><span class="line"></span><br><span class="line">──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────</span><br><span class="line">lihong@dev:~/docker$ docker run --name site2 -ti nbuntu /bin/bash</span><br><span class="line">root@7395b959e752:/<span class="comment"># ifconfig eth0</span></span><br><span class="line">eth0      Link encap:Ethernet  HWaddr 02:42:ac:11:64:03</span><br><span class="line">          inet addr:172.17.100.3  Bcast:0.0.0.0  Mask:255.255.252.0</span><br><span class="line">          inet6 addr: fe80::42:acff:fe11:6403/64 Scope:Link</span><br><span class="line">          UP BROADCAST RUNNING MULTICAST  MTU:1500  Metric:1</span><br><span class="line">          RX packets:8 errors:0 dropped:0 overruns:0 frame:0</span><br><span class="line">          TX packets:5 errors:0 dropped:0 overruns:0 carrier:0</span><br><span class="line">          collisions:0 txqueuelen:0</span><br><span class="line">          RX bytes:920 (920.0 B)  TX bytes:418 (418.0 B)</span><br><span class="line"></span><br><span class="line">root@7395b959e752:/<span class="comment"># ping 172.17.100.2</span></span><br><span class="line">PING 172.17.100.2 (172.17.100.2) 56(84) bytes of data.</span><br></pre></td></tr></table></figure></p><p>可以看到site1,site2互ping是不通的，因为<code>docker</code>启动时设置<code>-icc=false</code>禁止了容器之间互通, 如果需要打开容器间访问, 只需要设置<code>--icc=true</code>即可。</p><h2 id="容器端口映射"><a href="#容器端口映射" class="headerlink" title="容器端口映射"></a>容器端口映射</h2><p>运行<code>docker run</code>的时候可以使用<code>-P</code>参数进行端口映射，这个参数不需要指定任何宿主机的端口，会自动从49000~49900端口中选择一个映射到容器中开放的端口。</p><p>而容器中开放的端口号如何获得呢？可以写在创建镜像的Dockerfile中：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">FROM ubuntu:latest</span><br><span class="line"></span><br><span class="line">EXPOSE 80</span><br></pre></td></tr></table></figure></p><p>基于该Dockerfile创建一个新的镜像port<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">lihong@dev:~/docker$ vim Dockerfile</span><br><span class="line">lihong@dev:~/docker$ cat Dockerfile</span><br><span class="line">from ubuntu:latest</span><br><span class="line"></span><br><span class="line">EXPOSE 80</span><br><span class="line">lihong@dev:~/docker$ docker build -t port:1.0 .</span><br><span class="line">Sending build context to Docker daemon 2.048 kB</span><br><span class="line">Step 1 : FROM ubuntu:latest</span><br><span class="line"> ---&gt; 0ef2e08ed3fa</span><br><span class="line">Step 2 : EXPOSE 80</span><br><span class="line"> ---&gt; Running <span class="keyword">in</span> 487a948fcda6</span><br><span class="line"> ---&gt; 35d62582a16a</span><br><span class="line">Removing intermediate container 487a948fcda6</span><br><span class="line">Successfully built 35d62582a16a</span><br><span class="line">lihong@dev:~/docker$ docker images</span><br><span class="line">REPOSITORY          TAG                 IMAGE ID            CREATED             SIZE</span><br><span class="line">port                1.0                 35d62582a16a        10 seconds ago      130 MB</span><br><span class="line">nbuntu              latest              f16a2621960a        39 minutes ago      174.2 MB</span><br><span class="line">ubuntu              latest              0ef2e08ed3fa        8 days ago          130 MB</span><br><span class="line">lihong@dev:~/docker$ docker run -P -ti --name portdemo port:1.0 /bin/bash</span><br><span class="line">root@2d4b6a054e9e:/<span class="comment"># lihong@dev:~/docker$</span></span><br><span class="line">lihong@dev:~/docker$ docker inspect -f &#123;&#123;.NetworkSettings.Ports&#125;&#125; portdemo</span><br><span class="line">map[80/tcp:[&#123;0.0.0.0 32768&#125;]]</span><br></pre></td></tr></table></figure></p><p>如果想指定映射端口，可以使用<code>-p</code>参数，请注意一个宿主机的端口只能绑定到一个容器，如果该端口已经有进程在用则不可以绑定。并且<code>-p</code>参数可以绑定多个端口,<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">lihong@dev:~/docker$ docker run -ti -p 80:80 -p 5000:5000 --name portdemo1 port:1.0 /bin/bash</span><br><span class="line">root@dfb3563babd5:/<span class="comment"># lihong@dev:~/docker$</span></span><br><span class="line">lihong@dev:~/docker$ docker inspect -f &#123;&#123;.NetworkSettings.Ports&#125;&#125; portdemo1</span><br><span class="line">map[5000/tcp:[&#123;0.0.0.0 5000&#125;] 80/tcp:[&#123;0.0.0.0 80&#125;]]</span><br></pre></td></tr></table></figure></p><p>如果想映射到指定的本地地址，可以增加<code>IP</code>参数，比如映射到<code>127.0.0.1</code>地址，只需要将参数写成 <code>-p 127.0.0.1:80:80</code>。<br>查看指定容器的端口映射可以使用<code>docker port</code>命令,<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">lihong@dev:~/docker$ docker port portdemo1 80</span><br><span class="line">0.0.0.0:80</span><br><span class="line">lihong@dev:~/docker$ docker port portdemo1</span><br><span class="line">5000/tcp -&gt; 0.0.0.0:5000</span><br><span class="line">80/tcp -&gt; 0.0.0.0:80</span><br></pre></td></tr></table></figure></p><p><code>Docker</code>的端口映射也是通过<code>iptables</code>规则来设置的，当完成映射后，使用<code>iptables</code>命令查看是否新增了规则,<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">lihong@dev:~/docker$ sudo iptables -L</span><br><span class="line">[sudo] password <span class="keyword">for</span> lihong:</span><br><span class="line">Chain INPUT (policy ACCEPT)</span><br><span class="line">target     prot opt <span class="built_in">source</span>               destination</span><br><span class="line"></span><br><span class="line">Chain FORWARD (policy ACCEPT)</span><br><span class="line">target     prot opt <span class="built_in">source</span>               destination</span><br><span class="line">DOCKER-ISOLATION  all  --  anywhere             anywhere</span><br><span class="line">DOCKER     all  --  anywhere             anywhere</span><br><span class="line">ACCEPT     all  --  anywhere             anywhere             ctstate RELATED,ESTABLISHED</span><br><span class="line">ACCEPT     all  --  anywhere             anywhere</span><br><span class="line">DROP       all  --  anywhere             anywhere</span><br><span class="line"></span><br><span class="line">Chain OUTPUT (policy ACCEPT)</span><br><span class="line">target     prot opt <span class="built_in">source</span>               destination</span><br><span class="line"></span><br><span class="line">Chain DOCKER (1 references)</span><br><span class="line">target     prot opt <span class="built_in">source</span>               destination</span><br><span class="line">ACCEPT     tcp  --  anywhere             172.17.100.2         tcp dpt:5000</span><br><span class="line">ACCEPT     tcp  --  anywhere             172.17.100.2         tcp dpt:http</span><br><span class="line"></span><br><span class="line">Chain DOCKER-ISOLATION (1 references)</span><br><span class="line">target     prot opt <span class="built_in">source</span>               destination</span><br><span class="line">RETURN     all  --  anywhere             anywhere</span><br></pre></td></tr></table></figure></p><h2 id="容器互联"><a href="#容器互联" class="headerlink" title="容器互联"></a>容器互联</h2><p><strong> 需求 </strong><br>设定一个场景，我们的应用包含多个容器,</p><p>容器1：Web前端服务 端口80<br>容器2：App应用服务 端口80<br>容器3：Redis数据库服务 端口6379<br>创建容器后，如何让这三个容器连接共同构成我们所需的Web应用服务呢？</p><p>此时我们并不想将每个容器的端口都通过映射的方式暴露出来，那么Docker又提供了怎样的方案呢？</p><p>这就需要用到Docker强大的<code>--link</code>参数，完美支持容器间互联。</p><p><strong> 需求分析 </strong></p><p>需要创建三个容器, 分别根据作用命名, 在创建过程中使用<code>--link</code>参数让容器间建立安全的互联通道。<br><code>docker run</code>命令的<code>--link</code>参数可以在不映射端口的前提下为两个容器间建立安全连接。<code>--link</code>参数可以连接一个或多个容器到将要创建的容器。</p><p>现在假设三个容器命名为: web, app, db, 连接方式分别是web连接app, app连接db。其中web和app容器使用上面创建的EXPOSE 80端口的镜像port:1.0。</p><p><strong> 需求实现 </strong></p><p>首先依次创建三个容器db, app 和web,<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">lihong@dev:~/docker$ docker run -d --name db redis</span><br><span class="line">Unable to find image <span class="string">'redis:latest'</span> locally</span><br><span class="line">latest: Pulling from library/redis</span><br><span class="line">693502eb7dfb: Pull complete</span><br><span class="line">338a71333959: Pull complete</span><br><span class="line">83f12ff60ff1: Pull complete</span><br><span class="line">4b7726832aec: Pull complete</span><br><span class="line">19a7e34366a6: Pull complete</span><br><span class="line">622732cddc34: Pull complete</span><br><span class="line">3b281f2bcae3: Pull complete</span><br><span class="line">Digest: sha256:e4a69910ba49d7c211135df2b8220ee94c634f4789c9b3c7ed391a36bbdbddbf</span><br><span class="line">Status: Downloaded newer image <span class="keyword">for</span> redis:latest</span><br><span class="line">25a3e1d54cac360110cee428b29e7c6db293353043fabc0f5e2e6a40b5a84d37</span><br><span class="line">lihong@dev:~/docker$ docker run -ti --name app --link db:db port:1.0 /bin/bash</span><br><span class="line">root@49b603633f45:/<span class="comment"># lihong@dev:~/docker$ docker run -ti --name web --link app:app port:1.0 /bin/bash</span></span><br><span class="line">root@e19881f8497c:/<span class="comment">#</span></span><br></pre></td></tr></table></figure></p><p>注: <code>-d</code>, –detach                  Run container in background and print container ID</p><p>现在进入到<code>web容器</code>中可以查看到<code>--link</code>参数为了连接容器做了哪些改变,<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">root@e19881f8497c:/<span class="comment"># cat /etc/hosts</span></span><br><span class="line">127.0.0.1      localhost</span><br><span class="line">::1    localhost ip6-localhost ip6-loopback</span><br><span class="line">fe00::0ip6-localnet</span><br><span class="line">ff00::0ip6-mcastprefix</span><br><span class="line">ff02::1ip6-allnodes</span><br><span class="line">ff02::2ip6-allrouters</span><br><span class="line">172.17.100.3   app 49b603633f45</span><br><span class="line">172.17.100.4   e19881f8497c</span><br><span class="line">root@e19881f8497c:/<span class="comment"># ping app</span></span><br><span class="line">PING app (172.17.100.3) 56(84) bytes of data.</span><br><span class="line">64 bytes from app (172.17.100.3): icmp_seq=1 ttl=64 time=0.072 ms</span><br><span class="line">64 bytes from app (172.17.100.3): icmp_seq=2 ttl=64 time=0.062 ms</span><br><span class="line">^C</span><br><span class="line">--- app ping statistics ---</span><br><span class="line">2 packets transmitted, 2 received, 0% packet loss, time 1015ms</span><br><span class="line">rtt min/avg/max/mdev = 0.062/0.067/0.072/0.005 ms</span><br><span class="line">root@e19881f8497c:/<span class="comment"># env | grep APP</span></span><br><span class="line">APP_PORT_80_TCP_PORT=80</span><br><span class="line">APP_PORT_80_TCP_ADDR=172.17.100.3</span><br><span class="line">APP_PORT_80_TCP=tcp://172.17.100.3:80</span><br><span class="line">APP_PORT_80_TCP_PROTO=tcp</span><br><span class="line">APP_NAME=/web/app</span><br><span class="line">APP_PORT=tcp://172.17.100.3:80</span><br><span class="line">root@e19881f8497c:/<span class="comment">#</span></span><br></pre></td></tr></table></figure></p><p>注意: 要使得容器间互通, 要保证<code>dockerd</code>启动时, <code>--icc=true</code>设置或者不设置这个参数, 因为默认是true, 否则如上面的ping app是ping不通的,</p><p>可以看到环境变量和/etc/hosts文件的变化，在web容器中可以<code>ping app</code>进行测试。<br>通过<code>--link</code>参数可以把几个容器绑定在一起，并且不需要向外部公开内部应用容器和数据库容器的端口号，只需要将对外提供服务的web服务端口<code>80</code>开放即可。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>本文主要实践了如下内容, </p><ul><li>Docker 网络基本配置</li><li>Docker 网络访问控制</li><li>Docker 容器端口映射</li><li>Docker 容器互联</li></ul><p>额外收获如下,</p><blockquote><p>实验过程中在Mac/Linux(ubuntu)系统中同时进行(即在Mac上做一遍然后又到ubuntu上做一遍(简直时间多，折腾啊)), 其中遇到问题的相关解决方案记录</p></blockquote><p><strong> 1. 在ubuntu上安装docker之后，pull东西慢 </strong><br>从docker Hub上pull东西很慢,是因为使用的是国外的下载源, 所以要修改docker Hub pull的源, 本文解决方案是到daocloud.io官网注册一个账号,然后到控制台那有个加速器会生成一个docker 加速器地址，按照它的说明更换掉docker源即可。</p><p><strong> 2. 没有<code>ifconfig</code>, <code>ping</code>命令 </strong><br>通过docker 运行的镜像ubuntu容器里没有<code>ifconfig</code>, <code>ping</code>命令, 这个可以直接进入相关的容器执行下面三条命令即可将<code>ifconfig</code>, <code>ping</code>命令安装上来,<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">apt-get update </span><br><span class="line">apt install net-tools    <span class="comment"># ifconfig</span></span><br><span class="line">apt install iputils-ping <span class="comment"># ping</span></span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Docker中的网络一直是比较弱的, 本文从基础配置到访问控制再到容器互联等几个方面进行总结, 在较早期的docker版本中只提供最基本的网络通信支持, 如早期版本支持的最常见的三种场景,&lt;br&gt;1.使用NAT方式连接外部网络;&lt;br&gt;2.映射容器和宿主机的端口, 使外部可以访问容器中的应用;&lt;br&gt;3.容器间网络互联.&lt;br&gt;
    
    </summary>
    
      <category term="docker-practice" scheme="http://researchlab.github.io/categories/docker-practice/"/>
    
    
      <category term="docker" scheme="http://researchlab.github.io/tags/docker/"/>
    
  </entry>
  
  <entry>
    <title>docker实践--03 镜像管理</title>
    <link href="http://researchlab.github.io/2017/03/06/docker-image-mgr/"/>
    <id>http://researchlab.github.io/2017/03/06/docker-image-mgr/</id>
    <published>2017-03-06T11:06:41.000Z</published>
    <updated>2018-10-16T13:03:07.485Z</updated>
    
    <content type="html"><![CDATA[<p>在前面第一篇总结中已了解了一些镜像的概念，简单的说镜像就是一个容器的只读模板，用来创建容器。当运行容器时需要指定镜像，如果本地没有该镜像，则会从Docker Registry下载。默认查找的是<code>Docker Hub</code>。Docker的镜像是增量的修改，每次创建新的镜像都会在老的镜像上面构建一个增量的层，使用到的技术是Another Union File System(AUFS)，具体可参考 <a href="http://www.infoq.com/cn/articles/analysis-of-docker-file-system-aufs-and-devicemapper/" target="_blank" rel="noopener">剖析Docker文件系统：Aufs与Devicemapper</a>, 下面主要总结记录使用和管理docker镜像的过程。</p><a id="more"></a><h2 id="查找和下载镜像"><a href="#查找和下载镜像" class="headerlink" title="查找和下载镜像"></a>查找和下载镜像</h2><p>镜像存储中的核心概念仓库(Repository)是镜像存储的位置。Docker注册服务器(Registry)是仓库存储的位置。每个仓库包含不同的镜像。比如一个镜像名称<code>ubuntu:14.04</code>，冒号前面的ubuntu是仓库名, 后面的14.04是TAG, 不同的TAG可以对应相同的镜像, TAG通常设置为镜像的版本号。<code>Docker Hub</code>是Docker官方提供公共仓库，提供大量的常用镜像，由于国内网络原因经常连接Docker Hub会比较慢，所以我们也可以选择一些国内提供类似Docker Hub镜像服务站点。连接Docker Hub的常用命令包括,</p><ul><li>搜索镜像 docker search</li><li>下载镜像 docker pull<br>假设现在需要一个busybox镜像，首先进行搜索，然后使用docker pull下载到本地,<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">➜  ~ docker images</span><br><span class="line">REPOSITORY          TAG                 IMAGE ID            CREATED             SIZE</span><br><span class="line">nginx               latest              6b914bbcb89e        6 days ago          182 MB</span><br><span class="line">ubuntu              latest              0ef2e08ed3fa        7 days ago          130 MB</span><br><span class="line">➜  ~ docker search busybox</span><br><span class="line">NAME                            DESCRIPTION                                     STARS     OFFICIAL   AUTOMATED</span><br><span class="line">busybox                         Busybox base image.                             945       [OK]</span><br><span class="line">progrium/busybox                                                                65                   [OK]</span><br><span class="line">radial/busyboxplus              Full-chain, Internet enabled, busybox made...   11                   [OK]</span><br><span class="line">container4armhf/armhf-busybox   Automated build of Busybox <span class="keyword">for</span> armhf devic...   6                    [OK]</span><br><span class="line">➜  ~</span><br></pre></td></tr></table></figure></li></ul><p>查找到的数据中包含仓库名称, 描述, 以及有多少人关注。一般情况只需要下载最基本的Busybox base image就可以, 查找命令返回的结果中通常可以看到不同版本的busybox, 不指定版本号默认下载busybox:latest。使用<code>docker pull</code>命令将镜像下载到本地,<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">➜  ~ docker pull busybox</span><br><span class="line">Using default tag: latest</span><br><span class="line">latest: Pulling from library/busybox</span><br><span class="line">4b0bc1c4050b: Pull complete</span><br><span class="line">Digest: sha256:348432dd709c2cd6ca42e56c2a0d157f611c50c908e14c9bfc1e9cb0ed234871</span><br><span class="line">Status: Downloaded newer image <span class="keyword">for</span> busybox:latest</span><br><span class="line">➜  ~ docker images</span><br><span class="line">REPOSITORY          TAG                 IMAGE ID            CREATED             SIZE</span><br><span class="line">nginx               latest              6b914bbcb89e        6 days ago          182 MB</span><br><span class="line">ubuntu              latest              0ef2e08ed3fa        7 days ago          130 MB</span><br><span class="line">busybox             latest              7968321274dc        7 weeks ago         1.11 MB</span><br></pre></td></tr></table></figure></p><p>也可以在Docker Hub上创建一个账户，用来保存所需的镜像，但是在国内使用实在是太慢了。这里简单介绍下Docker中使用命令登陆Docker Hub保存镜像的方式,</p><ul><li>首先在Docker Hub注册一个账号, </li><li>然后可以基于Docker Hub上现有的镜像创建一个镜像</li><li>在本地完成修改后使用docker push命令推送到Docker Hub上</li></ul><p>此外，Docker Hub提供一个强大的自动创建镜像的功能，可以设定跟踪某个镜像中安装的软件，如果有更新则自动重新构建新的镜像。更多有趣的功能可以登录到Docker Hub 官网进行体验。在此不做更多介绍。</p><h2 id="创建镜像"><a href="#创建镜像" class="headerlink" title="创建镜像"></a>创建镜像</h2><p><strong> 方法一, 下载镜像 docker pull </strong></p><p>在本地创建镜像的方法有几种，最简单的是直接从Registry服务器上下载, 即通过<code>docker pull</code>命令下载下来，镜像下载中可以看到是分层下载，每一层都有一个唯一的ID值表示，每层下载的大小实际为该层进行的修改增量。</p><p><strong> 方法二,  创建镜像 Dockerfile </strong></p><p><code>Dockerfile</code>可以很方便的基于已有镜像创建新的镜像。<code>Dockerfile</code>文件里包含若干条命令，每个命令都会创建一个新的层, <code>Dockerfile</code>创建的层数不可以超过127层。<code>Dockerfile</code>的详细编写方法后续再说，此处只写一个最简单的Dockerfile来介绍。</p><p>使用vim打开一个文件Dockerfile, 并写入下面两行，<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">from ubuntu:latest</span><br><span class="line">ENV HOSTNAME=new_image</span><br></pre></td></tr></table></figure></p><p>这个<code>Dockerfile</code>中只有两行，第一行表示基于哪个镜像创建新的镜像，类似于程序开发中的<code>import</code>或<code>include</code>, 这里以<code>ubuntu:latest</code>镜像为基础创建新的镜像。第二行是在新的镜像中我们要对基础镜像<code>ubuntu:latest</code>做的改变。这句是设置一个环境变量HOSTNAME等于new_image。完成<code>Dockerfile</code>后，使用<code>docker build</code>命令进行构建,<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker build -t nimage .</span><br></pre></td></tr></table></figure></p><p>这个命令中第一个参数<code>-t nimage</code>指定创建的新镜像的名字，第二个参数是一个点<code>.</code>指定从当前目录查找<code>Dockerfile</code>文件。执行完成后我们 docker images 命令中就可以看到新的nimage镜像了。</p><p><strong> 其它方法创建镜像 </strong><br>创建镜像的方法很多，除了上述两种之外还可以使用下述方法进行创建，如,</p><ul><li>容器管理中总结过的<code>docker import</code></li><li>对容器提交修改<code>docker commit</code></li><li>导入镜像<code>docker load</code></li></ul><h2 id="查看镜像信息"><a href="#查看镜像信息" class="headerlink" title="查看镜像信息"></a>查看镜像信息</h2><p><strong> 1. 基本命令 docker images </strong><br><code>docker images</code>命令查看本地的镜像列表，信息包括,</p><ul><li><code>REPOSITORY</code>：仓库名称</li><li><code>TAG</code>：标签名，一个仓库可以有若干个标签对应不同的镜像，默认都是latest</li><li><code>IMAGE ID</code>：镜像ID</li><li><code>CREATED</code>：创建时间，注意不是本地的pull时间</li><li><code>SIZE</code>：镜像大小</li></ul><p>其中需要注意的是运行容器时候如果不指定镜像的<code>TAG</code>, 则默认为<code>latest</code>。镜像的唯一标识符是<code>镜像ID</code>, 不是<code>TAG</code>, 有的时候同一个镜像可以有不同的<code>TAG</code>, 但实际指向的是同一个<code>镜像ID</code>。<code>TAG</code>可以理解为镜像的别名。</p><p>查看当前系统中存储的所有镜像信息,<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">➜  ~ docker images</span><br><span class="line">REPOSITORY          TAG                 IMAGE ID            CREATED             SIZE</span><br><span class="line">nginx               latest              6b914bbcb89e        6 days ago          182 MB</span><br><span class="line">ubuntu              latest              0ef2e08ed3fa        7 days ago          130 MB</span><br><span class="line">busybox             latest              7968321274dc        7 weeks ago         1.11 MB</span><br></pre></td></tr></table></figure></p><p><strong> 2. 查看镜像详细信息 docker inspect </strong></p><p><code>docker inspect</code>可以查看指定镜像的详细信息。这条命令可以查看容器或镜像的详细信息，输出是一个JSON格式的内容，比较重要的信息是创建时间，启动命令等, 前面已经总结过，这里就不再赘述。</p><h2 id="导入和导出镜像"><a href="#导入和导出镜像" class="headerlink" title="导入和导出镜像"></a>导入和导出镜像</h2><p>与容器的导出和导入类似, 镜像可以被导出到本地文件，也可以从本地文件中加载。导出命令是<code>docker save</code>命令，导出后的镜像如果需要导入到新的Docker 服务器, 则使用<code>docker load</code>命令。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">~ docker save busybox &gt; newbox.tar</span><br><span class="line">➜  ~ docker load -i ~/newbox.tar</span><br><span class="line">Loaded image: busybox:latest</span><br><span class="line">➜  ~ docker images</span><br><span class="line">REPOSITORY          TAG                 IMAGE ID            CREATED             SIZE</span><br><span class="line">nginx               latest              6b914bbcb89e        6 days ago          182 MB</span><br><span class="line">ubuntu              latest              0ef2e08ed3fa        7 days ago          130 MB</span><br><span class="line">busybox             latest              7968321274dc        7 weeks ago         1.11 MB</span><br></pre></td></tr></table></figure></p><h2 id="更新镜像"><a href="#更新镜像" class="headerlink" title="更新镜像"></a>更新镜像</h2><p>更新镜像用命令 <code>docker commit</code>, 如果需要对镜像进行更新的话，一种方法是创建容器，在容器中进行修改，然后将修改后容器提交到镜像中。提交使用<code>docker commit</code>命令。<br>注意：本方法不推荐用在生产系统中，未来会很难维护镜像。最好的创建镜像的方法是<code>Dockerfile</code>，修改镜像的方法是<code>修改Dockerfile</code>，然后重新从Dockerfile中构建新的镜像。</p><p>下面先基于ubuntu镜像创建一个容器,<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run -t -i --name updateimage ubuntu /bin/bash</span><br></pre></td></tr></table></figure></p><p>进入到容器中进行修改，创建三个新的文件夹，然后退出容器, 通过<code>docker diff</code>命令可以查看到确实做出了修改，然后通过<code>docker commit</code>命令将修改后的内容提交到本地，另存为镜像newbuntu, </p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">➜  ~ docker run -t -i --name updateimage ubuntu /bin/bash</span><br><span class="line">root@4a7b3923ad93:/<span class="comment"># touch /tmp/s&#123;1,2,3&#125;</span></span><br><span class="line">root@4a7b3923ad93:/<span class="comment"># ls -la /tmp/</span></span><br><span class="line">total 8</span><br><span class="line">drwxrwxrwt 1 root root 4096 Mar  7 03:53 .</span><br><span class="line">drwxr-xr-x 1 root root 4096 Mar  7 03:53 ..</span><br><span class="line">-rw-r--r-- 1 root root    0 Mar  7 03:53 s1</span><br><span class="line">-rw-r--r-- 1 root root    0 Mar  7 03:53 s2</span><br><span class="line">-rw-r--r-- 1 root root    0 Mar  7 03:53 s3</span><br><span class="line">root@4a7b3923ad93:/<span class="comment"># %                                                                                                                                                              ➜  ~ docker diff updateimage</span></span><br><span class="line">C /tmp</span><br><span class="line">A /tmp/s1</span><br><span class="line">A /tmp/s2</span><br><span class="line">A /tmp/s3</span><br><span class="line">➜  ~ docker images</span><br><span class="line">REPOSITORY          TAG                 IMAGE ID            CREATED             SIZE</span><br><span class="line">nginx               latest              6b914bbcb89e        6 days ago          182 MB</span><br><span class="line">ubuntu              latest              0ef2e08ed3fa        7 days ago          130 MB</span><br><span class="line">➜  ~ docker commit -m <span class="string">'add 3 dirs'</span> -a <span class="string">'newbuntu'</span> -p updateimage newbuntu</span><br><span class="line">sha256:2557af5f7c99b0f1dd61c32e5c70320c5181f8e288109220437ed51e829c996b</span><br><span class="line">➜  ~ docker images</span><br><span class="line">REPOSITORY          TAG                 IMAGE ID            CREATED             SIZE</span><br><span class="line">newbuntu            latest              2557af5f7c99        2 seconds ago       130 MB</span><br><span class="line">nginx               latest              6b914bbcb89e        6 days ago          182 MB</span><br><span class="line">ubuntu              latest              0ef2e08ed3fa        7 days ago          130 MB</span><br><span class="line">➜  ~</span><br></pre></td></tr></table></figure><p><code>docker commit</code>参数说明,</p><ul><li><code>-m</code>: 本次提交的描述</li><li><code>-a</code>: 指定镜像作者信息</li><li><code>-p</code>: 提交时暂停容器运行</li><li><code>updateimage</code>: 容器的ID或名称</li><li><code>newbuntu</code>: 目标镜像</li></ul><p>如果指定了目标镜像，Docker会创建新的镜像。类似我们修改一个word文档后进行的另存为。</p><h2 id="删除镜像"><a href="#删除镜像" class="headerlink" title="删除镜像"></a>删除镜像</h2><p>删除镜像命令:<code>docker rmi</code>, <code>docker rmi</code>命令可以删除本地的镜像，删除前需要先使用<code>docker rm</code> 删除所有依赖该镜像的容器。<code>docker rmi -f</code> 可以强制删除存在容器依赖的镜像，但这不是一个好习惯，请先删除容器再清理镜像。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ul><li>使用Docker Hub查找和下载镜像</li><li>创建镜像</li><li>查看镜像信息</li><li>导入和导出镜像</li><li>修改镜像</li><li>删除镜像</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在前面第一篇总结中已了解了一些镜像的概念，简单的说镜像就是一个容器的只读模板，用来创建容器。当运行容器时需要指定镜像，如果本地没有该镜像，则会从Docker Registry下载。默认查找的是&lt;code&gt;Docker Hub&lt;/code&gt;。Docker的镜像是增量的修改，每次创建新的镜像都会在老的镜像上面构建一个增量的层，使用到的技术是Another Union File System(AUFS)，具体可参考 &lt;a href=&quot;http://www.infoq.com/cn/articles/analysis-of-docker-file-system-aufs-and-devicemapper/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;剖析Docker文件系统：Aufs与Devicemapper&lt;/a&gt;, 下面主要总结记录使用和管理docker镜像的过程。&lt;/p&gt;
    
    </summary>
    
      <category term="docker-practice" scheme="http://researchlab.github.io/categories/docker-practice/"/>
    
    
      <category term="docker" scheme="http://researchlab.github.io/tags/docker/"/>
    
  </entry>
  
  <entry>
    <title>docker实践--02 数据卷管理</title>
    <link href="http://researchlab.github.io/2017/03/05/docker-data-volume/"/>
    <id>http://researchlab.github.io/2017/03/05/docker-data-volume/</id>
    <published>2017-03-05T00:44:31.000Z</published>
    <updated>2018-10-16T13:03:07.485Z</updated>
    
    <content type="html"><![CDATA[<p>Docker中的数据可以存储在类似于虚拟机磁盘的介质中，在Docker中称为<code>数据卷</code>(Data Volume)。数据卷可以用来存储Docker应用的数据，也可以用来在Docker容器间进行数据共享。数据卷呈现给Docker容器的形式就是一个目录，支持多个容器间共享，修改也不会影响镜像。使用Docker的数据卷，类似在系统中使用<code>mount</code> 挂载一个文件系统。<br><a id="more"></a></p><h2 id="创建数据卷"><a href="#创建数据卷" class="headerlink" title="创建数据卷"></a>创建数据卷</h2><p>利用<code>docker run</code>创建容器时, 添加<code>-v</code>参数, 就可以创建并挂载一个到多个数据卷到当前运行的容器中，<code>-v</code>参数的作用是将宿主机的一个目录作为容器的数据卷挂载到容器中，使宿主机和容器之间可以共享一个目录，如果本地路径不存在，Docker也会自动创建。</p><p>下面就通过挂载2个数据卷到新创建的容器上来操作一下,<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 创建两个目录</span></span><br><span class="line">➜  mkdir /tmp/data&#123;1,2&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 分别将两个目录挂载到新创建的data容器上</span></span><br><span class="line">➜  docker run -t -i --name data -v /tmp/data1:/data1 -v /tmp/data2:/data2 ubuntu /bin/bash</span><br></pre></td></tr></table></figure></p><p>上述命令中 -v 参数可以使用多次，并挂在多个数据卷到容器中。后面的参数信息中冒号前面是宿主机的本地目录，冒号后面是容器中的挂载目录, 结果如下,<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">➜  mkdir /tmp/data&#123;1,2&#125;</span><br><span class="line">➜  docker run -t -i --name data -v /tmp/data1:/data1 -v /tmp/data2:/data2 ubuntu /bin/bash</span><br><span class="line">root@8a8754728a1c:/<span class="comment"># ls</span></span><br><span class="line">bin  boot  data1  data2  dev  etc  home  lib  lib64  media  mnt  opt  proc  root  run  sbin  srv  sys  tmp  usr  var</span><br><span class="line">root@8a8754728a1c:/<span class="comment"># mount | grep data</span></span><br><span class="line">osxfs on /data1 <span class="built_in">type</span> fuse.osxfs (rw,nosuid,nodev,relatime,user_id=0,group_id=0,allow_other,max_read=1048576)</span><br><span class="line">osxfs on /data2 <span class="built_in">type</span> fuse.osxfs (rw,nosuid,nodev,relatime,user_id=0,group_id=0,allow_other,max_read=1048576)</span><br><span class="line">/dev/vda1 on /etc/resolv.conf <span class="built_in">type</span> ext4 (rw,relatime,data=ordered)</span><br><span class="line">/dev/vda1 on /etc/hostname <span class="built_in">type</span> ext4 (rw,relatime,data=ordered)</span><br><span class="line">/dev/vda1 on /etc/hosts <span class="built_in">type</span> ext4 (rw,relatime,data=ordered)</span><br><span class="line">root@8a8754728a1c:/<span class="comment"># ls -l data*</span></span><br><span class="line">data1:</span><br><span class="line">total 0</span><br><span class="line"></span><br><span class="line">data2:</span><br><span class="line">total 0</span><br><span class="line">root@8a8754728a1c:/<span class="comment">#</span></span><br></pre></td></tr></table></figure></p><p>进入容器后我们可以查看和使用容器卷，尝试向这个容器卷中写入数据，然后在宿主机中查看是否存在,<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">root@8a8754728a1c:/<span class="comment"># touch /data1/test1</span></span><br><span class="line">root@8a8754728a1c:/<span class="comment"># touch /data2/test2</span></span><br><span class="line">root@8a8754728a1c:/<span class="comment"># %                                                                                                ➜  helloworldimage ls /tmp/data1/test1</span></span><br><span class="line">➜  helloworldimage <span class="built_in">cd</span> /tmp/data2/test2</span><br><span class="line"><span class="built_in">cd</span>: not a directory: /tmp/data2/test2</span><br><span class="line">➜  helloworldimage <span class="built_in">cd</span> /tmp/data2</span><br><span class="line">➜  data2 ls</span><br><span class="line">test2</span><br></pre></td></tr></table></figure></p><p>可以看到容器中挂载的数据卷具备可写权限，那么如何对数据卷的权限进行管理呢？比如如何创建一个只读的数据卷呢？</p><h2 id="管理数据卷权限"><a href="#管理数据卷权限" class="headerlink" title="管理数据卷权限"></a>管理数据卷权限</h2><p>挂载的数据卷默认为可读写权限，除非外部文件系统做了特殊限制，在<code>docker run</code>时也可以执行为只读权限,<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 创建一个数据卷目录</span></span><br><span class="line">➜  mkdir /tmp/readonlydata</span><br><span class="line"><span class="comment"># 以只读的方式挂载到data容器上</span></span><br><span class="line">➜  docker run -t -i --name data -v /tmp/readonlydata:/rodata:ro ubuntu /bin/bash</span><br></pre></td></tr></table></figure></p><p>上面的命令中参数很简单, <code>ro</code>表示<code>readonly</code>, 挂载后的数据卷就是只读权限了, 此时再次尝试向数据卷中写入,<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">t@ad5299bae606:/<span class="comment"># mount | grep rodata</span></span><br><span class="line">osxfs on /rodata <span class="built_in">type</span> fuse.osxfs (ro,relatime,user_id=0,group_id=0,allow_other,max_read=1048576)</span><br><span class="line">root@ad5299bae606:/<span class="comment"># ls -l /rodata/</span></span><br><span class="line">total 0</span><br><span class="line">root@ad5299bae606:/<span class="comment"># touch /rodata/readonlydatafile</span></span><br><span class="line">touch: cannot touch <span class="string">'/rodata/readonlydatafile'</span>: Read-only file system</span><br></pre></td></tr></table></figure></p><p>除了可以挂载目录之外，文件也可以作为数据卷挂载到容器中。</p><h2 id="挂载宿主机文件"><a href="#挂载宿主机文件" class="headerlink" title="挂载宿主机文件"></a>挂载宿主机文件</h2><p>如果想让所有的容器都可以共享宿主机的/etc/apt/sources.list，从而只需要改变宿主机的apt源就能够影响到所有的容器。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run -t -i --name file -v /etc/apt/sources.list:/etc/apt/sources.list:ro ubuntu /bin/bash</span><br></pre></td></tr></table></figure></p><blockquote><p>此命令适合linux系统中执行，在mac os中无/etc/apt/sources.list文件</p></blockquote><p>如果想共享一个数据卷给多个容器怎么办，比如设想一个场景，我们有两个处理上传数据的应用运行在不同的容器中，但需要同时读取同一个文件夹下的文件，此时，最好的方式是使用数据卷容器。</p><h2 id="使用数据卷容器共享数据"><a href="#使用数据卷容器共享数据" class="headerlink" title="使用数据卷容器共享数据"></a>使用数据卷容器共享数据</h2><p>如果需要在多个容器间共享数据，并希望永久保存这些数据，最好的方式是使用数据卷容器，类似于一个提供网络文件共享服务的NFS服务器。</p><p>数据卷容器创建方法跟普通容器一样，只需要指定宿主机的一个文件夹作为数据卷即可，使用<code>docker create</code>命令创建但不启动数据卷容器,<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">➜ docker create -v /sharedb --name sharedb ubuntu /bin/<span class="literal">true</span></span><br><span class="line">b73abf556db4e76edc79bb7514cfa4067fd891ffb4d26105eec32ab612b83d78</span><br><span class="line">➜ docker ps</span><br><span class="line">dCONTAINER ID        IMAGE               COMMAND             CREATED             STATUS              PORTS               NAMES</span><br><span class="line">➜ docker ps -a</span><br><span class="line">CONTAINER ID        IMAGE               COMMAND             CREATED             STATUS              PORTS               NAMES</span><br><span class="line">b73abf556db4        ubuntu              <span class="string">"/bin/true"</span>         4 hours ago         Created                                 sharedb</span><br></pre></td></tr></table></figure></p><p>其他使用该数据卷容器的容器创建时候需要使用<code>--volumes-from</code>参数，指定该容器名称或ID,<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run --volumes-from sharedb...</span><br></pre></td></tr></table></figure></p><p>创建site1和site2两个容器挂载数据卷容器sharedb,<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">➜  ~ docker run --volumes-from sharedb --name site1 -t -i ubuntu /bin/bash</span><br><span class="line">root@e0984656600a:/# %                                                                                                ➜  ~ docker run --volumes-from sharedb --name site2 -t -i ubuntu /bin/bash</span><br><span class="line">root@7bf4a2ebe458:/# %                                                                                                ➜  ~ docker attach site1</span><br><span class="line">root@e0984656600a:/#</span><br><span class="line">root@e0984656600a:/# ls -l /sharedb/</span><br><span class="line">total 0</span><br><span class="line">root@e0984656600a:/# touch /sharedb/site1file</span><br><span class="line">root@e0984656600a:/# %                                                                                                ➜  ~ docker attach site2</span><br><span class="line">root@7bf4a2ebe458:/#</span><br><span class="line">root@7bf4a2ebe458:/# ls -l /sharedb/</span><br><span class="line">total 0</span><br><span class="line">-rw-r--r-- 1 root root 0 Mar  6 13:01 site1file</span><br><span class="line">root@7bf4a2ebe458:/# touch /sharedb/fromsite2file</span><br><span class="line">root@7bf4a2ebe458:/# %                                                                                                ➜  ~ docker attach site1</span><br><span class="line">root@e0984656600a:/#</span><br><span class="line">root@e0984656600a:/# ls /sharedb/</span><br><span class="line">fromsite2file  site1file</span><br><span class="line">root@e0984656600a:/#</span><br></pre></td></tr></table></figure></p><p>上面通过连接到这两个容器中对数据卷进行操作，并查看彼此之间已经有了共享文件。</p><h2 id="数据卷备份"><a href="#数据卷备份" class="headerlink" title="数据卷备份"></a>数据卷备份</h2><p>既然可以利用数据卷容器共享数据， 那如何备份这些共享数据呢？下面通过一个完整的案例来操作如何进行数据卷备份，</p><p>1.创建一个新的容器<br>2.挂载数据卷容器<br>3.挂载宿主机本地目录作为数据卷<br>4.将数据卷容器的内容备份到宿主机本地目录挂载的数据卷中<br>5.完成备份操作后容器销毁</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">➜  ~ docker run --rm --volumes-from sharedb -v /tmp/backup:/backup ubuntu tar cvf /backup/sharedb.tar /sharedb</span><br><span class="line">tar: Removing leading `/<span class="string">' from member names</span></span><br><span class="line"><span class="string">/sharedb/</span></span><br><span class="line"><span class="string">/sharedb/fromsite2_file</span></span><br><span class="line"><span class="string">/sharedb/fromsite1_file</span></span><br><span class="line"><span class="string">/sharedb/fromsite2file</span></span><br><span class="line"><span class="string">/sharedb/site1file</span></span><br><span class="line"><span class="string">➜  ~ docker ps</span></span><br><span class="line"><span class="string">CONTAINER ID        IMAGE               COMMAND             CREATED             STATUS              PORTS               NAMES</span></span><br><span class="line"><span class="string">2207035e4d5c        ubuntu              "/bin/bash"         4 hours ago         Up 2 minutes                            site2</span></span><br><span class="line"><span class="string">350af1aa2bc6        ubuntu              "/bin/bash"         4 hours ago         Up 3 minutes                            site1</span></span><br><span class="line"><span class="string">➜  ~ ls /tmp/backup/sharedb.tar</span></span><br></pre></td></tr></table></figure><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ul><li>创建数据卷</li><li>管理数据卷权限</li><li>挂载宿主机文件</li><li>使用数据卷容器共享数据</li><li>数据卷备份</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Docker中的数据可以存储在类似于虚拟机磁盘的介质中，在Docker中称为&lt;code&gt;数据卷&lt;/code&gt;(Data Volume)。数据卷可以用来存储Docker应用的数据，也可以用来在Docker容器间进行数据共享。数据卷呈现给Docker容器的形式就是一个目录，支持多个容器间共享，修改也不会影响镜像。使用Docker的数据卷，类似在系统中使用&lt;code&gt;mount&lt;/code&gt; 挂载一个文件系统。&lt;br&gt;
    
    </summary>
    
      <category term="docker-practice" scheme="http://researchlab.github.io/categories/docker-practice/"/>
    
    
      <category term="docker" scheme="http://researchlab.github.io/tags/docker/"/>
    
  </entry>
  
  <entry>
    <title>docker实践--01 创建docker应用</title>
    <link href="http://researchlab.github.io/2017/03/04/docker-basic-use/"/>
    <id>http://researchlab.github.io/2017/03/04/docker-basic-use/</id>
    <published>2017-03-04T09:05:58.000Z</published>
    <updated>2018-10-16T13:03:07.485Z</updated>
    
    <content type="html"><![CDATA[<p>很早就使用docker了，只是工作上一直没用起来， 加之工作多/杂，就只是断断续续自己瞎折腾，现在打算系统的整理总结一下docker使用经历，这个第一篇主要总结一下几个方面，<br><a id="more"></a></p><ul><li>理解Docker是什么</li><li>学习如何在Linux上安装Docker</li><li>学习如何使用Docker Hub</li><li>创建第一个Docker应用HelloWorld</li><li>Docker基本的容器和镜像管理</li></ul><h2 id="Docker-概念"><a href="#Docker-概念" class="headerlink" title="Docker 概念"></a>Docker 概念</h2><p>对比虚拟化技术，Docker容器与主机共享操作系统内核，不能像虚拟机那样运行独立的内核, 容器比虚拟化更轻量级, 对资源的消耗小很多。容器操作也更快捷，启动和停止都要比虚拟机快。Docker容器技术为使用者提供了更好的容器操作接口, 其中包括一系列的容器，镜像，网络等管理工具，可以让用户简单的创建和使用容器。<br>Docker支持将应用打包进一个可以移植的容器中，重新定义了应用开发，测试，部署上线的过程，核心理念就是<font color="red">Build once, Run anywhere</font>, Docker容器技术的典型应用场景是开发运维上提供持续集成和持续部署的服务。<br>在学习Docker容器技术时，首选要了解什么是<code>镜像</code>, 什么是<code>容器</code>, 什么是<code>仓库</code>等基础概念， 不过在阐述这些概念前推荐先阅读以下两篇文章，</p><ul><li><a href="http://www.infoq.com/cn/articles/docker-core-technology-preview" target="_blank" rel="noopener">深入浅出Docker(一): Docker核心技术预览</a><br>  这篇文章介绍了Docker产生的技术发展历程，Docker中的核心技术以及相关的子项目，非常好的入门资料。</li><li><a href="https://docs.docker.com/engine/understanding-docker/" target="_blank" rel="noopener">了解Docker容器技术的架构设计</a><br>  这篇Docker 官方的文章详细介绍了Docker的运行机制和必要的组件。不涉及到很底层的技术，可以做为对Docker的一个初步了解。</li></ul><p><strong> 什么是镜像? </strong></p><p>Docker的镜像概念类似于虚拟机里的镜像，是一个只读的模板，一个独立的文件系统，包括运行容器所需的数据，可以用来创建新的容器。<br>镜像可以基于Dockerfile构建，Dockerfile是一个描述文件，里面包含若干条命令，每条命令都会对基础文件系统创建新的层次结构。<br>用户可以通过编写Dockerfile创建新的镜像，也可以直接从类似github的Docker Hub上下载镜像使用。</p><p><strong> 什么是容器? </strong></p><p>Docker容器是由Docker镜像创建的运行实例。Docker容器类似虚拟机，可以支持的操作包括启动，停止，删除等。每个容器间是相互隔离的，但隔离的效果比不上虚拟机。容器中会运行特定的应用，包含特定应用的代码及所需的依赖文件。<br>在Docker容器中，每个容器之间的隔离使用Linux的 CGroups 和 Namespaces 技术实现的。其中 CGroups 对CPU，内存，磁盘等资源的访问限制，Namespaces 提供了环境的隔离。</p><p><strong> 什么是仓库? </strong></p><p>使用过git 和 github 就很容易理解Docker的仓库概念。Docker仓库相当于一个 github 上的代码库。<br>Docker 仓库是用来包含镜像的位置，Docker提供一个注册服务器（Registry）来保存多个仓库，每个仓库又可以包含多个具备不同tag的镜像。Docker运行中使用的默认仓库是 Docker Hub 公共仓库。<br>仓库支持的操作类似 git，创建了新的镜像后，我们可以 push 提交到仓库，也可以从指定仓库 pull 拉取镜像到本地。</p><h2 id="安装docker"><a href="#安装docker" class="headerlink" title="安装docker"></a>安装docker</h2><p>安装官方说明在Mac 上安装docker非常简单，直接在官方下载docker for mac的安装程序双击安装即可，安装完后，可以使用<code>docker version</code>查看Docker的版本信息，如我的,<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">er version</span><br><span class="line">Client:</span><br><span class="line"> Version:      17.03.0-ce</span><br><span class="line"> API version:  1.26</span><br><span class="line"> Go version:   go1.7.5</span><br><span class="line"> Git commit:   60ccb22</span><br><span class="line"> Built:        Thu Feb 23 10:40:59 2017</span><br><span class="line"> OS/Arch:      darwin/amd64</span><br><span class="line"></span><br><span class="line">Server:</span><br><span class="line"> Version:      17.03.0-ce</span><br><span class="line"> API version:  1.26 (minimum version 1.12)</span><br><span class="line"> Go version:   go1.7.5</span><br><span class="line"> Git commit:   3a232c8</span><br><span class="line"> Built:        Tue Feb 28 07:52:04 2017</span><br><span class="line"> OS/Arch:      linux/amd64</span><br><span class="line"> Experimental: <span class="literal">true</span></span><br></pre></td></tr></table></figure></p><p>如果可以看到version信息的话，说明docker 已经安装成功了，下面可以尝试执行如下命令，在docker中运行一个nginx 服务器，<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run -d -p 80:80 --name webserver nginx</span><br></pre></td></tr></table></figure></p><p>运行这个命令，docker首先会在本地找nginx:lastest镜像，如果没找到就会自动去<code>Docker Hub</code>公有仓库中去拉一个下来运行，运行上述命令之后， 就启动一个docker 应用nginx服务器了， 通过docker ps 命令查看 当前正在运行的服务器， 可以看到如下,<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">➜  ~ docker ps</span><br><span class="line">CONTAINER ID        IMAGE               COMMAND                  CREATED             STATUS              PORTS                         NAMES</span><br><span class="line">c1760b8f9359        nginx               <span class="string">"nginx -g 'daemon ..."</span>   3 hours ago         Up About an hour    0.0.0.0:80-&gt;80/tcp, 443/tcp   webserver</span><br></pre></td></tr></table></figure></p><blockquote><p>注: 在国内直接运行docker run -d -p 80:80 –name webserver nginx 命令多半会出现xxx Timeout 的提示，因为国内docker Hub站点被强了，所以需要先更换Docker Hub源再运行上述docker run 命令就可以成功，要更换Docker Hub源可以通过DaoCloud公司提供的Docker Hub加速器地址来解决， 具体做法可参考<a href="http://blog.daocloud.io/how-to-master-docker-image/" target="_blank" rel="noopener">how to master docker image</a>; </p></blockquote><p>此时就可以在浏览器中输入<code>http://0.0.0.0/</code>, 看到nginx服务器的欢迎界面咯，</p><center><img src="imgs/hi-nginx.png" alt="webserver-nginx"></center><p>可以通过<code>docker stats</code>命令查看当前所有container的运行状态,<code>docker stats</code> 可以查看到运行状态容器的CPU，内存及网络使用率。在实际工作中，我们通常会把这个命令的输出连接到类似Logstash一类的服务用来分析。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">➜  ~ docker stats</span><br><span class="line">CONTAINER           CPU %               MEM USAGE / LIMIT       MEM %               NET I/O             BLOCK I/O           PIDS</span><br><span class="line">c1760b8f9359        0.00%               1.859 MiB / 1.952 GiB   0.09%               16.1 kB / 4.58 kB   0 B / 0 B           2</span><br><span class="line">CONTAINER           CPU %               MEM USAGE / LIMIT       MEM %               NET I/O             BLOCK I/O           PIDS</span><br><span class="line">c1760b8f9359        0.00%               1.859 MiB / 1.952 GiB   0.09%               16.1 kB / 4.58 kB   0 B / 0 B           2</span><br></pre></td></tr></table></figure></p><p>这个命令的输出是实时刷新的(类似Linux上的top命令），如果需要退出可以使用<code>Ctrl-C</code>组合键。</p><h2 id="创建docker应用"><a href="#创建docker应用" class="headerlink" title="创建docker应用"></a>创建docker应用</h2><p><strong> 需求描述 </strong></p><p>Docker 安装后，下面来创建第一个Docker 应用。这个应用很简单，作用就是输出一句 HelloWorld!。</p><p><strong> 需求分析 </strong></p><p>应用执行的命令是 echo “HelloWorld”，可以为这条命令构建一个运行的容器，让这条命令在容器中运行，运行后容器自动退出。</p><p><strong>  解决方案 </strong></p><p>首先，需要有一个镜像来运行这个应用，这里选择用busybox镜像，直接使用docker run 命令来运行容器<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run busybox <span class="built_in">echo</span> <span class="string">"HelloWorld"</span></span><br></pre></td></tr></table></figure></p><p>首先docker run 会先在本地找busybox 这个镜像，如果找不到就会到Docker Hub上去下载一个下来，然后docker run 命令会基于指定的镜像busyzbox运行一个容器实例，然后把 echo “HelloWorld”命令传递给该容器执行,所以上述命令最终会再屏幕上输出 “HelloWorld”, 如下,<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">➜  ~ docker run busybox <span class="built_in">echo</span> <span class="string">"HelloWorld"</span></span><br><span class="line">Unable to find image <span class="string">'busybox:latest'</span> locally</span><br><span class="line">latest: Pulling from library/busybox</span><br><span class="line">4b0bc1c4050b: Pull complete</span><br><span class="line">Digest: sha256:348432dd709c2cd6ca42e56c2a0d157f611c50c908e14c9bfc1e9cb0ed234871</span><br><span class="line">Status: Downloaded newer image <span class="keyword">for</span> busybox:latest</span><br><span class="line">HelloWorld</span><br></pre></td></tr></table></figure></p><p>执行 docker ps 命令查看运行的容器列表，但看不到任何容器在运行，原因是容器运行了echo 命令后已经终止，进入到停止状态，需要用 docker ps -a 命令查看,<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">➜  ~ docker ps</span><br><span class="line">CONTAINER ID        IMAGE               COMMAND             CREATED             STATUS              PORTS               NAMES</span><br><span class="line">➜  ~ docker ps -a</span><br><span class="line">CONTAINER ID        IMAGE               COMMAND                  CREATED             STATUS                          PORTS               NAMES</span><br><span class="line">65948b8f61eb        busybox             <span class="string">"echo HelloWorld"</span>        About an hour ago   Exited (0) 2 minutes ago                            xenodochial_bohr</span><br></pre></td></tr></table></figure></p><p>在这个命令的输出中我们看到列表里有一个处于 Exited (0) 2 minutes ago 的容器，这个容器表示大约2分钟之前终止。列表中还包括该容器的ID，使用的镜像，执行的命令，创建的时间等信息。最后一个是为容器随机设置的名称，也可以通过run的参数进行设置为指定名称，注意同一个服务器上的容器不可以同名。</p><h2 id="容器管理"><a href="#容器管理" class="headerlink" title="容器管理"></a>容器管理</h2><p>上面通过docker run 命令在指定的镜像中运行一个容器，然后在容器中执行我们的应用程序，下面通过实践来了解docker容器管理中最常用的几个命令,</p><p><strong> 1. 创建运行并容器: docker run </strong></p><p>最主要的是创建运行容器的命令<code>docker run</code>，这个命令的参数非常多，可以通过<code>docker run --help</code> 查看。<br>继续上一节实验，echo 命令运行后容器就退出了，如果我们需要一个保持运行的容器呢，最简单的方法就是给这个容器一个可以保持的应用，比如bash，运行 ubuntu 容器并进入容器的 bash：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run -t -i ubuntu /bin/bash</span><br></pre></td></tr></table></figure></p><p>上面命令的说明：<br><code>-t</code>：分配一个 pseudo-TTY<br><code>-i</code>：–interactive参数缩写，表示交互模式<br><code>ubuntu</code>：运行的镜像名称，默认为latest 标签<br><code>/bin/bash</code>：容器中运行的应用<br>通过这个简单的命令，我们现在进入了新创建容器的bash中，在bash里执行的任何命令都不会影响到我们的宿主机，可以随意操作。你可以看到主机名和环境变量HOSTNAME都已经显示为容器的ID了。在这个bash下，我们可以进行各种Ubuntu系统上的操作，当然因为Docker本身的限制，有些涉及到磁盘、网络、设备等Linux特权命令是无法执行的，可以试试reboot命令，会提示你shutdown: Unable to shutdown system。</p><p>如何退出这个bash呢？有两种方法，两种方法的效果完全不同,</p><ul><li>直接<code>exit</code>，这时候<code>bash</code>程序终止，容器进入到停止状态</li><li>使用组合键退出，仍然保持容器运行，我们可以随时回来到这个bash中来，组合键是<code>Ctrl-p Ctrl-q</code>，你没有看错，是两组组合键，先同时按下Ctrl和p，再按Ctrl和q。就可以退出到我们的宿主机了。</li></ul><p>上述第二种方法比较常用，此时使用<code>docker ps</code> 查看，能看到容器仍然在运行中：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">➜  ~ docker run -t -i ubuntu /bin/bash</span><br><span class="line">Unable to find image <span class="string">'ubuntu:latest'</span> locally</span><br><span class="line">latest: Pulling from library/ubuntu</span><br><span class="line">d54efb8db41d: Pull complete</span><br><span class="line">f8b845f45a87: Pull complete</span><br><span class="line">e8db7bf7c39f: Pull complete</span><br><span class="line">9654c40e9079: Pull complete</span><br><span class="line">6d9ef359eaaa: Pull complete</span><br><span class="line">Digest: sha256:f649e49c1ed34607912626a152efbc23238678af1ac37859b6223ef28e711a3f</span><br><span class="line">Status: Downloaded newer image <span class="keyword">for</span> ubuntu:latest</span><br><span class="line">root@65fc97a6b032:/<span class="comment"># %</span></span><br><span class="line">➜  ~ docker ps</span><br><span class="line">CONTAINER ID        IMAGE               COMMAND             CREATED             STATUS              PORTS               NAMES</span><br><span class="line">65fc97a6b032        ubuntu              <span class="string">"/bin/bash"</span>         About an hour ago   Up 4 minutes                            kickass_goodall</span><br></pre></td></tr></table></figure></p><p>如果想再次回到刚才的bash中，只需要使用<code>docker attach</code>命令就可以再次连接到运行的bash里：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">➜  ~ docker ps</span><br><span class="line">CONTAINER ID        IMAGE               COMMAND             CREATED             STATUS              PORTS               NAMES</span><br><span class="line">65fc97a6b032        ubuntu              <span class="string">"/bin/bash"</span>         About an hour ago   Up 4 minutes                            kickass_goodall</span><br><span class="line">➜  ~ docker attach 65fc9</span><br><span class="line">root@65fc97a6b032:/<span class="comment">#</span></span><br></pre></td></tr></table></figure></p><p><strong> 注意</strong> ：命令后面的参数是容器的ID，并不需要输入完整的数字，只要能唯一定位这个容器即可，通常输入4位就足够了。</p><p><code>docker run</code>命令的执行分一下几步，<br>1.查找镜像或下载镜像<br>2.创建容器<br>3.分配文件系统及虚拟网络（网桥，接口，IP地址），其中容器中的DNS默认挂载宿主机的<code>/etc/resolve.conf</code>和<code>/etc/hosts</code>。<br>4.执行应用, 默认执行镜像中指定的<code>Cmd</code>参数，也可以在<code>docker run</code>后面跟应用来覆盖<code>Cmd</code>命令。</p><p>如果容器中的应用执行完成, 则容器进入到终止状态。</p><p><code>docker run</code>的参数非常多, 假设按如下容器配置设定创建新容器,</p><ul><li>设置容器名称 bash（使用–name，如果不加该参数，Docker会随机产生一个名字）。</li><li>设置容器的主机名 bashHost(使用–hostname参数）</li><li>设定网络信息，这里只使用一个简单的参数设置MAC地址（–mac-address参数）</li><li>设置资源限制，设置容器中最大的进程数，包括soft和hard两个限制值（使用-ulimit nproc=…等参数）</li><li>创建容器过程中也可以挂载数据卷，数据卷在下一节实验中会详细介绍。这里不过多涉及。</li></ul><p>根据上述的需求我们通过查询<code>docker run --help</code>, 使用相关参数, 创建符合要求的容器,<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">➜  docker run --name bash --hostname bashHost --mac-address 00:01:02:03:04:05 --<span class="built_in">ulimit</span> nproc=1024:2048 -t -i ubuntu /bin/bash</span><br></pre></td></tr></table></figure></p><p>进入容器中我们可以对一些参数进行验证,<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">➜  docker run --name bash --hostname bashHost --mac-address 00:01:02:03:04:05 --<span class="built_in">ulimit</span> nproc=1024:2048 -t -i ubuntu /bin/bash</span><br><span class="line">root@bashHost:/<span class="comment"># hostname</span></span><br><span class="line">bashHost</span><br><span class="line">root@bashHost:/<span class="comment"># ulimit</span></span><br><span class="line">unlimited</span><br><span class="line">root@bashHost:/<span class="comment"># % </span></span><br><span class="line">➜  docker inspect -f <span class="string">'&#123;&#123;.HostConfig.Ulimits&#125;&#125;'</span> bash</span><br><span class="line">[nproc=1024:2048]</span><br></pre></td></tr></table></figure></p><p>注，容器中的 ulimit 不会有任何输出，查看实际的ulimit信息可以在宿主机上使用docker inspect查看,</p><p><strong> 2. 查看容器列表: docker ps </strong></p><p><code>docker ps</code>命令用来查看正在运行的容器信息,几个最常用的参数：<br><code>-a</code>：查看所有容器，含停止运行的<br><code>-l</code>：查看刚启动的容器<br><code>-q</code>：只显示容器ID</p><p>例如查看所有容器的ID列表,则执行<code>docker ps -a -q</code>命令即可。</p><p><strong> 3. 查看容器详细信息: docker inspect </strong></p><p>docker inspect 查看容器的细节信息，包括创建时间，操作命令，端口映射信息，IP地址等等。<br>查看Docker容器或镜像的一些内部信息, 默认输出JSON格式的信息，可以通过-f指定输出的项目。 如启动并查看<code>/bin/bash</code>容器,<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">➜  ~ docker start 65fc</span><br><span class="line">65fc</span><br><span class="line">➜  ~ docker inspect 65fc</span><br><span class="line">[</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="string">"Id"</span>: <span class="string">"65fc97a6b0324436f4f9843f06657473d6cf441318937d243b395aff13d6d466"</span>,</span><br><span class="line">        <span class="string">"Created"</span>: <span class="string">"2017-03-05T12:47:04.372874677Z"</span>,</span><br><span class="line">        <span class="string">"Path"</span>: <span class="string">"/bin/bash"</span>,</span><br><span class="line">        <span class="string">"Args"</span>: [],</span><br><span class="line">.....</span><br><span class="line">➜  docker ps -a</span><br><span class="line">CONTAINER ID        IMAGE               COMMAND                  CREATED             STATUS              PORTS               NAMES</span><br><span class="line">d3efa7a729ba        ubuntu              <span class="string">"/bin/bash -c 'whi..."</span>   4 hours ago         Up 6 minutes                            bash</span><br><span class="line">➜  docker inspect -f <span class="string">'&#123;&#123;.NetworkSettings.IPAddress&#125;&#125;'</span> d3ef</span><br><span class="line">172.17.0.2</span><br><span class="line">➜  docker inspect -f <span class="string">'&#123;&#123;.NetworkSettings.Gateway&#125;&#125;'</span> bash</span><br><span class="line">172.17.0.1</span><br></pre></td></tr></table></figure></p><p>返回的信息非常多，是JSON格式，每一项内容具体含义本节不做详细介绍，可以参考官方文档。<br>上述命令中我们查看了网络配置信息中的IP地址和Gateway地址。</p><p><strong> 4. 查看容器内进程信息: docker top </strong></p><p>查看容器中运行的进程信息，显示容器中进程的PID，UID，PPID，时间，tty等信息,<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">➜  ~ docker top 65fc</span><br><span class="line">PID                 USER                TIME                COMMAND</span><br><span class="line">3073                root                0:00                /bin/bash</span><br></pre></td></tr></table></figure></p><p><strong> 5. 查看容器输出信息: docker logs </strong><br>获取容器的输出信息可以使用<code>docker logs</code>命令，使用<code>docker attach</code> 回到刚才创建的<code>/bin/bash容器</code>中，写一个循环输出信息的脚本，然后再使用<code>Ctrl-P Ctrl-Q</code>组合键退出。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">➜  docker run -t -i --name bash ubuntu /bin/bash -c <span class="string">"while true; do echo 'Hello world'; sleep 1; done"</span></span><br></pre></td></tr></table></figure></p><p>在宿主机的终端中，我们可以用<code>docker logs</code>命令查看输出信息。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">➜  docker logs bash</span><br><span class="line">Hello world</span><br><span class="line">Hello world</span><br><span class="line">Hello world</span><br></pre></td></tr></table></figure></p><p><code>docker logs</code>只会显示截止到当前的所有输出，如果想动态查看实时输出，也可以加<code>-f</code>参数，类似<code>tail</code>命令</p><p><strong> 6. 查看容器中的修改: docker diff </strong></p><p><code>docker diff</code> 查看容器中对镜像做了哪些变化。</p><p>先执行<code>docker diff</code> 查看现有的容器中的变化，发现没有任何文件变化, 连接到容器内部，<code>Ctrl-C</code>中断先前实验的死循环,再创建几个文件,退出到宿主机,再次使用docker diff命令查看是否有新的修改<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">➜  docker diff bash</span><br><span class="line">➜  docker attach bash</span><br><span class="line">root@efb833099bb1:/<span class="comment">#</span></span><br><span class="line">root@efb833099bb1:/<span class="comment"># cd tmp/</span></span><br><span class="line">root@efb833099bb1:/tmp<span class="comment"># touch s&#123;1,2,3&#125;</span></span><br><span class="line">root@efb833099bb1:/tmp<span class="comment"># %                                                                                             </span></span><br><span class="line">➜  docker diff bash</span><br><span class="line">C /tmp</span><br><span class="line">A /tmp/s1</span><br><span class="line">A /tmp/s2</span><br><span class="line">A /tmp/s3</span><br><span class="line">➜  docker attach bash</span><br><span class="line">root@efb833099bb1:/tmp<span class="comment">#</span></span><br><span class="line">root@efb833099bb1:/tmp<span class="comment"># rm s1</span></span><br><span class="line">root@efb833099bb1:/tmp<span class="comment"># % </span></span><br><span class="line">➜  docker diff bash</span><br><span class="line">C /tmp</span><br><span class="line">A /tmp/s2</span><br><span class="line">A /tmp/s3</span><br></pre></td></tr></table></figure></p><p>输出的信息中<code>A</code> 表示添加，后面的三个新建文件的路径。可以尝试下修改或删除文件会有怎样的diff输出。</p><p><strong> 7. 容器的守护状态 </strong></p><p>首先需要了解的概念是容器的守护状态，类似于守护进程，需要为<code>run</code>命令增加参数<code>-d</code>，此时容器在后台以守护状态(Daemonized)形式运行。</p><p>创建一个守护状态的容器,<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">➜  docker run --name bash -d ubuntu /bin/bash -c <span class="string">"while true; do echo 'Hello world'; sleep 1; done"</span></span><br></pre></td></tr></table></figure></p><p>会启动一个守护状态的容器在后台运行, 使用<code>docker attach</code> 登录上去可以看到循环输出Hello world 的字符串。</p><p><strong> 8. 停止容器: docker stop </strong></p><p>停止运行状态的容器，进入到终止状态。停止状态的容器可以通过 docker ps -a 查看到。</p><p>首先使用 <code>docker stop container</code> 命令停止名称为container的容器,然后使用docker ps -a 查看容器状态，</p><p><strong> 9. 启动容器: docker start </strong></p><p>启动停止状态的容器。再次启动名称为container的容器,<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker start container</span><br></pre></td></tr></table></figure></p><p><strong> 10. 重启容器: docker restart </strong></p><p>可以将运行状态的容器终止，然后重新启动。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker restart container</span><br></pre></td></tr></table></figure></p><p><strong> 11. 杀死容器: docker kill </strong></p><p>跟进程相同，有的时候正常的终止操作不起作用时，需要使用<code>kill</code>命令杀死进程，在<code>docker kill</code>可以处理异常的运行状态的容器，强制退出, 杀死名为<code>container</code>的容器命令,<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker <span class="built_in">kill</span> container</span><br></pre></td></tr></table></figure></p><p><strong> 12. 暂停和恢复容器: docker pause/unpause </strong></p><p>类似Windows操作系统的睡眠，我们可以先临时将容器的运行挂起，不再使用CPU资源，当需要的时候再恢复成正常的运行状态。<br>先启动容器, 再执行pause操作, 再unpause恢复,<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">docker start container </span><br><span class="line">docker pause container </span><br><span class="line">docker unpause container</span><br></pre></td></tr></table></figure></p><p><strong> 13. 删除容器: docker rm </strong></p><p>当一个容器不再需要时，我们可以删除这个容器。对于停止的容器直接执行<code>docker rm 容器ID</code>, 对于运行状态的容器也可以执行<code>docker rm -f 容器ID强制删除</code>。</p><p>导出和导入容器操作可以将容器导出到压缩包，并可将压缩包导入到Docker系统中成为镜像，为容器的迁移和镜像的制作提供支持。</p><p><strong> 14. 容器导出: docker export </strong></p><p>导出容器快照到本地的tar包。导出后的文件可以拷贝到其他<code>Docker服务器</code>上执行导入命令形成新的镜像，下面选择导出刚才建立的容器new_container到到tar包, 保存到当前目录, 具体命令如下,<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">docker run --name new_container -t -i ubuntu /bin/bash</span><br><span class="line">root@6c8edd28ad65:/<span class="comment"># cd tmp/</span></span><br><span class="line">root@6c8edd28ad65:/tmp<span class="comment"># touch s&#123;1,2,3&#125;</span></span><br><span class="line">root@6c8edd28ad65:/tmp<span class="comment"># ls</span></span><br><span class="line">s1  s2  s3</span><br><span class="line">root@6c8edd28ad65:/tmp<span class="comment"># %                                                                                             </span></span><br><span class="line">➜  docker diff new_container</span><br><span class="line">C /tmp</span><br><span class="line">A /tmp/s1</span><br><span class="line">A /tmp/s2</span><br><span class="line">A /tmp/s3</span><br><span class="line">➜  docker ps -a</span><br><span class="line">CONTAINER ID        IMAGE               COMMAND             CREATED             STATUS              PORTS               NAMES</span><br><span class="line">6c8edd28ad65        ubuntu              <span class="string">"/bin/bash"</span>         4 hours ago         Up 44 seconds                           new_container</span><br><span class="line">➜  docker <span class="built_in">export</span> 6c8e &gt; new_container.tar</span><br><span class="line">➜  ls</span><br><span class="line">Dockerfile        new_container.tar</span><br></pre></td></tr></table></figure></p><blockquote><p>需要注意的是，当容器导出后，容器仍然在Docker环境中运行，只是拷贝了一份内容到tar包。</p></blockquote><p><strong>  15. 容器导入: docker import </strong></p><p>执行导入命令，将该文件加载到docker系统中，文件加载后会成为镜像，命令执行时需要制定导入后生成的镜像的名字,<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cat new_container.tar | docker import new_container:1.0</span><br></pre></td></tr></table></figure></p><p>执行导入后，使用docker images 查看是否有新的镜像产生,<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">➜  docker images</span><br><span class="line">REPOSITORY          TAG                 IMAGE ID            CREATED             SIZE</span><br><span class="line">nginx               latest              6b914bbcb89e        6 days ago          182 MB</span><br><span class="line">ubuntu              latest              0ef2e08ed3fa        6 days ago          130 MB</span><br><span class="line">busybox             latest              7968321274dc        7 weeks ago         1.11 MB</span><br><span class="line">➜  cat new_container.tar| docker import - new_container:1.0</span><br><span class="line">sha256:dd10880b0d88c4d4159c3c29c034d46dc52c5d8d9d52ee5385aff687d0967216</span><br><span class="line">➜  docker images</span><br><span class="line">REPOSITORY          TAG                 IMAGE ID            CREATED             SIZE</span><br><span class="line">new_container       1.0                 dd10880b0d88        4 hours ago         111 MB</span><br><span class="line">nginx               latest              6b914bbcb89e        6 days ago          182 MB</span><br><span class="line">ubuntu              latest              0ef2e08ed3fa        6 days ago          130 MB</span><br><span class="line">busybox             latest              7968321274dc        7 weeks ago         1.11 MB</span><br></pre></td></tr></table></figure></p><p>docker import 命令比较灵活，也可以直接从URL链接进行导入。所以可以记住这是一种创建镜像的方式，将容器导出后拷贝到目标服务器然后导入成镜像。</p><p>使用新镜像创建容器，查看是否与导出的容器内容一致,<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">➜  docker run --name new_new_container -t -i new_container:1.0 /bin/bash</span><br><span class="line">root@eeef608f020b:/<span class="comment"># cd tmp/</span></span><br><span class="line">root@eeef608f020b:/tmp<span class="comment"># ls</span></span><br><span class="line">s1  s2  s3</span><br><span class="line">root@eeef608f020b:/tmp<span class="comment">#</span></span><br></pre></td></tr></table></figure></p><h2 id="镜像管理"><a href="#镜像管理" class="headerlink" title="镜像管理"></a>镜像管理</h2><p>先来简单了解一下镜像管理的基本概念,</p><p><strong> 查看镜像列表 </strong></p><p><code>docker images</code> 命令可以列出当前系统上所有的镜像信息,<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">➜  ~ docker images</span><br><span class="line">REPOSITORY          TAG                 IMAGE ID            CREATED             SIZE</span><br><span class="line">nginx               latest              6b914bbcb89e        4 days ago          182 MB</span><br><span class="line">ubuntu              latest              0ef2e08ed3fa        5 days ago          130 MB</span><br><span class="line">busybox             latest              7968321274dc        7 weeks ago         1.11 MB</span><br></pre></td></tr></table></figure></p><p>其中：<br><code>REPOSITORY</code>：仓库名称<br><code>TAG</code>：标签名，一个仓库可以有若干个标签对应不同的镜像，默认都是latest<br><code>IMAGE ID</code>：镜像ID<br><code>CREATED</code>：创建时间，注意不是本地的pull时间<br><code>SIZE</code>：镜像大小</p><p><strong> 获取镜像 </strong></p><p>最简单的获取镜像的方式是从 Docker Hub上 pull 最新的镜像，比如我们想要一个<code>busybox</code> 的镜像，直接使用命令<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker pull busybox</span><br></pre></td></tr></table></figure></p><p><strong> 创建镜像 </strong></p><p>最常用的是写一个<code>Dockerfile</code>，从<code>Dockerfile</code>里创建新的镜像。<br><code>Dockerfile</code>的详细编写方法我们后续有专门的实验介绍，此处只写一个最简单的<code>Dockerfile</code>来介绍。<br>使用vim打开一个文件<code>Dockerfile</code>, 写入如下两行保存,<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">from ubuntu:latest</span><br><span class="line">ENV HOSTNAME=HelloWorld</span><br></pre></td></tr></table></figure></p><p>这个<code>Dockerfile</code> 中只有两行，<br>第一行表示基于哪个镜像创建新的镜像，类似于程序开发中的<code>import</code> 或<code>include</code>，这里以<code>ubuntu:latest</code>镜像为基础创建新的镜像。第二行是在新的镜像中我们要对基础镜像 ubuntu:latest 做的改变。这句是设置一个环境变量HOSTNAME等于HelloWorld。完成<code>Dockerfile</code> 后，使用<code>docker build</code> 命令进行构建：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker build -t hellworld .</span><br></pre></td></tr></table></figure></p><p>这个命令中第一个参数<code>-t helloworld</code>指定创建的新镜像的名字，第二个参数是一个点 <code>.</code> 指定从当前目录查找<code>Dockerfile</code> 文件，编译结果如图,<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">➜  docker build -t HelloWorld .</span><br><span class="line">invalid argument <span class="string">"HelloWorld"</span> <span class="keyword">for</span> t: Error parsing reference: <span class="string">"HelloWorld"</span> is not a valid repository/tag: repository name must be lowercase</span><br><span class="line">See <span class="string">'docker build --help'</span>.</span><br><span class="line">➜  docker build -t helloworld .</span><br><span class="line">Sending build context to Docker daemon 2.048 kB</span><br><span class="line">Step 1/2 : FROM ubuntu:latest</span><br><span class="line"> ---&gt; 0ef2e08ed3fa</span><br><span class="line">Step 2/2 : ENV HOSTNAME HelloWorld</span><br><span class="line"> ---&gt; Running <span class="keyword">in</span> d0f16b14164e</span><br><span class="line"> ---&gt; de0c24b4dc2e</span><br><span class="line">Removing intermediate container d0f16b14164e</span><br><span class="line">Successfully built de0c24b4dc2e</span><br></pre></td></tr></table></figure></p><p>如结果所示，镜像名必须小写。执行<code>docker images</code> 命令就可以看到新的<code>helloworld</code>镜像了。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">➜  docker images</span><br><span class="line">REPOSITORY          TAG                 IMAGE ID            CREATED             SIZE</span><br><span class="line">helloworld          latest              de0c24b4dc2e        About an hour ago   130 MB</span><br><span class="line">nginx               latest              6b914bbcb89e        4 days ago          182 MB</span><br><span class="line">ubuntu              latest              0ef2e08ed3fa        5 days ago          130 MB</span><br><span class="line">busybox             latest              7968321274dc        7 weeks ago         1.11 MB</span><br><span class="line">➜  docker run -t -i helloworld /bin/bash</span><br><span class="line">root@3ce776c1ee74:/<span class="comment"># echo $HOSTNAME</span></span><br><span class="line">HelloWorld</span><br><span class="line">root@3ce776c1ee74:/<span class="comment">#</span></span><br></pre></td></tr></table></figure></p><p>上述结果知, 通过<code>docker run</code>命令运行新的镜像，然后通过<code>echo $HOSTNAME</code> 果然是之前设置的<code>HelloWorld</code>名称。</p><p><strong> 清理镜像 </strong></p><p>通过命令退出上述<code>helloworld</code>容器后，可使用<code>docker rm</code> 命令删除容器，并使用<code>docker rmi</code> 删除镜像。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">➜  docker rm -f 3ce7</span><br><span class="line">3ce7</span><br><span class="line">➜  docker rmi helloworld</span><br><span class="line">Untagged: helloworld:latest</span><br><span class="line">Deleted: sha256:de0c24b4dc2ee6512b8c95d15b532b162dc883c7e5caf8aa00939fa5712fb7d1</span><br></pre></td></tr></table></figure></p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ul><li>理解Docker是什么</li><li>学习如何在Mac上安装Docker</li><li>学习如何使用Docker Hub</li><li>创建第一个HelloWorld 的Docker应用</li><li>Docker基本的容器和镜像管理</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;很早就使用docker了，只是工作上一直没用起来， 加之工作多/杂，就只是断断续续自己瞎折腾，现在打算系统的整理总结一下docker使用经历，这个第一篇主要总结一下几个方面，&lt;br&gt;
    
    </summary>
    
      <category term="docker-practice" scheme="http://researchlab.github.io/categories/docker-practice/"/>
    
    
      <category term="docker" scheme="http://researchlab.github.io/tags/docker/"/>
    
  </entry>
  
  <entry>
    <title>基于fzzy/radix/redis封装新的redispool</title>
    <link href="http://researchlab.github.io/2017/03/02/redispool-baseon-fzzy-radix/"/>
    <id>http://researchlab.github.io/2017/03/02/redispool-baseon-fzzy-radix/</id>
    <published>2017-03-02T14:42:42.000Z</published>
    <updated>2018-10-16T13:03:07.485Z</updated>
    
    <content type="html"><![CDATA[<p>之前的老项目的redis client sdk 直接大名鼎鼎的<code>github.com/fzzy/radix</code>提供的<code>redis client</code> 和<code>redis pool</code>, 当访问峰值达到一定的值后会出现<code>too many open files</code>等tcp连接错误，同时也没有直接提供authorization 密钥认证的接口，为满足这些新需求基于<code>fzzy/radix</code>封装出的新的<code>redispool</code>, 已投入生产使用半年来暂无问题，本文总结如下,<br><a id="more"></a></p><h2 id="auth认证"><a href="#auth认证" class="headerlink" title="auth认证"></a>auth认证</h2><p>如果redis server 需要密钥访问的话，每新建一个client 连接后都需要先通过authorization认证之后才能被使用，如果每次都通过新建一个redis client 再oauth认证来用显然没什么问题，但对于要频繁进行redis操作的系统而言，最好采用redis pool 的办法来解决，用redis conn 池本来也很好解决， 就是在新建redis conn pool时 每新建一个redis client就auth认证一下然后再保存起来就可以使用了，并且这个连接以后都不需要在进行auth认证了。<br>如果redis pool在新建之后就固定的话， 是可以如上面这么简单的，但是采用的<code>fzzy/radix</code>包在实现的方案是可根据需要自动伸缩地新建redis client conn,之前设置的redis 连接池的大小其实是最小的空闲连接池，当业务需求需要的redis client连接数大于pool中的数目时则会通过redis.Dial()的方法新建一个redis client conn 以满足业务的需求，即在建立redis连接池的时候auth认证的redis client conn 和最后回到pool池中的redis client conn 可能就不是同一个client了，因为当新的redis client conn 塞满redis 连接池后 之前auth认证过的旧的redis client conn就会被Close关闭到而不再回到pool池中，具体实现如下:<br><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p *RedisPool)</span> <span class="title">getRedisClient</span><span class="params">()</span> <span class="params">(*redis.Client, error)</span></span> &#123;</span><br><span class="line">client, err := redis.Dial(p.network, p.addr)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span>, err</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> <span class="built_in">len</span>(p.pwd) != <span class="number">0</span> &#123;</span><br><span class="line"><span class="keyword">if</span> client, err = p.redisAuth(client); err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span>, err</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> client, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p *RedisPool)</span> <span class="title">redisAuth</span><span class="params">(client *redis.Client)</span> <span class="params">(*redis.Client, error)</span></span> &#123;</span><br><span class="line"><span class="keyword">if</span> _, err := client.Cmd(<span class="string">"AUTH"</span>, p.pwd).Str(); err != <span class="literal">nil</span> &#123;</span><br><span class="line">client.Close()</span><br><span class="line"><span class="keyword">return</span> client, err</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> client, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>上述代码提供了一个redisAuth方法来提供auth认证，这样不管是通过新建redis池还是当池中redis client conn耗尽之后单独新建的redis client 都通过上述提供getRedisClient()方法来获取新建的redis client conn ,这样便可保证每次新建的redis client conn 都是通过auth认证的(当然上次实现的时候如果没有设置密码，则不进行密钥认证，只有设置了密钥才会调用auth进行认证授权)。</p><h2 id="qps限制"><a href="#qps限制" class="headerlink" title="qps限制"></a>qps限制</h2><p>因为<code>fzzy/radix</code>包当初始化创建的redis 连接池中的redis client 耗尽后会通过redis.Dial()方法新建一个redis.client, 如果在某一个峰值redis连接池耗尽的同时大量新建redis.client 而不能及时Close掉这些redis.Client,则后继再redis.Dial()新建的redis client conn 就会因为受系统限制无法分配文件句柄地址而报”too many open files”错误。具体试验可以先限制redis连接池为100, 然后同时发起10w redis 连接请求， 可以通过下面的命令观察到当redis client conn最大分配的大小，超过之后程序也会崩掉。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">watch -n 1 <span class="string">"redis-cli -h localhost -p 6379 -a 123456 client list | wc -l"</span> <span class="comment"># redis client 连接数</span></span><br><span class="line">watch -n 1 <span class="string">"lsof -i:6379 | wc -l "</span> <span class="comment"># redis tcp 连接数</span></span><br></pre></td></tr></table></figure></p><p>上述命令可以动态看到每一秒内当前的redis client 连接数目 和 tcp 连接数</p><p>显然程序不能仍由业务需求无限的取申请redis client 连接数， 本文设计通过每次成功Get到一个redis client时 则通过<code>sync/atomic</code>包原子的给qps新增一 进行计数，当Put到池或Empty全部清空时则进行减一 计数操作, 具体实现如下,<br><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Retrieves an available redis client. If there are none available it will</span></span><br><span class="line"><span class="comment">// create a new one on the fly</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p *RedisPool)</span> <span class="title">Get</span><span class="params">()</span> <span class="params">(client *redis.Client, err error)</span></span> &#123;</span><br><span class="line"><span class="keyword">if</span> p.qpsLimit &gt; <span class="number">0</span> &#123;</span><br><span class="line"><span class="keyword">for</span> p.qps &gt; p.qpsLimit &#123;</span><br><span class="line">time.Sleep(time.Millisecond * time.Duration(<span class="number">10</span>))</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">3</span>; i++ &#123;</span><br><span class="line"><span class="keyword">if</span> client, err = p.get(); err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">break</span></span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> pstate, perr := client.Cmd(<span class="string">"PING"</span>).Str(); pstate == <span class="string">"PONG"</span> &amp;&amp; perr == <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">break</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> err == <span class="literal">nil</span> &#123;</span><br><span class="line">atomic.AddInt32(&amp;p.qps, <span class="number">1</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Returns a client back to the pool. If the pool is full the client is closed</span></span><br><span class="line"><span class="comment">// instead. If the client is already closed (due to connection failure or</span></span><br><span class="line"><span class="comment">// what-have-you) it should not be put back in the pool. The pool will create</span></span><br><span class="line"><span class="comment">// more connections as needed.</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p *RedisPool)</span> <span class="title">Put</span><span class="params">(conn *redis.Client)</span></span> &#123;</span><br><span class="line"><span class="keyword">select</span> &#123;</span><br><span class="line"><span class="keyword">case</span> p.pool &lt;- conn:</span><br><span class="line"><span class="keyword">default</span>:</span><br><span class="line">conn.Close()</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> p.qps &gt; <span class="number">0</span> &#123;</span><br><span class="line">atomic.AddInt32(&amp;p.qps, <span class="number">-1</span>)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Removes and calls Close() on all the connections currently in the pool.</span></span><br><span class="line"><span class="comment">// Assuming there are no other connections waiting to be Put back this method</span></span><br><span class="line"><span class="comment">// effectively closes and cleans up the pool.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p *RedisPool)</span> <span class="title">Empty</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">var</span> conn *redis.Client</span><br><span class="line"><span class="keyword">for</span> &#123;</span><br><span class="line"><span class="keyword">select</span> &#123;</span><br><span class="line"><span class="keyword">case</span> conn = &lt;-p.pool:</span><br><span class="line">conn.Close()</span><br><span class="line"><span class="keyword">default</span>:</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> p.qps &gt; <span class="number">0</span> &#123;</span><br><span class="line">atomic.AddInt32(&amp;p.qps, <span class="number">-1</span>)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>完整的代码设计及测试代码请参见: <a href="https://github.com/researchlab/experiments/tree/master/redispool" target="_blank" rel="noopener">https://github.com/researchlab/experiments/tree/master/redispool</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;之前的老项目的redis client sdk 直接大名鼎鼎的&lt;code&gt;github.com/fzzy/radix&lt;/code&gt;提供的&lt;code&gt;redis client&lt;/code&gt; 和&lt;code&gt;redis pool&lt;/code&gt;, 当访问峰值达到一定的值后会出现&lt;code&gt;too many open files&lt;/code&gt;等tcp连接错误，同时也没有直接提供authorization 密钥认证的接口，为满足这些新需求基于&lt;code&gt;fzzy/radix&lt;/code&gt;封装出的新的&lt;code&gt;redispool&lt;/code&gt;, 已投入生产使用半年来暂无问题，本文总结如下,&lt;br&gt;
    
    </summary>
    
      <category term="golang" scheme="http://researchlab.github.io/categories/golang/"/>
    
    
      <category term="golang" scheme="http://researchlab.github.io/tags/golang/"/>
    
      <category term="redispool" scheme="http://researchlab.github.io/tags/redispool/"/>
    
  </entry>
  
  <entry>
    <title>beego/orm使用总结</title>
    <link href="http://researchlab.github.io/2017/03/01/use-beego-orm-summary/"/>
    <id>http://researchlab.github.io/2017/03/01/use-beego-orm-summary/</id>
    <published>2017-03-01T10:44:29.000Z</published>
    <updated>2018-10-16T13:03:07.489Z</updated>
    
    <content type="html"><![CDATA[<p>很早之前的一个老项目就使用过ORM，当时使用的是<code>xorm</code>，后来新的项目设计说考虑性能什么的又用写原生sql来做了，在项目中使用一直没什么问题， 但是代码中到处写着原生的sql语句,并且有很多重复的语句，很不好维护，于是最近又重新考虑采用orm的方式来操作数据库，最近看中<code>beego/orm</code>这个包， 它的官方文档也写了很详细的使用说明，下面还是简要总结一下自己在项目中的使用经历,<br><a id="more"></a></p><h2 id="ORM"><a href="#ORM" class="headerlink" title="ORM"></a>ORM</h2><p>ORM, 即Object-Relational Mapping(对象关系映射)，它的作用是在关系型数据库和业务实体对象之间作一个映射，这样在具体的操作业务对象的时候，就不需要再去和复杂的SQL语句打交道，只需简单的操作对象的属性和方法。</p><p><strong> 优势 </strong> </p><ul><li><p>隐藏了数据访问细节，也是ORM的核心所在, “封闭”的通用数据库交互。使数据库交互变得简单易行，并且完全不用考虑SQL语句。快速开发，由此而来。</p></li><li><p>ORM使构造固化数据结构变得简单易行。在使用ORM之前, 需要将对象模型转化为一条一条的SQL语句，通过直连或是DB helper在关系数据库构造想要的数据库体系。而基本上所有的ORM框架都提供了通过对象模型构造关系数据库结构的功能。</p></li></ul><p>ORM有优势也存在缺点，</p><p><strong> 缺点 </strong></p><ul><li><p>无可避免的，自动化意味着映射和关联管理，代价是牺牲性能(早期，这是所有不喜欢ORM人的共同点)。现各种ORM框架都在尝试使用各种方法来减轻这块(LazyLoad，Cache),效果还是很显著的。</p></li><li><p>面向对象的查询语言(X-QL)作为一种数据库与对象之间的过渡, 虽然隐藏了数据层面的业务抽象, 但并不能完全的屏蔽掉数据库层的设计, 并且无疑将增加学习成本。</p></li><li><p>对于复杂查询，ORM仍然力不从心。虽然可以实现，但是不值的。视图可以解决大部分calculated column，case，group，having, order by, exists，但是查询条件(a and b and not c and (d or d))。</p></li></ul><p>从ORM优缺点来看， ORM适合使用在较大型复杂的系统中或数据库操作很多的系统中， 当即便使用了ORM的复杂项目在特殊情况下也应考虑用原生SQL来解决复杂查询和性能问题，小的项目则看性能苛刻来考虑了，如果性能苛刻则用原生的SQL实现更合适，如果没有什么要求则用不用ORM都没啥关系。</p><h2 id="beego-orm-使用"><a href="#beego-orm-使用" class="headerlink" title="beego/orm 使用"></a>beego/orm 使用</h2><p>据beego/orm官方文档说明目前其还处在开发中只支持<code>MySQL</code>,<code>PostgreSQL</code>, <code>Sqlite3</code>三种数据库驱动，目前beego/orm包支持以下特性,</p><ul><li>支持 Go 的所有类型存储</li><li>轻松上手，采用简单的 CRUD 风格</li><li>自动 Join 关联表</li><li>跨数据库兼容查询</li><li>允许直接使用 SQL 查询／映射</li><li>严格完整的测试保证 ORM 的稳定与健壮</li></ul><p>官方使用案例,<br><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">"fmt"</span></span><br><span class="line"></span><br><span class="line"><span class="string">"github.com/astaxie/beego/orm"</span></span><br><span class="line">_ <span class="string">"github.com/go-sql-driver/mysql"</span> <span class="comment">//import your used driver</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">// Model Struct</span></span><br><span class="line"><span class="keyword">type</span> User <span class="keyword">struct</span> &#123;</span><br><span class="line">Id   <span class="keyword">int</span></span><br><span class="line">Name <span class="keyword">string</span> <span class="string">`orm:"size(100)"`</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">init</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="comment">// set default database</span></span><br><span class="line">orm.RegisterDataBase(<span class="string">"default"</span>, <span class="string">"mysql"</span>, <span class="string">"root:123456@/my_db?charset=utf8"</span>, <span class="number">30</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// register model</span></span><br><span class="line">orm.RegisterModel(<span class="built_in">new</span>(User))</span><br><span class="line"></span><br><span class="line"><span class="comment">// create table</span></span><br><span class="line">orm.RunSyncdb(<span class="string">"default"</span>, <span class="literal">false</span>, <span class="literal">true</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">o := orm.NewOrm()</span><br><span class="line"></span><br><span class="line">user := User&#123;Name: <span class="string">"slene"</span>&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// insert</span></span><br><span class="line">id, err := o.Insert(&amp;user)</span><br><span class="line">fmt.Printf(<span class="string">"ID: %d, ERR: %v\n"</span>, id, err)</span><br><span class="line"></span><br><span class="line"><span class="comment">// update</span></span><br><span class="line">user.Name = <span class="string">"astaxie"</span></span><br><span class="line">num, err := o.Update(&amp;user)</span><br><span class="line">fmt.Printf(<span class="string">"NUM: %d, ERR: %v\n"</span>, num, err)</span><br><span class="line"></span><br><span class="line"><span class="comment">// read one</span></span><br><span class="line">u := User&#123;Id: user.Id&#125;</span><br><span class="line">err = o.Read(&amp;u)</span><br><span class="line">fmt.Printf(<span class="string">"ERR: %v\n"</span>, err)</span><br><span class="line">fmt.Println(<span class="string">"u:"</span>, u)</span><br><span class="line"></span><br><span class="line"><span class="comment">// delete</span></span><br><span class="line">num, err = o.Delete(&amp;u)</span><br><span class="line">fmt.Printf(<span class="string">"NUM: %d, ERR: %v\n"</span>, num, err)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>从上述代码可知，使用ORM大致分以下几步，<br>1.注册数据库;<br>2.注册待使用的数据库表结构对象;<br>3.在数据库中生成上述注册的数据库表结构对象;<br>4.得到一个待操作ORMER对象;<br>5.用上述的得到ORMER对象即可对数据库进行CURD操作了。</p><p>可以看到整个过程几乎不用写SQL语句， 并且逻辑清晰，当然性能方面跟直接用原生的SQL语句写肯定要差一些，因为beego/orm源码里面为了判断数据类型/转换数据类型等用了很多反射/强转等操作，这样做虽然是为了最大限度兼容各类数据操作，但对于本就不涉及复杂繁多的SQL的系统而言， 还是多考虑用原生SQL语句来写了。</p><p>下面是工作中应用抽取出来的一个代码片段，<br><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">"log"</span></span><br><span class="line"><span class="string">"strconv"</span></span><br><span class="line"><span class="string">"sync"</span></span><br><span class="line"><span class="string">"time"</span></span><br><span class="line"></span><br><span class="line"><span class="string">"github.com/astaxie/beego/orm"</span></span><br><span class="line">_ <span class="string">"github.com/go-sql-driver/mysql"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> (</span><br><span class="line">DEBUG = <span class="literal">true</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> db orm.Ormer</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">init</span><span class="params">()</span></span> &#123;</span><br><span class="line">orm.RegisterDriver(<span class="string">"mysql"</span>, orm.DRMySQL)</span><br><span class="line">err := orm.RegisterDataBase(<span class="string">"default"</span>, <span class="string">"mysql"</span>, *dsn)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">log.Fatalf(<span class="string">"connect database error: %v\n"</span>, err)</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">log.Println(<span class="string">"connect db success"</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">orm.RegisterModel(<span class="built_in">new</span>(Record))</span><br><span class="line"></span><br><span class="line">err = orm.RunSyncdb(<span class="string">"default"</span>, <span class="literal">false</span>, <span class="literal">false</span>)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">log.Fatalf(err)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">db = orm.NewOrm()</span><br><span class="line"><span class="keyword">if</span> DEBUG &#123;</span><br><span class="line">orm.Debug = <span class="literal">true</span></span><br><span class="line">&#125;</span><br><span class="line">recordsChan = <span class="built_in">make</span>(<span class="keyword">chan</span> *Record, *insertBatchNum)</span><br><span class="line">recordInsterLoop(done)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">GetDB</span><span class="params">()</span> <span class="title">orm</span>.<span class="title">Ormer</span></span> &#123;</span><br><span class="line"><span class="keyword">return</span> db</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">newRecord</span><span class="params">(param *requestParameter, resp *responseData)</span> *<span class="title">Record</span></span> &#123;</span><br><span class="line">r := <span class="built_in">new</span>(Record)</span><br><span class="line">r.Src = param.values.Get(<span class="string">"src"</span>)</span><br><span class="line">r.OpenID = param.values.Get(<span class="string">"openid"</span>)</span><br><span class="line">r.IdempotentStr = param.values.Get(<span class="string">"idempotent_str"</span>)</span><br><span class="line">r.Noncestr = param.values.Get(<span class="string">"noncestr"</span>)</span><br><span class="line">r.ReqTimestamp, _ = strconv.Atoi(param.values.Get(<span class="string">"timestamp"</span>))</span><br><span class="line">r.ActivityID, _ = strconv.Atoi(param.values.Get(<span class="string">"activity_id"</span>))</span><br><span class="line">r.BatchID, _ = strconv.Atoi(param.values.Get(<span class="string">"batch_id"</span>))</span><br><span class="line">r.Sign = param.values.Get(<span class="string">"sign"</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> resp != <span class="literal">nil</span> &#123;</span><br><span class="line">r.ErrorCode = resp.ErrorCode</span><br><span class="line">r.ErrorMsg = resp.ErrorMsg</span><br><span class="line"><span class="keyword">if</span> resp.Timestamp == <span class="number">0</span> &#123;</span><br><span class="line">r.RespTimestamp = <span class="keyword">int</span>(time.Now().Unix())</span><br><span class="line">&#125;</span><br><span class="line">r.CouponID = resp.CouponID</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> r</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Record <span class="keyword">struct</span> &#123;</span><br><span class="line">ID            <span class="keyword">int</span>    <span class="string">`orm:"column(id)" json:"record_id"`</span></span><br><span class="line">Src           <span class="keyword">string</span> <span class="string">`json:"str"`</span></span><br><span class="line">OpenID        <span class="keyword">string</span> <span class="string">`orm:"column(open_id)" json:"open_id"`</span></span><br><span class="line">IdempotentStr <span class="keyword">string</span> <span class="string">`json:"idempotent_str"`</span></span><br><span class="line">Noncestr      <span class="keyword">string</span> <span class="string">`json:"noncestr"`</span></span><br><span class="line">ReqTimestamp  <span class="keyword">int</span>    <span class="string">`json:"req_timestamp"`</span></span><br><span class="line">ActivityID    <span class="keyword">int</span>    <span class="string">`orm:"column(activity_id)" json:"activity_id"`</span></span><br><span class="line">BatchID       <span class="keyword">int</span>    <span class="string">`orm:"column(batch_id)" json:"batch_id"`</span></span><br><span class="line">Sign          <span class="keyword">string</span> <span class="string">`json:"sign"`</span></span><br><span class="line">ErrorCode     <span class="keyword">int</span>    <span class="string">`json:"error_code"`</span></span><br><span class="line">ErrorMsg      <span class="keyword">string</span> <span class="string">`json:"error_msg"`</span></span><br><span class="line">RespTimestamp <span class="keyword">int</span>    <span class="string">`json:"resp_timestamp"`</span></span><br><span class="line">CouponID      <span class="keyword">int</span>    <span class="string">`orm:"column(coupon_id)" json:"coupon_id"`</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(Record)</span> <span class="title">TableName</span><span class="params">()</span> <span class="title">string</span></span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="string">"records"</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> recordsChan <span class="keyword">chan</span> *Record</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(r *Record)</span> <span class="title">InsertRecord</span><span class="params">()</span></span> &#123;</span><br><span class="line">recordsChan &lt;- r</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">recordInsterLoop</span><span class="params">(done &lt;-<span class="keyword">chan</span> <span class="keyword">bool</span>)</span></span> &#123;</span><br><span class="line"><span class="keyword">var</span> mu sync.Mutex</span><br><span class="line"><span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">records := <span class="built_in">make</span>([]*Record, <span class="number">0</span>, *insertBatchNum)</span><br><span class="line"><span class="keyword">for</span> &#123;</span><br><span class="line"><span class="keyword">select</span> &#123;</span><br><span class="line"><span class="keyword">case</span> &lt;-done:</span><br><span class="line">recordCopy, recordLen := Copyrecode(records)</span><br><span class="line">insertMulti(recordLen, recordCopy)</span><br><span class="line"></span><br><span class="line"><span class="keyword">case</span> &lt;-time.After(time.Duration(<span class="number">5</span>) * time.Second):</span><br><span class="line"></span><br><span class="line">recordCopy, recordLen := Copyrecode(records)</span><br><span class="line">insertMulti(recordLen, recordCopy)</span><br><span class="line"></span><br><span class="line"><span class="keyword">case</span> r := &lt;-recordsChan:</span><br><span class="line">records = <span class="built_in">append</span>(records, r)</span><br><span class="line">recordLen := <span class="built_in">len</span>(records)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> recordLen &gt;= *insertBatchNum &#123;</span><br><span class="line">recordCopy, recordLen := Copyrecode(records)</span><br><span class="line">insertMulti(recordLen, recordCopy)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">close</span>(recordsChan)</span><br><span class="line">&#125;()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Copyrecode</span><span class="params">(records []*Record)</span> <span class="params">(recordCopy []*Record, recordLen <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">mu.Lock()</span><br><span class="line">recordLen = <span class="built_in">len</span>(records)</span><br><span class="line">recordCopy = <span class="built_in">make</span>([]*Record, recordLen)</span><br><span class="line"><span class="built_in">copy</span>(recordCopy, records)</span><br><span class="line">records = <span class="built_in">make</span>([]*Record, <span class="number">0</span>, *insertBatchNum)</span><br><span class="line">mu.Unlock()</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">insertMulti</span><span class="params">(n <span class="keyword">int</span>, rs []*Record)</span> <span class="params">(<span class="keyword">int64</span>, error)</span></span> &#123;</span><br><span class="line"><span class="keyword">return</span> GetDB().InsertMulti(n, rs)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>上述代码就是用ORM将数据插入到指定数据库表中，实现过程考虑到了数据插入超时及强制退出时将records中预留的数据插入数据库一定程度上保证数据不丢失。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;很早之前的一个老项目就使用过ORM，当时使用的是&lt;code&gt;xorm&lt;/code&gt;，后来新的项目设计说考虑性能什么的又用写原生sql来做了，在项目中使用一直没什么问题， 但是代码中到处写着原生的sql语句,并且有很多重复的语句，很不好维护，于是最近又重新考虑采用orm的方式来操作数据库，最近看中&lt;code&gt;beego/orm&lt;/code&gt;这个包， 它的官方文档也写了很详细的使用说明，下面还是简要总结一下自己在项目中的使用经历,&lt;br&gt;
    
    </summary>
    
      <category term="golang" scheme="http://researchlab.github.io/categories/golang/"/>
    
    
      <category term="golang" scheme="http://researchlab.github.io/tags/golang/"/>
    
      <category term="beego/orm" scheme="http://researchlab.github.io/tags/beego-orm/"/>
    
  </entry>
  
  <entry>
    <title>mysql 数据库表及数据导入导出方法总结</title>
    <link href="http://researchlab.github.io/2017/02/22/mysql-import-export-summary/"/>
    <id>http://researchlab.github.io/2017/02/22/mysql-import-export-summary/</id>
    <published>2017-02-22T10:50:36.000Z</published>
    <updated>2018-10-16T13:03:07.485Z</updated>
    
    <content type="html"><![CDATA[<p>由于公司的MySQL是搭建在服务器上，为了避免对服务器进行直接改动，想远程导出和导入MySQL的数据库表结构及数据进行操作, 刚好Mysql本身提供了命令行导出工具<code>Mysqldump</code>和<code>Mysql Source</code>导入命令进行SQL数据导入导出工作，通过Mysql命令行导出工具Mysqldump命令能够将Mysql数据导出为文本格式(txt)的SQL文件，通过Mysql Source命令能够将SQL文件导入Mysql数据库中，下面通过Mysql导入导出SQL实例详解Mysqldump和Source命令的用法</p><a id="more"></a><h2 id="数据库表及数据导出"><a href="#数据库表及数据导出" class="headerlink" title="数据库表及数据导出"></a>数据库表及数据导出</h2><p>需求说明是要希望导出整个数据库结构脚本，而MySQL提供的Mysqldump命令刚好可达到此目的而且还可以将数据库中的数据也一并导出，</p><p><strong> mysqldump导出语法以及实践 </strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mysqldump -h&#123;hostname&#125; [-P&#123;port&#125;] -u&#123;username&#125; -p&#123;password&#125; [--default-character-set=charset] database [tablename] &gt; &#123;you file path&#125;</span><br><span class="line"><span class="comment"># 注:-h和[hostname]之间并没有空格相连, 后同之, []扩起来的为可选项, 可不填</span></span><br></pre></td></tr></table></figure><ul><li>hostname表示主机名, 本地则填localhost, 远程则填写你的远程IP, 如192.168.0.3;</li><li>username是你的MySQL登录帐号, password则是登录密码;</li><li>default-character-set则是你的字符集编码, 如gb2312、gbk和utf8(没有横杠哦);</li><li>dbname是你的数据库名称, tablename是你的表名, 假如你不填写tablename的话则默认导出所有的表。</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysqldump -h192.168.0.3 -P3307 -uroot -p123456 --default-character-set=utf8  crm_adapter &gt; ./crm_adapter_db.sql</span><br></pre></td></tr></table></figure><p>通过上面的导出语句, 将会在当前目录下面创建一个crm_adapter_db.sql脚本文件, 这个脚本文件是可运行的, 它包含了crm_adapter数据库中所有数据表的建表细节以及其所有的数据。这就是导出命令的特点，它不但会导出数据，还会导出表或者数据库的结构信息。另外如果不带”&gt; {you file path}”这一部分路径信息，mysqldump导出命令或把内容打印在terminal命令界面上。</p><h2 id="数据库表及数据导入"><a href="#数据库表及数据导入" class="headerlink" title="数据库表及数据导入"></a>数据库表及数据导入</h2><p>数据库表及数据导入可用mysqldump 和source 两种方法来操作， </p><p><strong> 通过mysqldump 工具导入</strong><br>mysqldump -h{hostname} [-P{port}] -u{username} -p{password} [–default-character-set=charset] database [tablename] &lt; {you file path}</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysqldump -h192.168.0.3 -P3308 -uroot -p123456  databasename &lt; ./crm_adapter_db.sql</span><br></pre></td></tr></table></figure><p><strong> 通过source 命令导入 </strong></p><p><code>source</code>命令导入不同于mysqldump, 它是一个SQL命令, 必须登录进入MySQL在命令行那里才可以运行, 而mysqldump实则是一个管理工具，无须登入MySQ在命令行那里运行，只须在命令行下运行即可。先登入MySQL:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql -h&#123;hostname&#125; [-p&#123;port&#125;] -u&#123;username&#125; -p&#123;password&#125;</span><br></pre></td></tr></table></figure><p>举例, 我们登入一个远程MySQL可以用下面的命令,</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql -h192.168.0.3 -unikey -p123456</span><br></pre></td></tr></table></figure><p>登入之后，进入我们要作用的数据库,</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql &gt; use my_crm_adapter;</span><br></pre></td></tr></table></figure><p>然后我们可以使用source命令来运行前面导出的sql脚本实现数据的导入,</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql &gt; <span class="built_in">source</span> ./crm_adapter_db.sql;</span><br></pre></td></tr></table></figure><p><strong> mysqldump vs source </strong><br>mysqldump虽然好用, 但它实际上也是运用先登录在运行脚本的策略, 只是其中的细节我们无需关心, 但是, 因为其中有很多远程连接细节, 我们有可能遭遇中文乱码问题。</p><center><img src="imgs/mysqldump_error.png" alt="mysqldump 乱码"></center><p>关于为何在使用mysqldump做导入时会出现中文乱码问题, 我们先用mysql命令登入, 然后输入下面的命令:<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql &gt; show variables like <span class="string">'character%'</span>;</span><br></pre></td></tr></table></figure></p><center><img src="imgs/mysqldump_ret.png" alt="mysqldump character error"></center><p>是否注意到红圈部分的编码是latin1? latin1是MySQL的默认字符集, 可能由于某种原因你没有指定默认编码, 它就会默认为latin1了, 这就是你中文乱码出现的原因。</p><p><strong> <font color="red"> 所以建议优先使用source 命令来导入数据 </font> </strong> </p><h2 id="mysqldump使用总结"><a href="#mysqldump使用总结" class="headerlink" title="mysqldump使用总结"></a>mysqldump使用总结</h2><ul><li><p>导出所有库<br>  系统命令行</p>  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysqldump -uusername -ppassword --all-databases &gt; all.sql</span><br></pre></td></tr></table></figure></li><li><p>导入所有库<br>  mysql命令行</p>  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt;<span class="built_in">source</span> all.sql;</span><br></pre></td></tr></table></figure></li><li><p>导出某些库<br>  系统命令行</p>  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysqldump -uusername -ppassword --databases db1 db2 &gt; db1db2.sql</span><br></pre></td></tr></table></figure></li><li><p>导入某些库<br>  mysql命令行</p>  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt;<span class="built_in">source</span> db1db2.sql;</span><br></pre></td></tr></table></figure></li><li><p>导入某个库<br>  系统命令行</p>  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql -uusername -ppassword db1 &lt; db1.sql;</span><br></pre></td></tr></table></figure><p>  或mysql命令行</p>  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt;<span class="built_in">source</span> db1.sql;</span><br></pre></td></tr></table></figure></li><li><p>导出某些数据表<br>  系统命令行</p>  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysqldump -uusername -ppassword db1 table1 table2 &gt; tb1tb2.sql</span><br></pre></td></tr></table></figure></li><li><p>导入某些数据表<br>  系统命令行</p>  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql -uusername -ppassword db1 &lt; tb1tb2.sql</span><br></pre></td></tr></table></figure><p>  或mysql命令行</p>  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt;user db1;</span><br><span class="line">mysql&gt;<span class="built_in">source</span> tb1tb2.sql;</span><br></pre></td></tr></table></figure></li><li><p>mysqldump字符集设置<br>  mysqldump -uusername -ppassword –default-character-set=gb2312 db1 table1 &gt; tb1.sql<br>  mysqldump客户端可用来转储数据库或搜集数据库进行备份或将数据转移到另一个sql服务器(不一定是一个mysql服务器)。转储包含创建表和/或装载表的sql语句。<br>  如果在服务器上进行备份，并且表均为myisam表，应考虑使用mysqlhotcopy，因为可以更快地进行备份和恢复。<br>  有3种方式来调用mysqldump:<br>  系统命令行</p>  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">mysqldump [options] db_name [tables]</span><br><span class="line"><span class="comment"># 或</span></span><br><span class="line">mysqldump [options] ---database db1 [db2 db3...]</span><br><span class="line"><span class="comment"># 或</span></span><br><span class="line">mysqldump [options] --all--database</span><br></pre></td></tr></table></figure><p>  如果没有指定任何表或使用了—database或–all–database选项，则转储整个数据库。<br>  要想获得你的版本的mysqldump支持的选项，执行mysqldump —help。<br>  如果运行mysqldump没有–quick或–opt选项，mysqldump在转储结果前将整个结果集装入内存。如果转储大数据库可能会出现问题。该选项默认启用，但可以用–skip-opt禁用。<br>  如果使用最新版本的mysqldump程序生成一个转储重装到很旧版本的mysql服务器中，不应使用–opt或-e选项。<br>  mysqldump支持下面的选项:<br>   <code>--help</code> 或<code>-?</code><br>   显示帮助消息并退出。<br>   <code>--add-drop--database</code><br>   在每个create database语句前添加drop database语句。<br>   <code>--add-drop-tables</code><br>   在每个create table语句前添加drop table语句。<br>   <code>--add-locking</code><br>   用lock tables和unlock tables语句引用每个表转储。重载转储文件时插入得更快。<br>   <code>--all--database</code> 或 <code>-a</code><br>  转储所有数据库中的所有表。与使用—database选项相同，在命令行中命名所有数据库。<br>   <code>--allow-keywords</code><br>   允许创建关键字列名。应在每个列名前面加上表名前缀。<br>   <code>--comments[={0|1}]</code><br>   如果设置为0, 禁止转储文件中的其它信息, 例如程序版本, 服务器版本和主机。<code>--skip—comments</code>与<code>--comments=0</code>的结果相同。 默认值为1，即包括额外信息。<br>   <code>--compact</code><br>   产生少量输出。该选项禁用注释并启用<code>--skip-add-drop-tables</code>、<code>--no-set-names</code>、<code>--skip-disable-keys</code>和<code>--skip-add-locking</code>选项。<br>   <code>--compatible=name</code><br>   产生与其它数据库系统或旧的mysql服务器更兼容的输出。值可以为ansi、mysql323、mysql40、postgresql、oracle、mssql、db2、maxdb、no_key_options、no_tables_options或者no_field_options。要使用几个值，用逗号将它们隔开。这些值与设置服务器sql模式的相应选项有相同的含义。该选项不能保证同其它服务器之间的兼容性。它只启用那些目前能够使转储输出更兼容的sql模式值。例如，–compatible=oracle 不映射oracle类型或使用oracle注释语法的数据类型。<br>   <code>--complete-insert</code> 或 <code>-c</code><br>   使用包括列名的完整的insert语句。<br>   <code>--compress</code> 或<code>-c</code><br>   压缩在客户端和服务器之间发送的所有信息（如果二者均支持压缩）。<br>   <code>--create-option</code><br>   在create table语句中包括所有mysql表选项。<br>  <code>--database</code> 或 <code>-b</code><br>  转储几个数据库。通常情况, mysqldump将命令行中的第1个名字参量看作数据库名，后面的名看作表名。使用该选项，它将所有名字参量看作数据库名。create database if not exists db_name和use db_name语句包含在每个新数据库前的输出中。<br>   <code>--debug[=debug_options]</code> 或<code>-# [debug_options]</code><br>   写调试日志。debug_options字符串通常为’d:t:o,file_name’。<br>   <code>--default-character-set=charset</code><br>   使用charsetas默认字符集。如果没有指定，mysqldump使用utf8。<br>   <code>--delayed-insert</code><br>   使用insert delayed语句插入行。<br>   <code>--delete-master-logs</code><br>   在主复制服务器上，完成转储操作后删除二进制日志。该选项自动启用<code>--master-data</code>。<br>   <code>--disable-keys</code> 或 <code>-k</code><br>   对于每个表，用/<em>!40000 alter table tbl_name disable keys </em>/;和/<em>!40000 alter table tbl_name enable keys </em>/;语句引用insert语句。这样可以更快地装载转储文件，因为在插入所有行后创建索引。该选项只适合myisam表。<br>   <code>--extended-insert</code> 或 <code>-e</code><br>   使用包括几个values列表的多行insert语法。这样使转储文件更小，重载文件时可以加速插入。<br>   <code>--fields-terminated-by=...，--fields-enclosed-by=...，--fields-optionally-enclosed-by=...，--fields-escaped-by=...，--行-terminated-by=...</code><br>   这些选项结合-t选项使用，与load data infile的相应子句有相同的含义。<br>   <code>--first-slave</code> 或 <code>-x</code><br>   不赞成使用，现在重新命名为–lock-all-tables。<br>   <code>--flush-logs</code> 或 <code>-f</code><br>   开始转储前刷新mysql服务器日志文件。该选项要求reload权限。请注意如果结合<code>--all--database</code>(或-a)选项使用该选项，根据每个转储的数据库刷新日志。例外情况是当使用<code>--lock-all-tables</code>或<code>--master-data</code>的时候:在这种情况下, 日志只刷新一次, 在所有表被锁定后刷新。如果你想要同时转储和刷新日志，应使用<code>--flush-logs</code>连同<code>--lock-all-tables</code>或<code>--master-data</code>。<br>   <code>--force</code>或<code>-f</code><br>   在表转储过程中, 即使出现sql错误也继续。<br>   <code>--host=host_name</code> 或 <code>-h host_name</code><br>   从给定主机的mysql服务器转储数据。默认主机是localhost。<br>   <code>--hex-blob</code><br>   使用十六进制符号转储二进制字符串列(例如，’abc’ 变为0x616263)。影响到的列有binary、varbinary、blob。<br>   <code>--lock-all-tables</code> 或 <code>-x</code><br>   所有数据库中的所有表加锁。在整体转储过程中通过全局读锁定来实现。该选项自动关闭<code>--single-transaction</code>和<code>--lock-tables</code>。<br>   <code>--lock-tables</code> 或<code>-l</code><br>   开始转储前锁定所有表。用read local锁定表以允许并行插入myisam表。对于事务表例如innodb和bdb，<code>--single-transaction</code>是一个更好的选项，因为它不根本需要锁定表。请注意当转储多个数据库时，–lock-tables分别为每个数据库锁定表。因此，该选项不能保证转储文件中的表在数据库之间的逻辑一致性。不同数据库表的转储状态可以完全不同。<br>   <code>--master-data[=value]</code><br>   该选项将二进制日志的位置和文件名写入到输出中。该选项要求有reload权限，并且必须启用二进制日志。如果该选项值等于1，位置和文件名被写入change master语句形式的转储输出，如果你使用该sql转储主服务器以设置从服务器，从服务器从主服务器二进制日志的正确位置开始。如果选项值等于2，change master语句被写成sql注释。如果value被省略，这是默认动作。<br>   <code>--master-data</code>选项启用<code>--lock-all-tables</code>，除非还指定<code>--single-transaction</code>(在这种情况下，只在刚开始转储时短时间获得全局读锁定。又见<code>--single-transaction</code>。在任何一种情况下，日志相关动作发生在转储时。该选项自动关闭<code>--lock-tables</code>。<br>   <code>--no-create-db</code> 或 <code>-n</code><br>   该选项禁用create database /<em>!32312 if not exists</em>/ db_name语句，如果给出—database或–all–database选项，则包含到输出中。<br>   <code>--no-create-info</code> 或 <code>-t</code><br>   不写重新创建每个转储表的create table语句。<br>   <code>--no-data</code> 或 <code>-d</code><br>   不写表的任何行信息。如果你只想转储表的结构这很有用。<br>   <code>--opt</code><br>   该选项是速记；等同于指定 –add-drop-tables–add-locking –create-option –disable-keys–extended-insert –lock-tables –quick –set-charset。它可以给出很快的转储操作并产生一个可以很快装入mysql服务器的转储文件。该选项默认开启，但可以用–skip-opt禁用。要想只禁用确信用-opt启用的选项，使用–skip形式；例如，–skip-add-drop-tables或–skip-quick。<br>   –password[=password]，-p[password]<br>   连接服务器时使用的密码。如果你使用短选项形式(-p)，不能在选项和密码之间有一个空格。如果在命令行中，忽略了–password或-p选项后面的 密码值，将提示你输入一个。<br>   –port=port_num，-p port_num<br>   用于连接的tcp/ip端口号。<br>   –protocol={tcp | socket | pipe | memory}<br>   使用的连接协议。<br>   –quick，-q<br>   该选项用于转储大的表。它强制mysqldump从服务器一次一行地检索表中的行而不是检索所有行并在输出前将它缓存到内存中。<br>   –quote-names，-q<br>   用”`“字符引用数据库、表和列名。如果服务器sql模式包括ansi_quotes选项，用”字符引用名。默认启用该选项。可以用–skip-quote-names禁用，但该选项应跟在其它选项后面，例如可以启用–quote-names的–compatible。<br>   –result-file=file，-r file<br>  –socket=path，-s path<br>   当连接localhost(为默认主机)时使用的套接字文件。<br>   –skip–comments<br>  参见—comments选项的描述。<br>  –tab=path，-t path<br>  产生tab分割的数据文件。对于每个转储的表，mysqldump创建一个包含创建表的create table语句的tbl_name.sql文件，和一个包含其数据的tbl_name.txt文件。选项值为写入文件的目录。<br>  默认情况，.txt数据文件的格式是在列值和每行后面的新行之间使用tab字符。可以使用–fields-xxx和–行–xxx选项明显指定格式。<br>  注释：该选项只适用于mysqldump与mysqld服务器在同一台机器上运行时。你必须具有file权限，并且服务器必须有在你指定的目录中有写文件的许可。<br>  –tables<br>  覆盖—database或-b选项。选项后面的所有参量被看作表名。<br>  –triggers<br>  为每个转储的表转储触发器。该选项默认启用；用–skip-triggers禁用它。<br>  –tz-utc<br>  在转储文件中加入set time_zone=’+00:00’以便timestamp列可以在具有不同时区的服务器之间转储和重载。(不使用该选项，timestamp列在具有本地时区的源服务器和目的服务器之间转储和重载）。–tz-utc也可以保护由于夏令时带来的更改。–tz-utc默认启用。要想禁用它，使用–skip-tz-utc。该选项在mysql 5.1.2中加入。<br>   –where=’where-condition’, -w ‘where-condition’<br>   只转储给定的where条件选择的记录。请注意如果条件包含命令解释符专用空格或字符，一定要将条件引用起来。<br>   例如:<br>   <code>&quot;--where=user=&#39;jimf&#39;&quot;   &quot;-wuserid&gt;1&quot;   &quot;-wuserid&lt;1&quot;</code><br>   –xml，-x<br>   将转储输出写成xml。<br>   还可以使用–var_name=value选项设置下面的变量:<br>   max_allowed_packet<br>   客户端/服务器之间通信的缓存区的最大大小。最大为1gb。<br>   net_buffer_length<br>   客户端/服务器之间通信的缓存区的初始大小。当创建多行插入语句时(如同使用选项–extended-insert或–opt)，mysqldump创建长度达net_buffer_length的行。如果增加该变量，还应确保在mysql服务器中的net_buffer_length变量至少这么大。<br>   还可以使用–set-variable=var_name=value或-o var_name=value语法设置变量。然而，现在不赞成使用该语法。<br>   mysqldump最常用于备份一个整个的数据库:<br>  mysqldump –opt db_name &gt; backup-file.sql<br>  可以这样将转储文件读回到服务器:<br>  mysql db_name &lt; backup-file.sql<br>   或:<br>  mysql -e “source /path-to–backup/backup-file.sql” db_name<br>   mysqldump也可用于从一个mysql服务器向另一个服务器复制数据时装载数据库:<br>  mysqldump –opt db_name | mysql –host=remote_host -c db_name<br>  可以用一个命令转储几个数据库:<br>  mysqldump —database db_name1 [db_name2 …] &gt; my_databases.sql<br>  如果想要转储所有数据库，使用–all–database选项:<br>  mysqldump –all-databases &gt; all_databases.sql<br>  如果表保存在innodb存储引擎中，mysqldump提供了一种联机备份的途径(参见下面的命令)。该备份只需要在开始转储时对所有表进行全局读锁定(使用flush tables with read lock)。获得锁定后，读取二进制日志的相应内容并将锁释放。因此如果并且只有当发出flush…时正执行一个长的更新语句，mysql服务器才停止直到长语句结束，然后转储则释放锁。因此如果mysql服务器只接收到短(“短执行时间”)的更新语句，即使有大量的语句，也不会注意到锁期间。<br>  mysqldump –all-databases –single-transaction &gt; all_databases.sql<br>  对于点对点恢复(也称为“前滚”，当你需要恢复旧的备份并重放该备份以后的更改时)，循环二进制日志或至少知道转储对应的二进制日志内容很有用：<br>  mysqldump –all-databases –master-data=2 &gt; all_databases.sql<br>  或<br>  mysqldump –all-databases –flush-logs –master-data=2 &gt; all_databases.sql<br>  如果表保存在innodb存储引擎中，同时使用–master-data和–single-transaction提供了一个很方便的方式来进行适合点对点恢复的联机备份。</p></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;由于公司的MySQL是搭建在服务器上，为了避免对服务器进行直接改动，想远程导出和导入MySQL的数据库表结构及数据进行操作, 刚好Mysql本身提供了命令行导出工具&lt;code&gt;Mysqldump&lt;/code&gt;和&lt;code&gt;Mysql Source&lt;/code&gt;导入命令进行SQL数据导入导出工作，通过Mysql命令行导出工具Mysqldump命令能够将Mysql数据导出为文本格式(txt)的SQL文件，通过Mysql Source命令能够将SQL文件导入Mysql数据库中，下面通过Mysql导入导出SQL实例详解Mysqldump和Source命令的用法&lt;/p&gt;
    
    </summary>
    
      <category term="DevOps" scheme="http://researchlab.github.io/categories/DevOps/"/>
    
    
      <category term="mysql" scheme="http://researchlab.github.io/tags/mysql/"/>
    
  </entry>
  
  <entry>
    <title>Linux Signal及Golang中的信号处理</title>
    <link href="http://researchlab.github.io/2017/01/22/linux-signal-golang/"/>
    <id>http://researchlab.github.io/2017/01/22/linux-signal-golang/</id>
    <published>2017-01-22T14:35:45.000Z</published>
    <updated>2018-10-16T13:03:07.485Z</updated>
    
    <content type="html"><![CDATA[<p>信号(Signal)是Linux, 类Unix和其它POSIX兼容的操作系统中用来进程间通讯的一种方式。一个信号就是一个异步的通知，发送给某个进程，或者同进程的某个线程，告诉它们某个事件发生了。<br>当信号发送到某个进程中时，操作系统会中断该进程的正常流程，并进入相应的信号处理函数执行操作，完成后再回到中断的地方继续执行。<br>如果目标进程先前注册了某个信号的处理程序(signal handler),则此处理程序会被调用，否则缺省的处理程序被调用。</p><a id="more"></a><h2 id="发送信号"><a href="#发送信号" class="headerlink" title="发送信号"></a>发送信号</h2><ul><li><code>kill</code> 系统调用(system call)可以用来发送一个特定的信号给进程。</li><li><code>kill</code> 命令允许用户发送一个特定的信号给进程。</li><li><code>raise</code> 库函数可以发送特定的信号给当前进程。</li></ul><p>在Linux下运行man kill可以查看此命令的介绍和用法。</p><blockquote><p>The command kill sends the specified signal to the specified process or process group. If no signal is specified, the TERM signal is sent. The TERM signal will kill processes which do not catch this signal. For other processes, it may be necessary to use the KILL (9) signal, since this signal cannot be caught.<br>Most modern shells have a builtin kill function, with a usage rather similar to that of the command described here. The ‘-a’ and ‘-p’ options, and the possibility to specify pids by command name is a local extension.<br>If sig is 0, then no signal is sent, but error checking is still performed.</p></blockquote><p>一些异常比如除以0或者<code>segmentation violation</code>相应的会产生<code>SIGFPE</code>和<code>SIGSEGV</code>信号，缺省情况下导致<code>core dump</code>和程序退出。<br>内核在某些情况下发送信号，比如在进程往一个已经关闭的管道写数据时会产生<code>SIGPIPE</code>信号.<br>在进程的终端敲入特定的组合键也会导致系统发送某个特定的信号给此进程：</p><ul><li><code>Ctrl-C</code> 发送 INT signal (SIGINT)，通常导致进程结束</li><li><code>Ctrl-Z</code> 发送 TSTP signal (SIGTSTP); 通常导致进程挂起(suspend)</li><li><code>Ctrl-\</code> 发送 QUIT signal (SIGQUIT); 通常导致进程结束 和 dump core.</li><li><code>Ctrl-T</code> (不是所有的UNIX都支持) 发送INFO signal (SIGINFO); 导致操作系统显示此运行命令的信息</li><li><code>kill -9 pid</code> 会发送 SIGKILL信号给进程。</li></ul><h2 id="处理信号"><a href="#处理信号" class="headerlink" title="处理信号"></a>处理信号</h2><p>Signal handler可以通过signal()系统调用进行设置。如果没有设置，缺省的handler会被调用，当然进程也可以设置忽略此信号。<br>有两种信号不能被拦截和处理: <code>SIGKILL</code>和<code>SIGSTOP</code>。</p><p>当接收到信号时，进程会根据信号的响应动作执行相应的操作，信号的响应动作有以下几种：</p><p>1.中止进程(Term)<br>2.忽略信号(Ign)<br>3.中止进程并保存内存信息(Core)<br>4.停止进程(Stop)<br>5.继续运行进程(Cont)<br>6.用户可以通过signal或sigaction函数修改信号的响应动作（也就是常说的”注册信号”）。另外，在多线程中，各线程的信号响应动作都是相同的，不能对某个线程设置独立的响应动作。</p><h2 id="信号类型"><a href="#信号类型" class="headerlink" title="信号类型"></a>信号类型</h2><p>不同平台的信号定义或许有些不同。下面列出了POSIX中定义的信号。<br>Linux 使用34-64信号用作实时系统中。<br>命令man 7 signal提供了官方的信号介绍。</p><p>在POSIX.1-1990标准中定义的信号列表</p><table><thead><tr><th>信号</th><th>值</th><th>动作</th><th>说明</th></tr></thead><tbody><tr><td>SIGHUP</td><td>1</td><td>Term</td><td>终端控制进程结束(终端连接断开)</td></tr><tr><td>SIGINT</td><td>2</td><td>Term</td><td>用户发送INTR字符(Ctrl+C)触发</td></tr><tr><td>SIGQUIT</td><td>3</td><td>Core</td><td>用户发送QUIT字符(Ctrl+/)触发</td></tr><tr><td>SIGILL</td><td>4</td><td>Core</td><td>非法指令(程序错误、试图执行数据段、栈溢出等)</td></tr><tr><td>SIGABRT</td><td>6</td><td>Core</td><td>调用abort函数触发</td></tr><tr><td>SIGFPE</td><td>8</td><td>Core</td><td>算术运行错误(浮点运算错误、除数为零等)</td></tr><tr><td>SIGKILL</td><td>9</td><td>Term</td><td>无条件结束程序(不能被捕获、阻塞或忽略)</td></tr><tr><td>SIGSEGV</td><td>11</td><td>Core</td><td>无效内存引用(试图访问不属于自己的内存空间、对只读内存空间进行写操作)</td></tr><tr><td>SIGPIPE</td><td>13</td><td>Term</td><td>消息管道损坏(FIFO/Socket通信时，管道未打开而进行写操作)</td></tr><tr><td>SIGALRM</td><td>14</td><td>Term</td><td>时钟定时信号</td></tr><tr><td>SIGTERM</td><td>15</td><td>Term</td><td>结束程序(可以被捕获、阻塞或忽略)</td></tr><tr><td>SIGUSR1</td><td>30,10,16</td><td>Term</td><td>用户保留</td></tr><tr><td>SIGUSR2</td><td>31,12,17</td><td>Term</td><td>用户保留</td></tr><tr><td>SIGCHLD</td><td>20,17,18</td><td>Ign</td><td>子进程结束(由父进程接收)</td></tr><tr><td>SIGCONT</td><td>19,18,25</td><td>Cont</td><td>继续执行已经停止的进程(不能被阻塞)</td></tr><tr><td>SIGSTOP</td><td>17,19,23</td><td>Stop</td><td>停止进程(不能被捕获、阻塞或忽略)</td></tr><tr><td>SIGTSTP</td><td>18,20,24</td><td>Stop</td><td>停止进程(可以被捕获、阻塞或忽略)</td></tr><tr><td>SIGTTIN</td><td>21,21,26</td><td>Stop</td><td>后台程序从终端中读取数据时触发</td></tr><tr><td>SIGTTOU</td><td>22,22,27</td><td>Stop</td><td>后台程序向终端中写数据时触发</td></tr></tbody></table><p>在SUSv2和POSIX.1-2001标准中的信号列表:</p><table><thead><tr><th>信号</th><th>值</th><th>动作</th><th>说明</th></tr></thead><tbody><tr><td>SIGTRAP</td><td>5</td><td>Core</td><td>Trap指令触发(如断点，在调试器中使用)</td></tr><tr><td>SIGBUS</td><td>0,7,10</td><td>Core</td><td>非法地址(内存地址对齐错误)</td></tr><tr><td>SIGPOLL</td><td></td><td>Term</td><td>Pollable event (Sys V). Synonym for SIGIO</td></tr><tr><td>SIGPROF</td><td>27,27,29</td><td>Term</td><td>性能时钟信号(包含系统调用时间和进程占用CPU的时间)</td></tr><tr><td>SIGSYS</td><td>12,31,12</td><td>Core</td><td>无效的系统调用(SVr4)</td></tr><tr><td>SIGURG</td><td>16,23,21</td><td>Ign</td><td>有紧急数据到达Socket(4.2BSD)</td></tr><tr><td>SIGVTALRM</td><td>26,26,28</td><td>Term</td><td>虚拟时钟信号(进程占用CPU的时间)(4.2BSD)</td></tr><tr><td>SIGXCPU</td><td>24,24,30</td><td>Core</td><td>超过CPU时间资源限制(4.2BSD)</td></tr><tr><td>SIGXFSZ</td><td>25,25,31</td><td>Core</td><td>超过文件大小资源限制(4.2BSD)</td></tr></tbody></table><p>Windows中没有SIGUSR1,可以用SIGBREAK或者SIGINT代替。</p><h2 id="Go中的Signal发送和处理"><a href="#Go中的Signal发送和处理" class="headerlink" title="Go中的Signal发送和处理"></a>Go中的Signal发送和处理</h2><p>有时候我们想在Go程序中处理<code>Signal</code>信号，比如收到<code>SIGTERM</code>信号后优雅的关闭程序(参看下一节的应用)。<br>Go信号通知机制可以通过往一个<code>channel</code>中发送<code>os.Signal</code>实现。<br>首先我们创建一个<code>os.Signal channel</code>，然后使用<code>signal.Notify</code>注册要接收的信号。</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"><span class="keyword">import</span> <span class="string">"os"</span></span><br><span class="line"><span class="keyword">import</span> <span class="string">"os/signal"</span></span><br><span class="line"><span class="keyword">import</span> <span class="string">"syscall"</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    sigs := <span class="built_in">make</span>(<span class="keyword">chan</span> os.Signal, <span class="number">1</span>)</span><br><span class="line">    done := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">bool</span>, <span class="number">1</span>)</span><br><span class="line">    signal.Notify(sigs, syscall.SIGINT, syscall.SIGTERM)</span><br><span class="line">    <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">        sig := &lt;-sigs</span><br><span class="line">        fmt.Println(sig)</span><br><span class="line">        done &lt;- <span class="literal">true</span></span><br><span class="line">    &#125;()</span><br><span class="line">    fmt.Println(<span class="string">"awaiting signal"</span>)</span><br><span class="line">    &lt;-done</span><br><span class="line">    fmt.Println(<span class="string">"exiting"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>go run main.go执行这个程序，敲入<code>ctrl-C</code>会发送<code>SIGINT</code>信号。 此程序接收到这个信号后会打印退出。</p><p>在工作中，遇到这样一个场景:需要往阿里日志服务写数据，但要等到满了200条数据才会触发写入阿里日志服务操作， 辣就会遇到一个问题，当程序被人为中断退出时，但是又没有达到200数据，如果不做其它处理，则这些数据就会丢失了， 为防止存在上述情况的丢失，可以使用Signal来做，<br><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">ch := <span class="built_in">make</span>(<span class="keyword">chan</span> os.Signal, <span class="number">1</span>)</span><br><span class="line">signal.Notify(ch, syscall.SIGINT, syscall.SIGQUIT, syscall.SIGABRT, syscall.SIGTERM, syscall.SIGPIPE)</span><br><span class="line"><span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">for</span> sig := <span class="keyword">range</span> ch &#123;</span><br><span class="line"><span class="keyword">switch</span> sig &#123;</span><br><span class="line"><span class="keyword">case</span> syscall.SIGPIPE:</span><br><span class="line"><span class="keyword">default</span>:</span><br><span class="line">this.Terminate()</span><br><span class="line">&#125;</span><br><span class="line">glog.Info(<span class="string">"[服务] 收到信号 "</span>, sig)</span><br><span class="line">&#125;</span><br><span class="line">&#125;()</span><br></pre></td></tr></table></figure></p><blockquote><p>上述代码的好处时当收到Signal信号之后，就可以选择调用this.Terminate()方法来作出相应的处理</p></blockquote><h2 id="Go网络服务器如果无缝重启"><a href="#Go网络服务器如果无缝重启" class="headerlink" title="Go网络服务器如果无缝重启"></a>Go网络服务器如果无缝重启</h2><p>Go很适合编写服务器端的网络程序。DevOps经常会遇到的一个情况是升级系统或者重新加载配置文件，在这种情况下我们需要重启此网络程序，如果网络程序暂停的时间较长，则给客户的感觉很不好。</p><p>如何实现优雅地重启一个Go网络程序呢。主要要解决两个问题:</p><ul><li>进程重启不需要关闭监听的端口</li><li>既有请求应当完全处理或者超时</li></ul><p>文章<a href="https://grisha.org/blog/2014/06/03/graceful-restart-in-golang/" target="_blank" rel="noopener">Graceful Restart in Golang</a>中提供了一种方式，而Florian von Bock根据此思路实现了一个框架<a href="https://github.com/fvbock/endless" target="_blank" rel="noopener">endless</a>。</p><p>此框架使用起来超级简单:<br><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">err := endless.ListenAndServe(<span class="string">"localhost:4242"</span>, mux)</span><br></pre></td></tr></table></figure></p><p>只需替换<code>http.ListenAndServe</code>和<code>http.ListenAndServeTLS</code>。</p><p>它会监听这些信号： <code>syscall.SIGHUP</code>, <code>syscall.SIGUSR1</code>, <code>syscall.SIGUSR2</code>, <code>syscall.SIGINT</code>, <code>syscall.SIGTERM</code>和<code>syscall.SIGTSTP</code>。</p><p>此文章提到的思路是：</p><p>通过<code>exec.Command</code> fork一个新的进程，同时继承当前进程的打开的文件(输入输出，socket等)<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">file := netListener.File() // this returns a Dup()</span><br><span class="line">path := <span class="string">"/path/to/executable"</span></span><br><span class="line">args := []string&#123;</span><br><span class="line">    <span class="string">"-graceful"</span>&#125;</span><br><span class="line">cmd := exec.Command(path, args...)</span><br><span class="line">cmd.Stdout = os.Stdout</span><br><span class="line">cmd.Stderr = os.Stderr</span><br><span class="line">cmd.ExtraFiles = []*os.File&#123;file&#125;</span><br><span class="line">err := cmd.Start()</span><br><span class="line"><span class="keyword">if</span> err != nil &#123;</span><br><span class="line">    log.Fatalf(<span class="string">"gracefulRestart: Failed to launch, error: %v"</span>, err)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>子进程初始化</p><p>网络程序的启动代码</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">server := &amp;http.Server&#123;Addr: <span class="string">"0.0.0.0:8888"</span>&#125;</span><br><span class="line"> <span class="keyword">var</span> gracefulChild <span class="keyword">bool</span></span><br><span class="line"> <span class="keyword">var</span> l net.Listever</span><br><span class="line"> <span class="keyword">var</span> err error</span><br><span class="line"> flag.BoolVar(&amp;gracefulChild, <span class="string">"graceful"</span>, <span class="literal">false</span>, <span class="string">"listen on fd open 3 (internal use only)"</span>)</span><br><span class="line"> <span class="keyword">if</span> gracefulChild &#123;</span><br><span class="line">     log.Print(<span class="string">"main: Listening to existing file descriptor 3."</span>)</span><br><span class="line">     f := os.NewFile(<span class="number">3</span>, <span class="string">""</span>)</span><br><span class="line">     l, err = net.FileListener(f)</span><br><span class="line"> &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">     log.Print(<span class="string">"main: Listening on a new file descriptor."</span>)</span><br><span class="line">     l, err = net.Listen(<span class="string">"tcp"</span>, server.Addr)</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p>父进程停止</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> gracefulChild &#123;</span><br><span class="line">    parent := syscall.Getppid()</span><br><span class="line">    log.Printf(<span class="string">"main: Killing parent pid: %v"</span>, parent)</span><br><span class="line">    syscall.Kill(parent, syscall.SIGTERM)</span><br><span class="line">&#125;</span><br><span class="line">server.Serve(l)</span><br></pre></td></tr></table></figure><p>因此，处理特定的信号可以实现程序无缝的重启。</p><h2 id="其它"><a href="#其它" class="headerlink" title="其它"></a>其它</h2><p>graceful shutdown实现非常的简单，通过简单的信号处理就可以实现。本文介绍的是graceful restart,要求无缝重启，所以所用的技术相当的hack。</p><p>Facebook的工程师也提供了http和net的实现： <a href="https://github.com/facebookgo/grace" target="_blank" rel="noopener">facebookgo</a>。</p><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p><a href="http://colobu.com/2015/10/09/Linux-Signals/?utm_source=tuicool&amp;utm_medium=referral" target="_blank" rel="noopener">http://colobu.com/2015/10/09/Linux-Signals/?utm_source=tuicool&amp;utm_medium=referral</a></p><p><a href="https://en.wikipedia.org/wiki/Unix_signal" target="_blank" rel="noopener">https://en.wikipedia.org/wiki/Unix_signal</a><br><a href="http://hutaow.com/blog/2013/10/19/linux-signal/" target="_blank" rel="noopener">http://hutaow.com/blog/2013/10/19/linux-signal/</a><br><a href="http://www.ucs.cam.ac.uk/docs/course-notes/unix-courses/Building/files/signals.pdf" target="_blank" rel="noopener">http://www.ucs.cam.ac.uk/docs/course-notes/unix-courses/Building/files/signals.pdf</a><br><a href="https://golang.org/pkg/os/signal/" target="_blank" rel="noopener">https://golang.org/pkg/os/signal/</a><br><a href="https://gobyexample.com/signals" target="_blank" rel="noopener">https://gobyexample.com/signals</a><br><a href="http://grisha.org/blog/2014/06/03/graceful-restart-in-golang/" target="_blank" rel="noopener">http://grisha.org/blog/2014/06/03/graceful-restart-in-golang/</a><br><a href="https://fitstar.github.io/falcore/hot_restart.html" target="_blank" rel="noopener">https://fitstar.github.io/falcore/hot_restart.html</a><br><a href="https://github.com/rcrowley/goagain" target="_blank" rel="noopener">https://github.com/rcrowley/goagain</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;信号(Signal)是Linux, 类Unix和其它POSIX兼容的操作系统中用来进程间通讯的一种方式。一个信号就是一个异步的通知，发送给某个进程，或者同进程的某个线程，告诉它们某个事件发生了。&lt;br&gt;当信号发送到某个进程中时，操作系统会中断该进程的正常流程，并进入相应的信号处理函数执行操作，完成后再回到中断的地方继续执行。&lt;br&gt;如果目标进程先前注册了某个信号的处理程序(signal handler),则此处理程序会被调用，否则缺省的处理程序被调用。&lt;/p&gt;
    
    </summary>
    
      <category term="golang" scheme="http://researchlab.github.io/categories/golang/"/>
    
    
      <category term="signal" scheme="http://researchlab.github.io/tags/signal/"/>
    
  </entry>
  
  <entry>
    <title>golang server 跨域解决总结</title>
    <link href="http://researchlab.github.io/2017/01/20/go-http-cross-origin/"/>
    <id>http://researchlab.github.io/2017/01/20/go-http-cross-origin/</id>
    <published>2017-01-20T15:30:40.000Z</published>
    <updated>2018-10-16T13:03:07.485Z</updated>
    
    <content type="html"><![CDATA[<p>server提供api服务直接对接前端js, 但是存在跨域问题，本文使用先查询请求过来的host 然后判断主域名是否存在，存在,则在返回头部设置这个请求域名充许跨域访问。<br><a id="more"></a></p><h2 id="跨域概念"><a href="#跨域概念" class="headerlink" title="跨域概念"></a>跨域概念</h2><p>浏览器的同源策略，出于防范跨站脚本的攻击，禁止客户端脚本（如 JavaScript）对不同域的服务进行跨站调用。</p><p>一般的，只要网站的 协议名protocol 、 主机host 、 端口号port 这三个中的任意一个不同，网站间的数据请求与传输便构成了跨域调用。</p><p>一般的，发起跨域请求而没有被设置许可跨域时，则会返回类型下面的说明</p><center><img src="/imgs/cross-website.png" alt="cross-website"></center><p>上面返回提示说明: 跨域请求并非是浏览器限制了发起跨站请求，而是请求可以正常发起，到达服务器端，但是服务器返回的结果会被浏览器拦截。</p><blockquote><p>为了防止CSRF的攻击，我们建议修改浏览器在发送POST请求的时候加上一个Origin字段，这个Origin字段主要是用来标识出最初请求是从哪里发起的。如果浏览器不能确定源在哪里，那么在发送的请求里面Origin字段的值就为空。隐私方面：这种Origin字段的方式比Referer更人性化，因为它尊重了用户的隐私。<br>1、Origin字段里只包含是谁发起的请求，并没有其他信息 (通常情况下是方案，主机和活动文档URL的端口)。跟Referer不一样的是，Origin字段并没有包含涉及到用户隐私的URL路径和请求内容，这个尤其重要。<br>2、Origin字段只存在于POST请求，而Referer则存在于所有类型的请求, (随便点击一个超链接（比如从搜索列表里或者企业intranet），并不会发送Origin字段)。</p></blockquote><h2 id="获取完整url"><a href="#获取完整url" class="headerlink" title="获取完整url"></a>获取完整url</h2><p>查阅了r *http.Request对象中的所有属性，没有发现可以直接获取完整的url的方法。于是尝试根据host和请求地址进行拼接。在golang中可以通过r.Host获取hostname，r.RequestURI获取相应的请求地址。</p><p>但是还少一个协议的判断，怎么区分是http和https呢？一开始尝试通过r.Proto属性判断，但是发现该属性不管是http，还是https都是返回HTTP/1.1，又寻找了下发现TLS属性，在https协议下有对应值，在http下为nil。</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"> </span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">"fmt"</span></span><br><span class="line">    <span class="string">"log"</span></span><br><span class="line">    <span class="string">"net/http"</span></span><br><span class="line">    <span class="string">"strings"</span></span><br><span class="line">)</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">index</span><span class="params">(w http.ResponseWriter, r *http.Request)</span></span> &#123;</span><br><span class="line">    fmt.Println(r.Proto)</span><br><span class="line">    <span class="comment">// output:HTTP/1.1</span></span><br><span class="line">    fmt.Println(r.TLS)</span><br><span class="line">    <span class="comment">// output: &lt;nil&gt;</span></span><br><span class="line">    fmt.Println(r.Host)</span><br><span class="line">    <span class="comment">// output: localhost:9090</span></span><br><span class="line">    fmt.Println(r.RequestURI)</span><br><span class="line">    <span class="comment">// output: /index?id=1</span></span><br><span class="line"> </span><br><span class="line">    scheme := <span class="string">"http://"</span></span><br><span class="line">    <span class="keyword">if</span> r.TLS != <span class="literal">nil</span> &#123;</span><br><span class="line">        scheme = <span class="string">"https://"</span></span><br><span class="line">    &#125;</span><br><span class="line">    fmt.Println(strings.Join([]<span class="keyword">string</span>&#123;scheme, r.Host, r.RequestURI&#125;, <span class="string">""</span>))</span><br><span class="line">    <span class="comment">// output: http://localhost:9090/index?id=1</span></span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    http.HandleFunc(<span class="string">"/index"</span>, index)</span><br><span class="line"> </span><br><span class="line">    err := http.ListenAndServe(<span class="string">":9090"</span>, <span class="literal">nil</span>)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        log.Fatal(<span class="string">"ListenAndServe: "</span>, err)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="动态许可跨域"><a href="#动态许可跨域" class="headerlink" title="动态许可跨域"></a>动态许可跨域</h2><p>1.直接取头部的<code>Origin</code>字段， 如果取到， 则判断是否包含主域名，然后设置跨域，如果<code>Origin</code>字段为空不存在，则转下面第2步;<br>2.获取子域名(scheme + r.Host)之后, 先判断是否存在，并且是否包含主域名，然后设置跨域, 如果<code>r.Host</code>字段为空， 则转下面第3步;<br>3.获取子域名(scheme + r.URL.Host)之后， 判断是否存在， 并且是否包含主域名， 然后设置跨域，</p><p>还有一种方法是利用redis缓存，同样通过上述三个方法获取子域名， 然后查询redis缓存是否存在这个域名，如果有则设置许可跨域; redis缓存的数据来源是 另外准备一个后台，当后台有修改许可跨域网站时，写完db(mysql)的同时先清空缓存，然后在回填缓存即可。</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Origin := r.Header.Get(<span class="string">"Origin"</span>)</span><br><span class="line">    <span class="keyword">if</span> <span class="number">0</span> != <span class="built_in">len</span>(Origin) &amp;&amp; strings.Contains(Origin, <span class="string">"domain.com"</span>)&#123;</span><br><span class="line">        w.Header().Add(<span class="string">"Access-Control-Allow-Origin"</span>, Origin)</span><br><span class="line">        w.Header().Add(<span class="string">"Access-Control-Allow-Methods"</span>, <span class="string">"POST,GET,OPTIONS,DELETE"</span>)</span><br><span class="line">        w.Header().Add(<span class="string">"Access-Control-Allow-Headers"</span>, <span class="string">"x-requested-with,content-type"</span>)</span><br><span class="line">        w.Header().Add(<span class="string">"Access-Control-Allow-Credentials"</span>, <span class="string">"true"</span>)</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><blockquote><p>当不添加 <code>Access-Control-Allow-Methods</code>属性时， 默认支持使用GET、HEAD或者POST请求方法跨域请求</p></blockquote><p>更多参考</p><p><a href="http://www.open-open.com/lib/view/open1473667695212.html" target="_blank" rel="noopener">前端跨域请求原理与实践</a></p><p><a href="http://www.cnblogs.com/dojo-lzz/p/4265637.html" target="_blank" rel="noopener">探讨跨域请求资源的几种方式</a></p><p><a href="https://github.com/hstarorg/HstarDoc/blob/master/%E5%89%8D%E7%AB%AF%E7%9B%B8%E5%85%B3/CORS%E8%AF%A6%E8%A7%A3.md" target="_blank" rel="noopener">关于CORS</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;server提供api服务直接对接前端js, 但是存在跨域问题，本文使用先查询请求过来的host 然后判断主域名是否存在，存在,则在返回头部设置这个请求域名充许跨域访问。&lt;br&gt;
    
    </summary>
    
      <category term="golang" scheme="http://researchlab.github.io/categories/golang/"/>
    
    
      <category term="golang" scheme="http://researchlab.github.io/tags/golang/"/>
    
  </entry>
  
  <entry>
    <title>git submodule使用总结</title>
    <link href="http://researchlab.github.io/2017/01/18/git-submodule/"/>
    <id>http://researchlab.github.io/2017/01/18/git-submodule/</id>
    <published>2017-01-18T17:11:52.000Z</published>
    <updated>2018-10-16T13:03:07.485Z</updated>
    
    <content type="html"><![CDATA[<p>现在golang已经可以通过<code>vendor</code>来管理第三方依赖包了，但是之前的一个老项目用的是<code>git submodule</code>来管理的，但是<code>.gitsubmodule</code>文件中只记录管理了项目的部分依赖包， 需要把还没有被管理的第三包也加上，下面总结使用<code>git submodule</code>的过程。<br><a id="more"></a></p><h2 id="添加第三方包"><a href="#添加第三方包" class="headerlink" title="添加第三方包"></a>添加第三方包</h2><p>为当前工程添加submodule，命令如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git submodule add 仓库地址 保存路经路径</span><br></pre></td></tr></table></figure><p>例如要为gomail包添加<code>submodule</code>管理，<br>gomail包 仓库地址: <code>https://github.com/go-gomail/gomail.git</code><br>gomail包要保存在项目里的路经为: <code>src/github.com/go-gomail/gomail</code>, 则命令为:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git submodule add https://github.com/go-gomail/gomail   src/github.com/go-gomail/gomail</span><br></pre></td></tr></table></figure><p>但是老项目遇到的情况是在保存路经<code>src/github.com/go-gomail/gomail</code>中已经存在<code>gomail</code>, 这里只是需要把这个第三包用<code>git submodule</code>记录下来编译管理， 所以需要加一个强制参数， 则命令为如下:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git submodule add -f https://github.com/go-gomail/gomail   src/github.com/go-gomail/gomail</span><br></pre></td></tr></table></figure><blockquote><p>其中，仓库地址是指子模块仓库地址，路径指将子模块放置在当前工程下的路径。<br>注意：路径不能以 / 结尾（会造成修改不生效）、不能是现有工程已有的目录（不能順利 Clone）</p></blockquote><p>命令执行完成，会在当前工程根路径下生成一个名为<code>.gitmodules</code>的文件，其中记录了子模块的信息。添加完成以后，再将子模块所在的文件夹添加到工程中即可。</p><h2 id="删除第三方包"><a href="#删除第三方包" class="headerlink" title="删除第三方包"></a>删除第三方包</h2><p>submodule的删除稍微麻烦点:首先，要在“.gitmodules”文件中删除相应配置信息。然后，执行“git rm –cached ”命令将子模块所在的文件从git中删除。</p><h2 id="下载的工程带有submodule"><a href="#下载的工程带有submodule" class="headerlink" title="下载的工程带有submodule"></a>下载的工程带有submodule</h2><p>当使用git clone下来的工程中带有submodule时，初始的时候，submodule的内容并不会自动下载下来的，此时，只需执行如下命令：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git submodule update --init --recursive</span><br></pre></td></tr></table></figure></p><p>即可将子模块内容下载下来后工程才不会缺少相应的文件。</p><h2 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h2><p>当第三包被<code>git submodule</code>记录之后，<code>git status</code>命令会出现下面的情况,<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ git status vendor | grep modified:</span><br><span class="line"><span class="comment">#       modified:   vendor/rails (modified content)</span></span><br></pre></td></tr></table></figure></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">$ git diff vendor/</span><br><span class="line">diff --git a/vendor/rails b/vendor/rails</span><br><span class="line">--- a/vendor/rails</span><br><span class="line">+++ b/vendor/rails</span><br><span class="line">@@ -1 +1 @@</span><br><span class="line">-Subproject commit 046c900df27994d454b7f906caa0e4226bb42b6f</span><br><span class="line">+Subproject commit 046c900df27994d454b7f906caa0e4226bb42b6f-dirty</span><br></pre></td></tr></table></figure><p>如何让<code>git status</code>不显示那个<code>modified content</code>呢？<br>修改<code>.gitmodule</code>文件， 在显示<code>modified content</code>的第三包管理下添加一个<code>ignore = dirty</code>， 如下:<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[submodule <span class="string">"bundle/fugitive"</span>]</span><br><span class="line">    path = bundle/fugitive</span><br><span class="line">    url = git://github.com/tpope/vim-fugitive.git</span><br><span class="line">    ignore = dirty</span><br></pre></td></tr></table></figure></p><p>上述三个步骤一般就能解决问题了， 如果想深入理解<code>git submodule</code>,可进一步参考<a href="http://www.kafeitu.me/git/2012/03/27/git-submodule.html" target="_blank" rel="noopener">git submodule使用完整教程</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;现在golang已经可以通过&lt;code&gt;vendor&lt;/code&gt;来管理第三方依赖包了，但是之前的一个老项目用的是&lt;code&gt;git submodule&lt;/code&gt;来管理的，但是&lt;code&gt;.gitsubmodule&lt;/code&gt;文件中只记录管理了项目的部分依赖包， 需要把还没有被管理的第三包也加上，下面总结使用&lt;code&gt;git submodule&lt;/code&gt;的过程。&lt;br&gt;
    
    </summary>
    
      <category term="DevOps" scheme="http://researchlab.github.io/categories/DevOps/"/>
    
    
      <category term="submodule" scheme="http://researchlab.github.io/tags/submodule/"/>
    
  </entry>
  
  <entry>
    <title>http 缓存知识总结</title>
    <link href="http://researchlab.github.io/2017/01/17/http-cache/"/>
    <id>http://researchlab.github.io/2017/01/17/http-cache/</id>
    <published>2017-01-17T17:54:18.000Z</published>
    <updated>2018-10-16T13:03:07.485Z</updated>
    
    <content type="html"><![CDATA[<p>Http缓存机制作为web性能优化的重要手段, 本文对网络中，工作中使用的http缓存知识进行归纳总结。<br><a id="more"></a></p><h2 id="缓存分类"><a href="#缓存分类" class="headerlink" title="缓存分类"></a>缓存分类</h2><p>缓存分为<code>服务端缓存</code>(server side，比如Nginx、Apache)和<code>客户端缓存</code>(client side，比如 web browser)。</p><ul><li><code>服务端缓存</code>又分为<code>代理服务器缓存</code>和<code>反向代理服务器缓存</code>(也叫网关缓存，比如Nginx反向代理、Squid等)，其实广泛使用的CDN也是一种服务端缓存，目的都是让用户的请求走”捷径”(一般用CDN缓存图片、文件等静态资源)。</li><li><code>客户端缓存</code>一般指的是<code>浏览器缓存</code>，目的就是加速各种静态资源的访问，想想现在的大型网站，随便一个页面都是一两百个请求，每天pv都是亿级别，如果没有缓存，用户体验会急剧下降、同时服务器压力和网络带宽都面临严重的考验。</li></ul><p>下文总结的http缓存主要指浏览器缓存和代理服务器缓存</p><center><img src="imgs/cache_where.png" alt="cache"></center><p>上图中有三个角色，浏览器, Web代理和服务器，如图所示Http缓存存在于浏览器和Web代理中。<br>当然在服务器内部，也存在着各种缓存，但这已经不是本文要讨论的Http缓存了。<br>所谓的Http缓存控制，就是一种约定，通过设置不同的响应头Cache-Control来控制浏览器和Web代理对缓存的使用策略，通过设置请求头If-None-Match和响应头ETag，来对缓存的有效性进行验证。在开发Web服务时，只需要关注请求头If-None-Match、响应头ETag、响应头Cache-Control就足够了。</p><p><strong> 响应头ETag </strong></p><p>ETag全称Entity Tag，用来标识一个资源。在具体的实现中，ETag可以是资源的hash值，也可以是一个内部维护的版本号。但不管怎样，ETag应该能反映出资源内容的变化，这是Http缓存可以正常工作的基础。</p><center><img src="imgs/etag.png" alt="ETag"></center><p>如上例中所展示的，服务器在返回响应时，通常会在Http头中包含一些关于响应的元数据信息，其中，ETag就是其中一个，本例中返回了值为<code>x1323ddx</code>的<code>ETag</code>。当资源/file的内容发生变化时，服务器应当返回不同的ETag。</p><blockquote><p>为什么使用ETag呢? 主要是为了解决Last-Modified无法解决的一些问题。</p></blockquote><blockquote><blockquote><p>1.某些服务器不能精确得到文件的最后修改时间, 这样就无法通过最后修改时间来判断文件是否更新了。<br>2.某些文件的修改非常频繁, 在秒以下的时间内进行修改, Last-Modified只能精确到秒。<br>3.一些文件的最后修改时间改变了, 但是内容并未改变, 我们不希望客户端认为这个文件修改了。</p></blockquote></blockquote><p><strong> 请求头If-None-Match </strong></p><p>对于同一个资源，比如上一例中的/file，在进行了一次请求之后，浏览器就已经有了/file的一个版本的内容，和这个版本的ETag，当下次用户再需要这个资源，浏览器再次向服务器请求的时候，可以利用请求头If-None-Match来告诉服务器自己已经有个ETag为x1323ddx的/file，这样，如果服务器上的/file没有变化，也就是说服务器上的/file的ETag也是x1323ddx的话，服务器就不会再返回/file的内容，而是返回一个304的响应，告诉浏览器该资源没有变化，缓存有效。</p><center><img src="imgs/if-none-match.png" alt="If-None-Match"></center><p>如上例中所示，在使用了If-None-Match之后，服务器只需要很小的响应就可以达到相同的结果，从而优化了性能。</p><p><strong> 响应头Cache-Control </strong></p><p>每个资源都可以通过Http头Cache-Control来定义自己的缓存策略，Cache-Control控制谁在什么条件下可以缓存响应以及可以缓存多久。最快的请求是不必与服务器进行通信的请求:通过响应的本地副本, 我们可以避免所有的网络延迟以及数据传输的数据成本。为此，HTTP规范允许服务器返回一系列不同的<code>Cache-Control</code>指令，控制浏览器或者其他中继缓存如何缓存某个响应以及缓存多长时间。</p><blockquote><p>Cache-Control头在HTTP/1.1规范中定义，取代了之前用来定义响应缓存策略的头(例如 Expires)。当前的所有浏览器都支持Cache-Control，因此，使用它就够了。</p></blockquote><p>其中Cache-Control的参数包括:</p><ul><li><strong> max-age </strong>  - 该指令指定从当前请求开始，允许获取的响应被重用的最长时间（单位为秒。例如：Cache-Control:max-age=60表示响应可以再缓存和重用 60 秒。需要注意的是，在max-age指定的时间之内，浏览器不会向服务器发送任何请求，包括验证缓存是否有效的请求，也就是说，如果在这段时间之内，服务器上的资源发生了变化，那么浏览器将不能得到通知，而使用老版本的资源。所以在设置缓存时间的长度时，需要慎重。)，它在最大生存期后必须在源服务器处被验证或被重新下载。在现代浏览器中这个选项大体上取代了Expires头部，浏览器也将其作为决定内容的新鲜度的基础。最大可以表示一年的新鲜期（31536000秒）。但是这个参数定义的是时间大小(比如: 60)而不是确定的时间点, 单位是[秒seconds] </li><li><strong> s-maxage </strong>  - 类似于max-age, 但是它只用于公享缓存(e.g., proxy), 这个选项非常类似于max-age，它指明了内容能够被缓存的时间。区别是这个选项只在中间节点的缓存中有效。结合这两个选项可以构建更加灵活的缓存策略。</li><li><strong> public </strong> - 设置了public，表示该响应可以再浏览器或者任何中继的Web代理中缓存，public是默认值，即Cache-Control:max-age=60等同于Cache-Control:public, max-age=60。</li><li><strong> private </strong> - 在服务器设置了private比如Cache-Control:private, max-age=60的情况下，表示只有用户的浏览器可以缓存private响应，不允许任何中继Web代理对其进行缓存 - 例如，用户浏览器可以缓存包含用户私人信息的HTML网页，但是CDN不能缓存。</li><li><strong> no-cache </strong> - 如果服务器在响应中设置了no-cache即Cache-Control:no-cache，那么浏览器在使用缓存的资源之前，必须先与服务器确认返回的响应是否被更改，如果资源未被更改，可以避免下载。这个验证之前的响应是否被修改，就是通过上面介绍的请求头If-None-match和响应头ETag来实现的。<font color="red">(注意: no-cache这个名字有一点误导。设置了no-cache之后，并不是说浏览器就不再缓存数据，只是浏览器在使用缓存数据时，需要先确认一下数据是否还跟服务器保持一致。如果设置了no-cache，而ETag的实现没有反应出资源的变化，那就会导致浏览器的缓存数据一直得不到更新的情况。)</font> </li><li><strong> no-store </strong> - 如果服务器在响应中设置了no-store即Cache-Control:no-store，那么浏览器和任何中继的Web代理，都不会存储这次相应的数据。当下次请求该资源时，浏览器只能重新请求服务器，重新从服务器读取资源。</li><li><strong> must-revalidate </strong> - 响应在特定条件下会被重用, 以满足接下来的请求, 但是它必须到服务器端去验证它是不是仍然是最新的,它指明了由max-age、s-maxage或Expires头部指明的新鲜度信息必须被严格的遵守。它避免了缓存的数据在网络中断等类似的场景中被使用。</li><li><strong> proxy-revalidate </strong> - 类似于must-revalidate, 但不适用于代理缓存, 它和上面的选项有着一样的作用，但只应用于中间的代理节点。在这种情况下，用户的浏览器可以在网络中断时使用过期内容，但中间缓存内容不能用于此目的。</li><li><strong> no-transform </strong> - 这个选项告诉缓存在任何情况下都不能因为性能的原因修改接收到的内容。这意味着，缓存不允许压缩接收到的内容（没有从原始服务器处接收过压缩版本的该内容）并发送。</li></ul><blockquote><p>如果no-store和no-cache都被设置，那么no-store会取代no-cache。</p></blockquote><blockquote><p>cache-control默认为private, 其作用根据不同的重新浏览方式分为以下几种情况:</p></blockquote><blockquote><blockquote><p>1.打开新窗口 值为private、no-cache、must-revalidate，那么打开新窗口访问时都会重新访问服务器。而如果指定了max-age值，那么在此值内的时间里就不会重新访问服务器，例如: Cache-control:max-age=5(表示当访问此网页后的5秒内再次访问不会去服务器)<br>2.在地址栏回车 值为private或must-revalidate则只有第一次访问时会访问服务器，以后就不再访问。 值为no-cache，那么每次都会访问。 值为max-age，则在过期之前不会重复访问。<br>3.按后退按扭 值为private、must-revalidate、max-age，则不会重访问，值为no-cache，则每次都重复访问<br>4.按刷新按扭 无论为何值，都会重复访问 Cache-control值为”no-cache”时，访问此页面不会在Internet临时文件夹留下页面备份。</p></blockquote></blockquote><p>Cache-Control 有这么多字段可用来控制缓存策略， 那到底是怎么用的? ， 下面通过一张图来表述一个资源的Cache-Control策略,</p><center><img src="imgs/cache_control_workflow.png" alt="cache-control-work-flow"></center><h2 id="缓存新鲜度"><a href="#缓存新鲜度" class="headerlink" title="缓存新鲜度"></a>缓存新鲜度</h2><p>Web服务器通过2种方式来判断浏览器缓存是否是最新的。</p><p><strong> 第一种, 浏览器把缓存文件的<code>最后修改时间</code>通过header字段”If-Modified-Since”来告诉Web服务器。</strong><br><strong> 第二种, 浏览器把缓存文件的<code>ETag</code>, 通过header字段”If-None-Match”, 来告诉Web服务器。</strong></p><p><strong> 第一种: </strong> 通过最后修改时间, 来判断缓存新鲜度 </p><p>1.浏览器客户端想请求一个文档, 首先检查本地缓存, 发现存在这个文档的缓存, 获取缓存中文档的最后修改时间, 通过:If-Modified-Since， 发送Request给Web服务器。<br>2.Web服务器收到Request, 将服务器的文档修改时间(Last-Modified):跟request header中的, If-Modified-Since相比较, 如果时间是一样的, 说明缓存还是最新的, Web服务器将发送<code>304 Not Modified</code>给浏览器客户端, 告诉客户端直接使用缓存里的版本。如下图。</p><center><img src="imgs/cache_304.png" alt="cache 304"></center><p>3.假如该文档已经被更新了。Web服务器将发送该文档的最新版本给浏览器客户端， 如下图。</p><center><img src="imgs/cache_200.png" alt="cache 200"></center><p><strong> 第二种: </strong> 服务器通过比对客户端请求发来的”If-None-Match”带上的Etag值, 如果一致则表示可以使用本地缓存，如果不一致表示服务器内容有更新，此时会重新发一份新的给客户端。</p><p>至此，浏览器端http cache 的大致流程可总结如图，</p><center><img src="imgs/cache_workflow.png" alt="cache workflow"></center><p><strong> <font color="red">Etag/If-None-Match:</font>Etag/If-None-Match要配合Cache-Control使用。</strong></p><blockquote><p>Etag: web服务器响应请求时，告诉浏览器当前资源在服务器的唯一标识(生成规则由服务器决定)。Apache中，ETag的值，默认是对文件的索引节(INode)，大小(Size)和最后修改时间(MTime)进行Hash后得到的。<br>If-None-Match: 当资源过期时(使用Cache-Control标识的max-age)，发现资源具有Etage声明，则再次向web服务器请求时带上头If-None-Match(Etag的值)。web服务器收到请求后发现有头If-None-Match则与被请求资源的相应校验串进行比对，决定返回200或304。</p></blockquote><p><strong> <font color="red">Last-Modified/If-Modified-Since:</font>Last-Modified/If-Modified-Since也要配合Cache-Control使用。 </strong></p><blockquote><p>Last-Modified:标示这个响应资源的最后修改时间。web服务器在响应请求时，告诉浏览器资源的最后修改时间。<br>If-Modified-Since:当资源过期时(使用Cache-Control标识的max-age)，发现资源具有Last-Modified声明，则再次向web服务器请求时带上头If-Modified-Since，表示请求时间。web服务器收到请求后发现有头If-Modified-Since 则与被请求资源的最后修改时间进行比对。若最后修改时间较新，说明资源又被改动过，则响应整片资源内容（写在响应消息包体内），HTTP 200；若最后修改时间较旧，说明资源无新修改，则响应HTTP 304 (无需包体，节省浏览)，告知浏览器继续使用所保存的cache。</p></blockquote><p><font color="red">既生Last-Modified何生Etag? </font><br>你可能会觉得使用Last-Modified已经足以让浏览器知道本地的缓存副本是否足够新，为什么还需要Etag(实体标识)呢? HTTP1.1中Etag的出现主要是为了解决几个Last-Modified比较难解决的问题,</p><blockquote><p>Last-Modified标注的最后修改只能精确到秒级，如果某些文件在1秒钟以内，被修改多次的话，它将不能准确标注文件的修改时间, 如果某些文件会被定期生成，当有时内容并没有任何变化，但Last-Modified却改变了，导致文件没法使用缓存,有可能存在服务器没有准确获取文件修改时间，或者与代理服务器时间不一致等情形</p></blockquote><blockquote><p>Etag是服务器自动生成或者由开发者生成的对应资源在服务器端的唯一标识符, 能够更加准确的控制缓存。Last-Modified与ETag一起使用时, 服务器会优先验证ETag。</p></blockquote><p><strong> 注: <font color="red">yahoo的Yslow法则中则提示谨慎设置Etag,</font> </strong> 需要注意的是分布式系统里多台机器间文件的last-modified必须保持一致，以免负载均衡到不同机器导致比对失败，Yahoo建议分布式系统尽量关闭掉Etag(每台机器生成的etag都会不一样，因为除了last-modified、inode也很难保持一致)。</p><p>此外浏览器缓存行为还与用户的操作行为有关, 归纳总结如下,</p><table><thead><tr><th style="text-align:left">用户操作</th><th>Expires/Cache-Control</th><th>Last-Modified/Etag</th></tr></thead><tbody><tr><td style="text-align:left">地址栏回车</td><td>有效</td><td>有效</td></tr><tr><td style="text-align:left">页面链接跳转</td><td>有效</td><td>有效</td></tr><tr><td style="text-align:left">新开窗口</td><td>有效</td><td>有效</td></tr><tr><td style="text-align:left">前进、后退</td><td>有效</td><td>有效</td></tr><tr><td style="text-align:left"><font color="red">F5/按钮刷新 </font></td><td><font color="red"> 无效(BR重置max-age=0)</font></td><td><font color="red"> 有效     </font></td></tr><tr><td style="text-align:left"><font color="red">Ctrl+F5刷新 </font></td><td><font color="red"> 无效(重置CC=no-cache)</font></td><td><font color="red"> 无效(请求头丢弃该选项)</font></td></tr></tbody></table><h2 id="案例分析"><a href="#案例分析" class="headerlink" title="案例分析"></a>案例分析</h2><p>案例, page.html内容如下:<br><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE html&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">xmlns</span>=<span class="string">"http://www.w3.org/1999/xhtml"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">http-equiv</span>=<span class="string">"Content-Type"</span> <span class="attr">content</span>=<span class="string">"text/html; charset=utf-8"</span> /&gt;</span></span><br><span class="line"><span class="comment">&lt;!--&lt;meta http-equiv="cache-control" content="no-cache"&gt;--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">http-equiv</span>=<span class="string">"cache-control"</span> <span class="attr">content</span>=<span class="string">"private"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>page页<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">"images/head.png"</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"page.html"</span>&gt;</span>重新访问page页<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure></p><p>首次访问该页面，页面中head.png响应头信息如下:<br><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">HTTP/1.1 200 OK</span><br><span class="line">Cache-Control: no-cache</span><br><span class="line">Content-Type: image/png</span><br><span class="line">Last-Modified: Tue, 08 Nov 2016 06:59:00 GMT</span><br><span class="line">Accept-Ranges: bytes</span><br><span class="line">Date: Thu, 10 Nov 2016 02:48:50 GMT</span><br><span class="line">Content-Length: 3534</span><br></pre></td></tr></table></figure></p><p><strong> <font color="red"> 问题1: 请问当点击”重新访问page页”链接重新加载该页面后, head.png 如何二次加载? </font> </strong> </p><p><strong> <font color="red"> 问题2: 如果将上述信息中的 Cache-Control 设置为 private，那么结果又会如何呢? </font> </strong></p><p>下面从系统体系化角度来讲讲<code>Http缓存头</code>是如何协同工作的</p><p><strong> HTTP缓存体系 </strong></p><p>首先我将 Http 缓存体系分为以下三个部分:</p><center><img src="imgs/cache_sys.png" alt="cache"></center><p><strong> 1.缓存存储策略 </strong></p><p>这个策略的作用只有一个, 用于确定Http响应内容是否可以被客户端缓存, 以及可以被哪些客户端缓存</p><p>对于Cache-Control头里的Public, Private, no-cache, max-age, no-store他们都是用来指明响应内容是否可以被客户端存储的，其中前4个都会缓存文件数据(关于no-cache应理解为”不建议使用本地缓存”, 其仍然会缓存数据到本地), 后者no-store则不会在客户端缓存任何响应数据。</p><p>通过Cache-Control:Public设置我们可以将Http响应数据存储到本地，但此时并不意味着后续浏览器会直接从缓存中读取数据并使用, 为啥? 因为它无法确定本地缓存的数据是否可用(可能已经失效), 还必须借助一套鉴别机制来确认才行, 这就是我们下面要讲到的”缓存过期策略”。</p><p><strong> 2.缓存过期策略 </strong></p><p>客户端用来确认存储在本地的缓存数据是否已过期, 进而决定是否要发请求到服务端获取数据<br>这个策略的作用也只有一个, 那就是决定客户端是否可直接从本地缓存数据中加载数据并展示(否则就发请求到服务端获取)<br>刚上面我们已经阐述了数据缓存到了本地后还需要经过判断才能使用, 那么浏览器通过什么条件来判断呢? 答案是:Expires，Expires指明了缓存数据有效的绝对时间, 告诉客户端到了这个时间点(比照客户端时间点)后本地缓存就作废了, 在这个时间点内客户端可以认为缓存数据有效, 可直接从缓存中加载展示。</p><p>不过Http缓存头设计并没有想象的那么规矩, 像上面提到的Cache-Control(这个头是在Http1.1里加进来的)头里的no-cache和max-age就是特例, 它们既包含缓存存储策略也包含缓存过期策略, 以max-age为例, 它实际上相当于: Cache-Control:public/private(这里不太确定具体哪个)</p><p>Expires: 当前客户端时间 + maxAge。<br>而Cache-Control: no-cache 和 Cache-Control: max-age=0(单位是秒)相当</p><p>这里需要注意的是:</p><p><font color="red">Cache-Control中指定的缓存过期策略优先级高于Expires, 当它们同时存在的时候, Expires将被忽略不起作用。</font><br>缓存数据标记为已过期只是告诉客户端不能再直接从本地读取缓存了, 需要再发一次请求到服务器去确认, 并不等同于本地缓存数据从此就没用了, 有些情况下即使过期了还是会被再次用到，具体下面会讲到。</p><blockquote><p>Expires是Web服务器响应消息头字段，在响应http请求时告诉浏览器在过期时间前浏览器可以直接从浏览器缓存取数据，而无需再次请求。不过Expires 是HTTP 1.0的东西，现在默认浏览器均默认使用HTTP 1.1，所以它的作用基本忽略。Expires 的一个缺点就是，返回的到期时间是服务器端的时间，这样存在一个问题，如果客户端的时间与服务器的时间相差很大（比如时钟不同步，或者跨时区），那么误差就很大，所以在HTTP 1.1版开始，使用Cache-Control: max-age=秒替代。</p></blockquote><p><strong> 3.缓存对比策略 </strong></p><p>将缓存在客户端的数据标识发往服务端, 服务端通过标识来判断客户端缓存数据是否仍有效, 进而决定是否要重发数据。<br>客户端检测到数据过期或浏览器刷新后, 往往会重新发起一个http请求到服务器, 服务器此时并不急于返回数据, 而是看请求头有没有带标识(If-Modified-Since, If-None-Match)过来, 如果判断标识仍然有效, 则返回304告诉客户端取本地缓存数据来用即可(这里要注意的是你必须要在首次响应时输出相应的头信息(Last-Modified, ETags)到客户端)。至此我们就明白了上面所说的本地缓存数据即使被认为过期，并不等于数据从此就没用了的道理了。</p><p>关于Last-Modified，这个响应头使用要注意，可能会影响到缓存过期策略，具体原因，后面我会通过解答开篇提到的2道题来作说明。</p><p>以上就是我所认识的缓存策略，下面我将缓存策略三要素和常用的几个缓存头(项)结合一起，让大家更清晰的认识到它们之间的关系:</p><center><img src="imgs/cache_sys_relation.png" alt="cache sys relation"></center><p>通过上图可以清晰的看到各缓存项分别属于哪个缓存策略范畴，这其中有部分重叠，它表明这些缓存项具有多重缓存策略，所以实际在分析缓存头的时候，除了常规的头外，我们还需要将这些具有双重缓存策略的项分解开来。<br>现在回到最开始提到的2道题目,</p><p><strong> 第一道题: </strong><br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">HTTP/1.1 200 OK</span><br><span class="line">Cache-Control: no-cache</span><br><span class="line">Content-Type: image/png</span><br><span class="line">Last-Modified: Tue, 08 Nov 2016 06:59:00 GMT</span><br><span class="line">Accept-Ranges: bytes</span><br><span class="line">Date: Thu, 10 Nov 2016 02:48:50 GMT</span><br><span class="line">Content-Length: 3534</span><br></pre></td></tr></table></figure></p><p>分析上述Http响应头发现有以下两项与缓存相关:<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Cache-Control: no-cache </span><br><span class="line">Last-Modified: Tue, 08 Nov 2016 06:59:00 GMT</span><br></pre></td></tr></table></figure></p><p>我们上面讲到了Cache-Control:no-cache 相当于Cache-Control:max-age=0，且他们都是多重策略头, 我们需将其分解:</p><p>Cache-Control:no-cache 等于 Cache-Control:max-age=0， </p><p>接着Cache-Control:max-age=0 又可分解成:<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Cache-Control: public/private （不确定是二者中的哪一个）</span><br><span class="line">Expires: 当前时间</span><br></pre></td></tr></table></figure></p><p><strong> 最终我们得到了以下完整的缓存策略三要素: </strong></p><table><thead><tr><th style="text-align:center">缓存策略类型</th><th style="text-align:left">缓存策略值</th><th style="text-align:left">结果</th><th style="text-align:left">备注</th></tr></thead><tbody><tr><td style="text-align:center">缓存存储策略</td><td style="text-align:left">cache-control:public/private</td><td style="text-align:left">响应数据会被缓存到客户端</td><td style="text-align:left">由cache-control:no-cache拆解而来</td></tr><tr><td style="text-align:center">缓存过期策略</td><td style="text-align:left">Expires:当前时间</td><td style="text-align:left">立马过期, 二次资源访问浏览器会重新发起http请求</td><td style="text-align:left">由cache-control:no-cache拆解而来</td></tr><tr><td style="text-align:center">缓存对比策略</td><td style="text-align:left">Last-Modifed: Tue, 08 Nov 2016 06:59:00 GMT</td><td style="text-align:left">浏览器会携带该值去服务端比对，比对成功则返回304, 服务端提示浏览器从本地加载数据，否在返回200并响应数据。</td></tr></tbody></table><p>所以最终结果是:浏览器会再次请求服务端, 并携带上Last-Modified指定的时间去服务器对比:</p><p>a)对比失败: 服务器返回200并重发数据, 客户端接收到数据后展示, 并刷新本地缓存。<br>b)对比成功: 服务器返回304且不重发数据, 客户端收到304状态码后从本地读取缓存数据。</p><center><img src="imgs/cache_data1.jpg" alt="cache_data"></center><p>这道题本身不难, 但若认为no-cache不会缓存数据到本地, 那么你理解起来就会很矛盾, 因为如果文件数据没有被本地缓存, 服务器返回304后将会无法展示出图片内容, 但实际上它是能正常展示的。这道题很好的证明了no-cache也会缓存数据到本地这一说法。</p><p><strong> 第二道题: </strong><br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">HTTP/1.1 200 OK</span><br><span class="line">Cache-Control: private</span><br><span class="line">Content-Type: image/png</span><br><span class="line">Last-Modified: Tue, 08 Nov 2016 06:59:00 GMT</span><br><span class="line">Accept-Ranges: bytes</span><br><span class="line">Date: Thu, 10 Nov 2016 02:48:50 GMT</span><br><span class="line">Content-Length: 3534</span><br></pre></td></tr></table></figure></p><p>解题思路和上题一样，首先先找到缓存相关项:<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Cache-Control: private     </span><br><span class="line">Last-Modified: Tue, 08 Nov 2016 06:59:00 GMT</span><br></pre></td></tr></table></figure></p><p><code>private</code>: 指对于单个用户的整个或部分响应消息进行缓存，不能被共享缓存处理。这允许服务器仅仅描述当用户的部分响应消息，此响应消息对于其他用户的请求无效,这里可以看到没有提供任何缓存过期策略</p><p>在没有提供任何浏览器缓存过期策略的情况下，浏览器遵循一个启发式缓存过期策略, <strong> 根据响应头中2个时间字段Date和Last-Modified之间的时间差值，取其值的10%作为缓存时间周期。</strong> 下面是官方解释,</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">HTTP/1.1 Cache-Control Header is present: private</span><br><span class="line">HTTP Last-Modified Header is present: Tue, 08 Nov 2016 06:59:00 GMT</span><br><span class="line">No explicit HTTP Cache Lifetime information was provided.</span><br><span class="line">Heuristic expiration policies suggest defaulting to: 10% of the delta between Last-Modified and Date.</span><br><span class="line">That's '05:15:02' so this response will heuristically expire 2016/11/11 0:46:01.</span><br></pre></td></tr></table></figure><p>最终我们得到了以下完整的缓存策略三要素:</p><table><thead><tr><th style="text-align:center">缓存策略类型</th><th style="text-align:left">缓存策略值</th><th style="text-align:left">结果</th><th style="text-align:left">备注</th></tr></thead><tbody><tr><td style="text-align:center">缓存存储策略</td><td style="text-align:left">cache-control:private</td><td style="text-align:left">响应数据会被缓存到客户端</td><td style="text-align:left"></td></tr><tr><td style="text-align:center">缓存过期策略</td><td style="text-align:left">Expires: 当前时间 + (date - Last-Modified) * 10%</td><td style="text-align:left">根据计算公式得到一个缓存过期时间</td><td style="text-align:left">在没有提供任何浏览器缓存过期策略的情况下，客户端计算响应头中2个时间字段Date和Last-Modified之间的时间差值(单位:秒), 取该值的10%作为缓存过期周期</td></tr><tr><td style="text-align:center">缓存对比策略</td><td style="text-align:left">Last-Modifed: Tue, 08 Nov 2016 06:59:00 GMT</td><td style="text-align:left">浏览器会携带该值去服务端比对，比对成功则返回304, 服务端提示浏览器从本地加载数据，否在返回200并响应数据。</td></tr></tbody></table><p>即: 浏览器会根据<code>Date</code>和<code>Last-Modified</code>之间的时间差值缓存一段时间，这段时间内会直接使用本地缓存数据而不会再去请求服务器(强制请求除外)，缓存过期后，会再次请求服务端，并携带上<code>Last-Modified</code>指定的时间去服务器对比并根据服务端的响应状态决定是否要从本地加载缓存数据。</p><h2 id="reference"><a href="#reference" class="headerlink" title="reference"></a>reference</h2><p>[1] 浏览器缓存机制</p><p><a href="http://www.cnblogs.com/skynet/archive/2012/11/28/2792503.html" target="_blank" rel="noopener">http://www.cnblogs.com/skynet/archive/2012/11/28/2792503.html</a></p><p>[2] Web 开发人员需知的 Web 缓存知识</p><p><a href="http://www.oschina.net/news/41397/web-cache-knowledge" target="_blank" rel="noopener">http://www.oschina.net/news/41397/web-cache-knowledge</a></p><p>[3] 浏览器缓存详解:expires,cache-control,last-modified,etag详细说明</p><p><a href="http://blog.csdn.net/eroswang/article/details/8302191" target="_blank" rel="noopener">http://blog.csdn.net/eroswang/article/details/8302191</a></p><p>[4] 在浏览器地址栏按回车、F5、Ctrl+F5刷新网页的区别</p><p><a href="http://cloudbbs.org/forum.php?mod=viewthread&amp;tid=15790" target="_blank" rel="noopener">http://cloudbbs.org/forum.php?mod=viewthread&amp;tid=15790</a></p><p><a href="http://blog.csdn.net/yui/article/details/6584401" target="_blank" rel="noopener">http://blog.csdn.net/yui/article/details/6584401</a></p><p>[5] Cache Control 與 ETag</p><p><a href="https://blog.othree.net/log/2012/12/22/cache-control-and-etag/" target="_blank" rel="noopener">https://blog.othree.net/log/2012/12/22/cache-control-and-etag/</a></p><p>[6] 缓存的故事</p><p><a href="http://segmentfault.com/blog/animabear/1190000000375344" target="_blank" rel="noopener">http://segmentfault.com/blog/animabear/1190000000375344</a></p><p>[7] Google的PageSpeed网站优化理论中提到使用Etag可以减少服务器负担</p><p><a href="https://developers.google.com/speed/docs/pss/AddEtags" target="_blank" rel="noopener">https://developers.google.com/speed/docs/pss/AddEtags</a></p><p>[8] yahoo的Yslow法则中则提示谨慎设置Etag</p><p><a href="http://developer.yahoo.com/performance/rules.html#etags" target="_blank" rel="noopener">http://developer.yahoo.com/performance/rules.html#etags</a></p><p>[9] H5 缓存机制浅析 移动端 Web 加载性能优化</p><p><a href="http://segmentfault.com/a/1190000004132566" target="_blank" rel="noopener">http://segmentfault.com/a/1190000004132566</a></p><p>[10] 网页性能： 缓存效率实践</p><p><a href="http://www.w3ctech.com/topic/1648" target="_blank" rel="noopener">http://www.w3ctech.com/topic/1648</a></p><p>[11] 透过浏览器看HTTP缓存</p><p><a href="http://www.cnblogs.com/skylar/p/browser-http-caching.html" target="_blank" rel="noopener">http://www.cnblogs.com/skylar/p/browser-http-caching.html</a></p><p>[12] 浏览器缓存知识小结及应用</p><p><a href="http://web.jobbole.com/84888/" target="_blank" rel="noopener">http://web.jobbole.com/84888/</a></p><p>[13] 大公司里怎样开发和部署前端代码？</p><p><a href="http://zhihu.com/question/20790576/answer/32602154?utm_campaign=webshare&amp;utm_source=weibo&amp;utm_medium=zhihu" target="_blank" rel="noopener">http://zhihu.com/question/20790576/answer/32602154?utm_campaign=webshare&amp;utm_source=weibo&amp;utm_medium=zhihu</a></p><p>[14] 浏览器缓存机制详解</p><p><a href="https://mangguo.org/browser-cache-mechanism-detailed/" target="_blank" rel="noopener">https://mangguo.org/browser-cache-mechanism-detailed/</a></p><p>[15] 关于缓存和 Chrome 的“新版刷新”</p><p><a href="http://www.cnblogs.com/ziyunfei/p/6308652.html" target="_blank" rel="noopener">http://www.cnblogs.com/ziyunfei/p/6308652.html</a></p><p>[16] HTTP缓存控制小结</p><p><a href="http://www.kuqin.com/shuoit/20160801/352684.html?url_type=39&amp;object_type=webpage&amp;pos=1" target="_blank" rel="noopener">http://www.kuqin.com/shuoit/20160801/352684.html?url_type=39&amp;object_type=webpage&amp;pos=1</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Http缓存机制作为web性能优化的重要手段, 本文对网络中，工作中使用的http缓存知识进行归纳总结。&lt;br&gt;
    
    </summary>
    
      <category term="DevOps" scheme="http://researchlab.github.io/categories/DevOps/"/>
    
    
      <category term="cache" scheme="http://researchlab.github.io/tags/cache/"/>
    
  </entry>
  
  <entry>
    <title>一致性哈希算法总结</title>
    <link href="http://researchlab.github.io/2017/01/16/consistent-hashing-summary/"/>
    <id>http://researchlab.github.io/2017/01/16/consistent-hashing-summary/</id>
    <published>2017-01-16T11:02:50.000Z</published>
    <updated>2018-10-16T13:03:07.481Z</updated>
    
    <content type="html"><![CDATA[<p>存在一种场景, 当一个缓存服务由多个服务器组共同提供时, key应该路由到哪一个服务。这里假如采用最通用的方式取模求余: <code>key%N</code>(N为服务器数目), 这样做均衡性没有什么问题, 但是当服务器数目发送增加或减少时, 分配方式则变为<code>key%(N+1)</code>或<code>key%(N-1)</code>。这里将会有大量的key失效迁移, 如果后端key对应的是有状态的存储数据,那么毫无疑问,这种做法将导致服务器间大量的数据迁移,从而造成服务的不稳定。解决思路，采用一致性哈希方法可以解决此问题。 </p><a id="more"></a><h2 id="算法原理"><a href="#算法原理" class="headerlink" title="算法原理"></a>算法原理</h2><p>一致性哈希算法在1997年由麻省理工学院提出的一种分布式哈希(DHT)实现算法，设计目标是为了解决因特网中的热点(Hot spot)问题，初衷和CARP十分类似。一致性哈希修正了CARP使用的简 单哈希算法带来的问题，使得分布式哈希(DHT)可以在P2P环境中真正得到应用。 </p><p>一致性hash算法提出了在动态变化的Cache环境中，判定哈希算法好坏的四个定义:</p><p>1.<code>平衡性(Balance)</code>: 平衡性是指哈希的结果能够尽可能分布到所有的缓冲中去，这样可以使得所有的缓冲空间都得到利用。很多哈希算法都能够满足这一条件。</p><p>2.<code>单调性(Monotonicity)</code>: 单调性是指如果已经有一些内容通过哈希分派到了相应的缓冲中，又有新的缓冲加入到系统中。哈希的结果应能够保证原有已分配的内容可以被映射到原有的或者新的缓冲中去，而不会被映射到旧的缓冲集合中的其他缓冲区。 </p><p>3.<code>分散性(Spread)</code>: 在分布式环境中，终端有可能看不到所有的缓冲，而是只能看到其中的一部分。当终端希望通过哈希过程将内容映射到缓冲上时，由于不同终端所见的缓冲范围有可能不同，从而导致哈希的结果不一致，最终的结果是相同的内容被不同的终端映射到不同的缓冲区中。这种情况显然是应该避免的，因为它导致相同内容被存储到不同缓冲中去，降低了系统存储的效率。分散性的定义就是上述情况发生的严重程度。好的哈希算法应能够尽量避免不一致的情况发生，也就是尽量降低分散性。 </p><p>4.<code>负载(Load)</code>: 负载问题实际上是从另一个角度看待分散性问题。既然不同的终端可能将相同的内容映射到不同的缓冲区中，那么对于一个特定的缓冲区而言，也可能被不同的用户映射为不同 的内容。与分散性一样，这种情况也是应当避免的，因此好的哈希算法应能够尽量降低缓冲的负荷。</p><p>在分布式集群中，对机器的添加删除，或者机器故障后自动脱离集群这些操作是分布式集群管理最基本的功能。如果采用常用的hash(object)%N算法，那么在有机器添加或者删除后，很多原有的数据就无法找到了，这样严重的违反了单调性原则。在移除/添加一个cache时，利用一致性哈希算法能够尽可能小的改变已存在key映射关系，尽可能的满足单调性的要求。</p><p>下面就来按照5个步骤简单讲讲 consistent hashing 算法的基本原理:</p><p><strong> 1 环形hash空间 </strong></p><p>考虑通常的hash算法都是将value映射到一个32位的key值, 也即是0~2^32-1次方的数值空间上; 可以将这个空间想象成一个首(0)尾(2^32-1)相接的圆环, 如图1所示,</p><center><img src="imgs/hashring.jpg" alt="hash ring">图1 环形hash空间</center><p><strong> 2 把对象映射到hash空间 </strong></p><p>接下来考虑4个对象object1~object4，通过hash函数计算出的hash值key在环上的分布如图2所示,</p><p>hash(object1) = key1;<br>… …<br>hash(object4) = key4;</p><center><img src="imgs/object.jpg" alt="hash ring">图2 4个对象的key值分布</center><p><strong> 3 把cache server映射到hash空间 </strong></p><p>一致性哈希算法的基本思想就是将对象和cache server都映射到同一个hash数值空间中，并且使用相同的hash算法。</p><p>假设当前有A, B和C共3台cache server，那么其映射结果将如图3所示，他们在hash空间中，以对应的hash值排列(一般采用升序，好便于后继将对象映射到相应的cache server上)。</p><p>hash(cache A) = key A;<br>… …<br>hash(cache C) = key C;</p><center><img src="imgs/cache.jpg" alt="hash ring">图3 cache server 和对象的key值分布</center><font color="red">通常cache server的hash计算, 是用cache机器的IP地址或机器名作为hash输入, 后继的实现案例中利用了cache server的IP地址作为参数因子。</font><p><strong> 4 把对象映射到cache server上 </strong></p><p>现在cache server和对象都已经通过同一个hash算法映射到hash数值空间中了，接下来要考虑的就是如何将对象映射到cache server上面了。<br>在这个环形空间中，如果沿着顺时针方向从对象的key值出发，直到遇见一个cache server，那么就将该对象存储在这个cache server上，因为对象和cache server的hash值是固定的，因此这个cache server必然是唯一和确定的。这样不就找到了对象和cache server的映射方法了吗?! (程序实现时可以对hash环进行升序排序， 然后按顺时针从对象的key值出发，找到与这个key相邻的第一个大于key值的cache server hash值，则将这个key值映射到这个cache server上)</p><p>依然继续上面的例子(参见图3)，那么根据上面的方法，对象object1将被存储到cache server A上; object2和 object3 对应到 cache  server C; object4 对应到 cache server B; </p><p><strong> 5 考察cache server的变动 </strong><br>前面讲过，通过hash求余的方法带来的最大问题就在于不能满足单调性，当cache server有所变动时，存储在原位置上的cache数据失效了，就需要做相应的迁移, 进而对后台服务器造成巨大的冲击，现在就来分析一致性哈希算法,</p><p>5.1 移除cache server </p><p>假设cache server B 挂掉了, 根据上面讲到的映射方法，这时受影响的将仅是那些沿cache server B 逆时针遍历直到下一个cache server (cache server A)之间的对象，也即是本来映射到cache  server B上的那些对象。</p><p>因此这里仅需要变动对象object4，将其重新映射到cache server C上即可; 参见图4。</p><center><img src="imgs/remove.jpg" alt="hash ring">图4 Cache server B被移除后的cache server映射</center><p>5.2 添加cache server</p><p>再考虑添加一台新的cache server D的情况，假设在这个环形hash空间中，cache server D被映射在对象object2和object3之间。这时受影响的将仅是那些沿cache server D逆时针遍历直到下一个cache server (cache server B)之间的对象(它们是也本来映射到cache server C上对象的一部分)，将这些对象重新映射到cache server D上即可。因此这里仅需要变动对象object2, 将其重新映射到cache server D上; 参见图5。</p><center><img src="imgs/add.jpg" alt="hash ring">图5 添加cache server D后的映射关系</center><p><strong> 6 虚拟节点 </strong></p><p>考量Hash算法的另一个指标是<code>平衡性(Balance)</code>，定义如下:<br><strong> 平衡性 </strong> 是指哈希的结果能够尽可能分布到所有的缓冲中去，这样可以使得所有的缓冲空间都得到利用, hash算法并不是保证绝对的平衡，如果cache server较少的话，对象并不能被均匀的映射到cache server上，比如在上面的例子中，仅部署cache server A 和 cache server C的情况下，在4个对象中，cache server A仅存储了object1，而cache server C则存储了object2, object3和object4; 分布是很不均衡的。</p><p>为了解决这种情况, 一致性哈希引入了”虚拟节点”的概念, 它可以如下定义:</p><font color="red">“虚拟节点”(virtual node)是实际节点在hash空间的复制品(replica)，一实际个节点对应了若干个”虚拟节点”，这个对应个数也成为”复制个数”，”虚拟节点”在hash空间中以hash值排列。</font><p>仍以仅部署cache server A 和cache server C 的情况为例, 在图4中我们已经看到, cache server分布并不均匀。现在我们引入虚拟节点，并设置”复制个数”为2，这就意味着一共会存在4个”虚拟节点”, cache server A1, cache server A2代表了cache server A; cache server C1, cache server C2代表了cache server C; 假设一种比较理想的情况，参见图6,</p><center><img src="imgs/virtual.jpg" alt="hash ring">图6 引入”虚拟节点”后的映射关系</center><p>此时, 对象到”虚拟节点”的映射关系为:</p><p>objec1-&gt;cache A2; objec2-&gt;cache A1; objec3-&gt;cache C1; objec4-&gt;cache C2; </p><p>因此对象object1和object2都被映射到了cache server A上，而object3和object4映射到了cache server C上; 平衡性有了很大提高。</p><p>引入”虚拟节点”后, 映射关系就从<code>{对象-&gt;节点}</code>转换到了<code>{对象-&gt;虚拟节点}</code>。查询物体所在cache server时的映射关系如图7所示,</p><center><img src="imgs/map.jpg" alt="object to virtual node">图7 查询对象所在cache server</center><p>“虚拟节点”的hash计算可以采用对应节点的IP地址加数字后缀的方式。例如假设cache server A 的IP地址为202.168.14.241。</p><p>引入”虚拟节点”前，计算cache server A的hash值:</p><p>Hash(“202.168.14.241”);</p><p>引入”虚拟节点”后，计算”虚拟节点”cache server A1和cache server A2的hash值:</p><p>Hash(“202.168.14.241-1-1”);  // cache server A1 [Hash(server_IP-virtual_node_id-physical-node-id)]</p><p>Hash(“202.168.14.241-2-1”);  // cache server A2 [Hash(server_IP-virtual_node_id-physical-node-id)]</p><h2 id="算法实现"><a href="#算法实现" class="headerlink" title="算法实现"></a>算法实现</h2><p>上面详细讲述了一致性哈希算法的原理，下面通过golang语言来实现一致性哈希算法，具体实现思想:<br>1.通过一致性哈希函数将这些cache server映射到一个哈希环上，并将这个哈希环按升序排序;<br>2.将待写入到cache server中的key-value值对象，可以用这个对象的key作为因子用上述同一个一致性哈希函数计算出一个hash值，然后按顺时针在哈希环上找到第一个大于这个hash值的cache server hash值;<br>3.通过找到的这个cache server hash值可以找到对应的cache server;<br>4.然后将上述的key-value对象存入到这个cache server中。 </p><p>具体实现过程大致可以分为一下几个步骤:</p><p>1.定义cache server节点实体, 用于计算cache server节点hash值的字符串;<br>2.定义一致性哈希结构，用于构建cache server的哈希环;<br>3.定义添加哈希节点的函数;<br>4.定义获取哈希节点的函数;<br>5.定义删除哈希节点的函数。</p><p>1.定义cache server节点实体,<br><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Node <span class="keyword">struct</span> &#123;</span><br><span class="line">  Id       <span class="keyword">int</span></span><br><span class="line">  Ip       <span class="keyword">string</span></span><br><span class="line">  Port     <span class="keyword">int</span></span><br><span class="line">  HostName <span class="keyword">string</span></span><br><span class="line">  Weight   <span class="keyword">int</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>上面定义了一个cache server node的实体, 作用是用于计算代表cache server node的唯一hash值, 在本程序中将采用缓存服务器的Id, IP, Weight以及虚拟节点Id作为计算字符串，说明如下:</p><p><code>Id</code>: 缓存服务器节点id<br><code>Ip</code>: 缓存服务器ip<br><code>Port</code>: 缓存服务器port<br><code>HostName</code>: 缓存服务器主机名(unique)<br><code>Weight</code>: 缓存服务器权重</p><p>2.定义一致性哈希结构，</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Consistent <span class="keyword">struct</span> &#123;</span><br><span class="line">  Nodes     <span class="keyword">map</span>[<span class="keyword">uint32</span>]Node</span><br><span class="line">  numReps   <span class="keyword">int</span></span><br><span class="line">  Resources <span class="keyword">map</span>[<span class="keyword">int</span>]<span class="keyword">bool</span></span><br><span class="line">  ring      HashRing</span><br><span class="line">  sync.RWMutex</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面定义了一致性哈希结构，说明如下,</p><p><code>Nodes</code>: 用于保存所有的hash-cache server node 映射关系<br><code>numReps</code>: 复制个数, 用于设置每个物理节点所虚拟的个数，即每个物理节点最后虚拟出多少个节点个数<br><code>Resources</code>: 用于标识当前物理节点是否已经被映射过了<br><code>ring</code>: 是一个切片数组， 用于保存所有的虚拟节点，即上面<code>Nodes</code>中的所有<code>key</code>值，可以通过这个<code>key</code>值到<code>Nodes</code>中去取对应的cache server信息，这个切片数组是排序过的，可以想象成一个环，及所谓的hash 环。<br><code>sync.RWMutex</code>: 读写锁，全部数据操作一致性。</p><p>3.定义添加哈希节点函数, 用于构建哈希环<br><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *Consistent)</span> <span class="title">Add</span><span class="params">(node *Node)</span> <span class="title">bool</span></span> &#123;</span><br><span class="line">c.Lock()</span><br><span class="line"><span class="keyword">defer</span> c.Unlock()</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> _, ok := c.Resources[node.Id]; ok &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">count := c.numReps * node.Weight</span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; count; i++ &#123;</span><br><span class="line">str := c.joinStr(i, node)</span><br><span class="line">c.Nodes[c.hashStr(str)] = *(node)</span><br><span class="line">&#125;</span><br><span class="line">c.Resources[node.Id] = <span class="literal">true</span></span><br><span class="line">c.sortHashRing()</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>上述添加哈希节点过程其实就是在计算一个一个cache server node的hash值，并构建排序过的哈希环， 大致分为以下几步:<br>1.检查当前物理节点是否已经被映射到哈希环上了，没有则进入下一步，<br>2.根据权重值计算出本物理节点的最终虚拟节点个数，然后分别计算对应虚拟节点的hash值,保存到<code>Nodes</code>结构中，<br>3.构建哈希环并排序，</p><p>4.定义获取哈希节点的函数, 用于将待存储的热点值存入到对应的cache server上,<br><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *Consistent)</span> <span class="title">Get</span><span class="params">(key <span class="keyword">string</span>)</span> <span class="title">Node</span></span> &#123;</span><br><span class="line">c.RLock()</span><br><span class="line"><span class="keyword">defer</span> c.RUnlock()</span><br><span class="line"></span><br><span class="line">hash := c.hashStr(key)</span><br><span class="line">hit_index := c.search(hash)</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> c.Nodes[c.ring[hit_index]]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>大致过程，<br>1.计算对象key的hash值，<br>2.根据上面计算的hash值，用二分搜索法到哈希环搜索自上述hash值起离它最近的一个cache server node hash值节点key，<br>3.根据查找到的cache server节点key, 返回<code>Nodes</code>结构中存储的cache sever信息，</p><p>5.定义删除哈希节点的函数, 当某个cache server 挂掉之后，用于删除这个节点(一般情况下不建议删除节点，而是将当前坏节点上的数据迁移到好的节点上)<br><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *Consistent)</span> <span class="title">Remove</span><span class="params">(node *Node)</span></span> &#123;</span><br><span class="line">c.Lock()</span><br><span class="line"><span class="keyword">defer</span> c.Unlock()</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> _, ok := c.Resources[node.Id]; !ok &#123;</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">delete</span>(c.Resources, node.Id)</span><br><span class="line"></span><br><span class="line">count := c.numReps * node.Weight</span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; count; i++ &#123;</span><br><span class="line">str := c.joinStr(i, node)</span><br><span class="line"><span class="built_in">delete</span>(c.Nodes, c.hashStr(str))</span><br><span class="line">&#125;</span><br><span class="line">c.sortHashRing()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>大致过程，<br>1.判断待删除物理节点是否存在哈希环中，存在则删除，并进入下一步，<br>2.删除改物理节点映射在哈希环中的所有虚拟节点,<br>3.重新排序哈希环,</p><p>至此一致性哈希算法基本实现， 详细代码请参见 <a href="https://github.com/researchlab/experiments/tree/master/consistent_hash" target="_blank" rel="noopener">https://github.com/researchlab/experiments/tree/master/consistent_hash</a></p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ul><li>详细阐述了一致性哈希算法实现原理及适合场景</li><li>采用slice + sort 方式构建哈希环，并用golang实现了一致性哈希算法</li><li>可以尝试采用红黑树的方式来构建哈希环，在性能上可能更好，有待进一步尝试 </li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;存在一种场景, 当一个缓存服务由多个服务器组共同提供时, key应该路由到哪一个服务。这里假如采用最通用的方式取模求余: &lt;code&gt;key%N&lt;/code&gt;(N为服务器数目), 这样做均衡性没有什么问题, 但是当服务器数目发送增加或减少时, 分配方式则变为&lt;code&gt;key%(N+1)&lt;/code&gt;或&lt;code&gt;key%(N-1)&lt;/code&gt;。这里将会有大量的key失效迁移, 如果后端key对应的是有状态的存储数据,那么毫无疑问,这种做法将导致服务器间大量的数据迁移,从而造成服务的不稳定。解决思路，采用一致性哈希方法可以解决此问题。 &lt;/p&gt;
    
    </summary>
    
      <category term="algorithm" scheme="http://researchlab.github.io/categories/algorithm/"/>
    
    
      <category term="golang" scheme="http://researchlab.github.io/tags/golang/"/>
    
      <category term="hash" scheme="http://researchlab.github.io/tags/hash/"/>
    
  </entry>
  
  <entry>
    <title>linux too many open files 问题解决总结</title>
    <link href="http://researchlab.github.io/2017/01/14/too-many-open-files-solution/"/>
    <id>http://researchlab.github.io/2017/01/14/too-many-open-files-solution/</id>
    <published>2017-01-14T10:58:37.000Z</published>
    <updated>2018-10-16T13:03:07.485Z</updated>
    
    <content type="html"><![CDATA[<p>运行在Linux系统上的网络程序可能会出现”Too many open files”的异常情况，且常见于高并发访问文件系统，多线程网络连接等场景。<br><a id="more"></a></p><h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><p>程序经常访问的文件、socket等在Linux中都是指的文件file，系统需要记录每个当前访问file的name、location、access authority等相关信息，这样的一个实体被称为file entry。<code>open files table</code>存储这些file entry，以数组的形式线性管理。文件描述符(file descriptor)是作为<code>进程</code>到<code>open files table</code>的指针，也就是<code>open files table</code>的下标索引，将每个进程与它所访问的文件关联起来了。 </p><center><img src="imgs/too-many-files.jpg" alt="too many open files theory"></center><p> 每个进程中都有一个<code>file descriptor table</code>管理当前进程所访问(open or create)的所有文件file，文件描述符关联着<code>open files table</code>中文件的file entry。对于<code>open files table</code>能容纳多少file entry, 可由Linux系统配置<code>open files table</code>的文件限制，如果超过配置值，就会拒绝其它文件操作的请求，并抛出Too many open files异常。这种限制有系统级和用户级之分。 </p><ul><li><p>系统级：<br>  系统级设置对所有用户有效。可通过两种方式查看系统最大文件限制<br>  1  cat /proc/sys/fs/file-max<br>  2  sysctl -a 查看结果中fs.file-max这项的配置数量<br>  如果需要增加配置数量就修改/etc/sysctl.conf文件，配置fs.file-max属性，如果属性不存在就添加, 配置完成后使用sysctl -p来通知系统启用这项配置 </p></li><li><p>用户级：<br>  Linux限制每个登录用户的可连接文件数。可通过<code>ulimit -n</code>来查看当前有效设置。如果想修改这个值就使用<code>ulimit -n &lt;setting number&gt;</code>命令。<br>  对于文件描述符增加的比例，资料推荐是以2的幂次为参考。如当前文件描述符数量是1024，可增加到2048，如果不够，可设置到4096，依此类推。<br>  在出现Too many open files问题后，首先得找出主要原因。最大的可能是打开的文件或是socket没有正常关闭。为了定位问题是否由目标网络进程引起，通过目标网络程序进程号查看当前进程占用文件描述符情况： </p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">lsof -p <span class="variable">$target_pid</span> <span class="comment">#每个文件描述符的具体属性</span></span><br><span class="line">lsof -p <span class="variable">$target_pid</span> | wc -l  <span class="comment">#当前目标网络进程file descriptor table中FD的总量</span></span><br></pre></td></tr></table></figure></li></ul><h2 id="解决方案总结"><a href="#解决方案总结" class="headerlink" title="解决方案总结"></a>解决方案总结</h2><p>方案一:</p><p>查看系统许可的最大文件限制， 如果不够可以修改此值。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[root nginx]<span class="comment"># cat /proc/sys/fs/file-max</span></span><br><span class="line">8096</span><br></pre></td></tr></table></figure></p><p>文件系统最大可打开文件数<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[root nginx]<span class="comment"># ulimit -n</span></span><br><span class="line">1024</span><br></pre></td></tr></table></figure></p><p>程序限制只能打开1024个文件</p><p>使用[root nginx]# ulimit -n 8096调整一下<br>或者永久调整打开文件数 可在启动文件/etc/rc.d/rc.local末尾添加（在/etc/sysctl.conf末尾添加fs.file-max=xxx无效）<br>ulimit -n 8096 </p><p>方案二:</p><p>Linux内核有时会报告<code>Too many open files</code>，起因是file-max默认值（8096）太小, 要解决这个问题，可以root身份执行下列命令（或将它们加入/etc/rcS.d/*下的init脚本。）</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">echo</span> <span class="string">"65536"</span>  &gt; /proc/sys/fs/file-max  <span class="comment"># 适用于2.2和2.4版内核</span></span><br><span class="line"><span class="comment">#或者</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">"131072"</span> &gt; /proc/sys/fs/inode-max <span class="comment"># 仅适用于2.2版内核</span></span><br></pre></td></tr></table></figure><p>方案三:</p><p>办法是修改操作系统的打开文件数量限制，方法如下:</p><p>1.按照最大打开文件数量的需求设置系统，并且通过检查/proc/sys/fs/file-max文件来确认最大打开文件数已经被正确设置。 </p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cat /proc/sys/fs/file-max</span><br></pre></td></tr></table></figure><p>如果设置值太小， 修改文件/etc/sysctl.conf的变量到合适的值。 这样会在每次重启之后生效。(如果设置值够大，跳过下步)</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">echo</span> 2048 &gt; /proc/sys/fs/file-max</span><br></pre></td></tr></table></figure><p>编辑文件/etc/sysctl.conf，整体修改如下:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#kernel2.6之后的内核版本添加如下配置：                                                                                                                                                                          </span></span><br><span class="line">net.nf_conntrack_max = 3276800                                                                                                                                                                                  </span><br><span class="line">net.netfilter.nf_conntrack_tcp_timeout_established = 1200                                                                                                                                                       </span><br><span class="line">                                                                                                                                                                                                                </span><br><span class="line"><span class="comment">#当出现SYN等待队列溢出时，启用cookies来处理，可防范少量SYN攻击，默认为0，表示关闭                                                                                                                               </span></span><br><span class="line">net.ipv4.tcp_syncookies = 1                                                                                                                                                                                     </span><br><span class="line"><span class="comment">#开启TCP连接中TIME-WAIT sockets的快速回收，默认为0，表示关闭。                                                                                                                                                  </span></span><br><span class="line">net.ipv4.tcp_tw_recycle = 1                                                                                                                                                                                     </span><br><span class="line"><span class="comment">#开启重用，将TIME-WAIT sockets重新用于新的TCP连接，默认为0，表示关闭；                                                                                                                                          </span></span><br><span class="line">net.ipv4.tcp_tw_reuse = 1                                                                                                                                                                                       </span><br><span class="line"><span class="comment">#修改系統默认的 TIMEOUT 时间                                                                                                                                                                                    </span></span><br><span class="line">net.ipv4.tcp_fin_timeout = 25                                                                                                                                                                                   </span><br><span class="line">net.ipv4.tcp_orphan_retries = 1                                                                                                                                                                                 </span><br><span class="line">net.ipv4.tcp_max_orphans = 8192                                                                                                                                                                                 </span><br><span class="line">net.ipv4.ip_local_port_range = 32768 61000                                                                                                                                                                      </span><br><span class="line">                                                                                                                                                                                                                </span><br><span class="line"><span class="comment"># Disabled ipV6                                                                                                                                                                                                 </span></span><br><span class="line">net.ipv6.conf.all.disable_ipv6 = 1                                                                                                                                                                              </span><br><span class="line">net.ipv6.conf.default.disable_ipv6 = 1                                                                                                                                                                          </span><br><span class="line">net.ipv6.conf.lo.disable_ipv6 = 1</span><br></pre></td></tr></table></figure><p>2.在/etc/security/limits.conf文件中设置最大打开文件数，添加如下这行:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">* - nofile 8192</span><br></pre></td></tr></table></figure><p>这行设置了每个用户的默认打开文件数为2048。注意<code>nofile</code>项有两个可能的限制措施。就是项下的hard和soft, 要使修改过的最大打开文件数生效，必须对这两种限制进行设定。 如果使用”-“字符设定, 则hard和soft设定会同时被设定。硬限制表明soft限制中所能设定的最大值。soft限制指的是当前系统生效的设置值。hard限制值可以被普通用户降低, 但是不能增加。soft限制不能设置的比hard限制更高。只有root用户才能够增加hard限制值。当增加文件限制描述，可以简单的把当前值双倍。 例: 如果你要提高默认值1024， 最好提高到2048， 如果还要继续增加， 就需要设置成4096。<br>另外一种情况是在创建索引的时候，也有两种可能，一种是合并因子太小，导致创建文件数量超过操作系统限制，这时可以修改合并因子，也可以修改操作系统的打开文件数限制；另外一种是合并因子受虚拟机内存的限制，无法调整到更大，而需要索引的doc数量又非常的大，这个时候就只能通过修改操作系统的打开文件数限制来解决了。</p><p>在此基础上，我还修改了以下一个配置文件</p><p>vim /etc/sysctl.conf, 添加：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Decrease the time default value for tcp_fin_timeout connection</span></span><br><span class="line">net.ipv4.tcp_fin_timeout = 30</span><br><span class="line"><span class="comment"># Decrease the time default value for tcp_keepalive_time connection</span></span><br><span class="line">net.ipv4.tcp_keepalive_time = 1800</span><br><span class="line"><span class="comment"># Turn off tcp_window_scaling</span></span><br><span class="line">net.ipv4.tcp_window_scaling = 0</span><br><span class="line"><span class="comment"># Turn off the tcp_sack</span></span><br><span class="line">net.ipv4.tcp_sack = 0</span><br><span class="line"><span class="comment">#Turn off tcp_timestamps</span></span><br><span class="line">net.ipv4.tcp_timestamps = 0</span><br></pre></td></tr></table></figure><p>然后 service network restart, 这些都和<code>TCP sockets</code>有关的优化。</p><p>另外需要在 /etc/rc.d/rc.local里添加已使得重启的时候生效。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">echo</span> <span class="string">"30"</span>&gt;/proc/sys/net/ipv4/tcp_fin_timeout</span><br><span class="line"><span class="built_in">echo</span> <span class="string">"1800"</span>&gt;/proc/sys/net/ipv4/tcp_keepalive_time</span><br><span class="line"><span class="built_in">echo</span> <span class="string">"0"</span>&gt;/proc/sys/net/ipv4/tcp_window_scaling</span><br><span class="line"><span class="built_in">echo</span> <span class="string">"0"</span>&gt;/proc/sys/net/ipv4/tcp_sack</span><br><span class="line"><span class="built_in">echo</span> <span class="string">"0"</span>&gt;/proc/sys/net/ipv4/tcp_timestamps</span><br></pre></td></tr></table></figure><p>因为不是所有的程序都在root下跑的，所有linux有对hard与soft open files的区分，普通用户受hard的限制，无论ulimit -n $数值调到多高，都跑不到 /etc/security/limits.conf里nofile的值。</p><p>这样的优化后 lsof -p $target_pid|wc -l可以跑到4千以上都不会抛出too many open files。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;运行在Linux系统上的网络程序可能会出现”Too many open files”的异常情况，且常见于高并发访问文件系统，多线程网络连接等场景。&lt;br&gt;
    
    </summary>
    
      <category term="DevOps" scheme="http://researchlab.github.io/categories/DevOps/"/>
    
    
      <category term="linux" scheme="http://researchlab.github.io/tags/linux/"/>
    
  </entry>
  
</feed>
